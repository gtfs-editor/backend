
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model UserProject
 * 
 */
export type UserProject = $Result.DefaultSelection<Prisma.$UserProjectPayload>
/**
 * Model ProjectShare
 * 
 */
export type ProjectShare = $Result.DefaultSelection<Prisma.$ProjectSharePayload>
/**
 * Model ProjectInvite
 * 
 */
export type ProjectInvite = $Result.DefaultSelection<Prisma.$ProjectInvitePayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model Stop
 * 
 */
export type Stop = $Result.DefaultSelection<Prisma.$StopPayload>
/**
 * Model Route
 * 
 */
export type Route = $Result.DefaultSelection<Prisma.$RoutePayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model StopTime
 * 
 */
export type StopTime = $Result.DefaultSelection<Prisma.$StopTimePayload>
/**
 * Model Calendar
 * 
 */
export type Calendar = $Result.DefaultSelection<Prisma.$CalendarPayload>
/**
 * Model CalendarDate
 * 
 */
export type CalendarDate = $Result.DefaultSelection<Prisma.$CalendarDatePayload>
/**
 * Model FareAttribute
 * 
 */
export type FareAttribute = $Result.DefaultSelection<Prisma.$FareAttributePayload>
/**
 * Model FareRule
 * 
 */
export type FareRule = $Result.DefaultSelection<Prisma.$FareRulePayload>
/**
 * Model Shape
 * 
 */
export type Shape = $Result.DefaultSelection<Prisma.$ShapePayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model Frequency
 * 
 */
export type Frequency = $Result.DefaultSelection<Prisma.$FrequencyPayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model Pathway
 * 
 */
export type Pathway = $Result.DefaultSelection<Prisma.$PathwayPayload>
/**
 * Model FeedInfo
 * 
 */
export type FeedInfo = $Result.DefaultSelection<Prisma.$FeedInfoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProjectRole: {
  OWNER: 'OWNER',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER'
};

export type ProjectRole = (typeof ProjectRole)[keyof typeof ProjectRole]

}

export type ProjectRole = $Enums.ProjectRole

export const ProjectRole: typeof $Enums.ProjectRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProject`: Exposes CRUD operations for the **UserProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProjects
    * const userProjects = await prisma.userProject.findMany()
    * ```
    */
  get userProject(): Prisma.UserProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectShare`: Exposes CRUD operations for the **ProjectShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectShares
    * const projectShares = await prisma.projectShare.findMany()
    * ```
    */
  get projectShare(): Prisma.ProjectShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectInvite`: Exposes CRUD operations for the **ProjectInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectInvites
    * const projectInvites = await prisma.projectInvite.findMany()
    * ```
    */
  get projectInvite(): Prisma.ProjectInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stop`: Exposes CRUD operations for the **Stop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stops
    * const stops = await prisma.stop.findMany()
    * ```
    */
  get stop(): Prisma.StopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stopTime`: Exposes CRUD operations for the **StopTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StopTimes
    * const stopTimes = await prisma.stopTime.findMany()
    * ```
    */
  get stopTime(): Prisma.StopTimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **Calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.CalendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarDate`: Exposes CRUD operations for the **CalendarDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarDates
    * const calendarDates = await prisma.calendarDate.findMany()
    * ```
    */
  get calendarDate(): Prisma.CalendarDateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fareAttribute`: Exposes CRUD operations for the **FareAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FareAttributes
    * const fareAttributes = await prisma.fareAttribute.findMany()
    * ```
    */
  get fareAttribute(): Prisma.FareAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fareRule`: Exposes CRUD operations for the **FareRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FareRules
    * const fareRules = await prisma.fareRule.findMany()
    * ```
    */
  get fareRule(): Prisma.FareRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shape`: Exposes CRUD operations for the **Shape** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shapes
    * const shapes = await prisma.shape.findMany()
    * ```
    */
  get shape(): Prisma.ShapeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.frequency`: Exposes CRUD operations for the **Frequency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Frequencies
    * const frequencies = await prisma.frequency.findMany()
    * ```
    */
  get frequency(): Prisma.FrequencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pathway`: Exposes CRUD operations for the **Pathway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pathways
    * const pathways = await prisma.pathway.findMany()
    * ```
    */
  get pathway(): Prisma.PathwayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedInfo`: Exposes CRUD operations for the **FeedInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedInfos
    * const feedInfos = await prisma.feedInfo.findMany()
    * ```
    */
  get feedInfo(): Prisma.FeedInfoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserPreferences: 'UserPreferences',
    UserProject: 'UserProject',
    ProjectShare: 'ProjectShare',
    ProjectInvite: 'ProjectInvite',
    PasswordReset: 'PasswordReset',
    UserSession: 'UserSession',
    Agency: 'Agency',
    Stop: 'Stop',
    Route: 'Route',
    Trip: 'Trip',
    StopTime: 'StopTime',
    Calendar: 'Calendar',
    CalendarDate: 'CalendarDate',
    FareAttribute: 'FareAttribute',
    FareRule: 'FareRule',
    Shape: 'Shape',
    Transfer: 'Transfer',
    Frequency: 'Frequency',
    Level: 'Level',
    Pathway: 'Pathway',
    FeedInfo: 'FeedInfo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userPreferences" | "userProject" | "projectShare" | "projectInvite" | "passwordReset" | "userSession" | "agency" | "stop" | "route" | "trip" | "stopTime" | "calendar" | "calendarDate" | "fareAttribute" | "fareRule" | "shape" | "transfer" | "frequency" | "level" | "pathway" | "feedInfo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      UserProject: {
        payload: Prisma.$UserProjectPayload<ExtArgs>
        fields: Prisma.UserProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>
          }
          findFirst: {
            args: Prisma.UserProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>
          }
          findMany: {
            args: Prisma.UserProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>[]
          }
          create: {
            args: Prisma.UserProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>
          }
          createMany: {
            args: Prisma.UserProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>[]
          }
          delete: {
            args: Prisma.UserProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>
          }
          update: {
            args: Prisma.UserProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>
          }
          deleteMany: {
            args: Prisma.UserProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>[]
          }
          upsert: {
            args: Prisma.UserProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProjectPayload>
          }
          aggregate: {
            args: Prisma.UserProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProject>
          }
          groupBy: {
            args: Prisma.UserProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProjectCountArgs<ExtArgs>
            result: $Utils.Optional<UserProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectShare: {
        payload: Prisma.$ProjectSharePayload<ExtArgs>
        fields: Prisma.ProjectShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>
          }
          findFirst: {
            args: Prisma.ProjectShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>
          }
          findMany: {
            args: Prisma.ProjectShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>[]
          }
          create: {
            args: Prisma.ProjectShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>
          }
          createMany: {
            args: Prisma.ProjectShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>[]
          }
          delete: {
            args: Prisma.ProjectShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>
          }
          update: {
            args: Prisma.ProjectShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>
          }
          deleteMany: {
            args: Prisma.ProjectShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>[]
          }
          upsert: {
            args: Prisma.ProjectShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSharePayload>
          }
          aggregate: {
            args: Prisma.ProjectShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectShare>
          }
          groupBy: {
            args: Prisma.ProjectShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectShareCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectShareCountAggregateOutputType> | number
          }
        }
      }
      ProjectInvite: {
        payload: Prisma.$ProjectInvitePayload<ExtArgs>
        fields: Prisma.ProjectInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
          }
          findFirst: {
            args: Prisma.ProjectInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
          }
          findMany: {
            args: Prisma.ProjectInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>[]
          }
          create: {
            args: Prisma.ProjectInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
          }
          createMany: {
            args: Prisma.ProjectInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>[]
          }
          delete: {
            args: Prisma.ProjectInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
          }
          update: {
            args: Prisma.ProjectInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
          }
          deleteMany: {
            args: Prisma.ProjectInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectInviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>[]
          }
          upsert: {
            args: Prisma.ProjectInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
          }
          aggregate: {
            args: Prisma.ProjectInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectInvite>
          }
          groupBy: {
            args: Prisma.ProjectInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectInviteCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectInviteCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      Stop: {
        payload: Prisma.$StopPayload<ExtArgs>
        fields: Prisma.StopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          findFirst: {
            args: Prisma.StopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          findMany: {
            args: Prisma.StopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>[]
          }
          create: {
            args: Prisma.StopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          createMany: {
            args: Prisma.StopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>[]
          }
          delete: {
            args: Prisma.StopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          update: {
            args: Prisma.StopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          deleteMany: {
            args: Prisma.StopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>[]
          }
          upsert: {
            args: Prisma.StopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          aggregate: {
            args: Prisma.StopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStop>
          }
          groupBy: {
            args: Prisma.StopGroupByArgs<ExtArgs>
            result: $Utils.Optional<StopGroupByOutputType>[]
          }
          count: {
            args: Prisma.StopCountArgs<ExtArgs>
            result: $Utils.Optional<StopCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: Prisma.$RoutePayload<ExtArgs>
        fields: Prisma.RouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      StopTime: {
        payload: Prisma.$StopTimePayload<ExtArgs>
        fields: Prisma.StopTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StopTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StopTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>
          }
          findFirst: {
            args: Prisma.StopTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StopTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>
          }
          findMany: {
            args: Prisma.StopTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>[]
          }
          create: {
            args: Prisma.StopTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>
          }
          createMany: {
            args: Prisma.StopTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StopTimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>[]
          }
          delete: {
            args: Prisma.StopTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>
          }
          update: {
            args: Prisma.StopTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>
          }
          deleteMany: {
            args: Prisma.StopTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StopTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StopTimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>[]
          }
          upsert: {
            args: Prisma.StopTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopTimePayload>
          }
          aggregate: {
            args: Prisma.StopTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStopTime>
          }
          groupBy: {
            args: Prisma.StopTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StopTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StopTimeCountArgs<ExtArgs>
            result: $Utils.Optional<StopTimeCountAggregateOutputType> | number
          }
        }
      }
      Calendar: {
        payload: Prisma.$CalendarPayload<ExtArgs>
        fields: Prisma.CalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findFirst: {
            args: Prisma.CalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findMany: {
            args: Prisma.CalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          create: {
            args: Prisma.CalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          createMany: {
            args: Prisma.CalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          delete: {
            args: Prisma.CalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          update: {
            args: Prisma.CalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          deleteMany: {
            args: Prisma.CalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          upsert: {
            args: Prisma.CalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          aggregate: {
            args: Prisma.CalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendar>
          }
          groupBy: {
            args: Prisma.CalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarCountAggregateOutputType> | number
          }
        }
      }
      CalendarDate: {
        payload: Prisma.$CalendarDatePayload<ExtArgs>
        fields: Prisma.CalendarDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>
          }
          findFirst: {
            args: Prisma.CalendarDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>
          }
          findMany: {
            args: Prisma.CalendarDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>[]
          }
          create: {
            args: Prisma.CalendarDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>
          }
          createMany: {
            args: Prisma.CalendarDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>[]
          }
          delete: {
            args: Prisma.CalendarDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>
          }
          update: {
            args: Prisma.CalendarDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>
          }
          deleteMany: {
            args: Prisma.CalendarDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarDateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>[]
          }
          upsert: {
            args: Prisma.CalendarDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarDatePayload>
          }
          aggregate: {
            args: Prisma.CalendarDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarDate>
          }
          groupBy: {
            args: Prisma.CalendarDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarDateCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarDateCountAggregateOutputType> | number
          }
        }
      }
      FareAttribute: {
        payload: Prisma.$FareAttributePayload<ExtArgs>
        fields: Prisma.FareAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FareAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FareAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>
          }
          findFirst: {
            args: Prisma.FareAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FareAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>
          }
          findMany: {
            args: Prisma.FareAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>[]
          }
          create: {
            args: Prisma.FareAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>
          }
          createMany: {
            args: Prisma.FareAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FareAttributeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>[]
          }
          delete: {
            args: Prisma.FareAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>
          }
          update: {
            args: Prisma.FareAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>
          }
          deleteMany: {
            args: Prisma.FareAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FareAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FareAttributeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>[]
          }
          upsert: {
            args: Prisma.FareAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareAttributePayload>
          }
          aggregate: {
            args: Prisma.FareAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFareAttribute>
          }
          groupBy: {
            args: Prisma.FareAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FareAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FareAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<FareAttributeCountAggregateOutputType> | number
          }
        }
      }
      FareRule: {
        payload: Prisma.$FareRulePayload<ExtArgs>
        fields: Prisma.FareRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FareRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FareRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>
          }
          findFirst: {
            args: Prisma.FareRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FareRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>
          }
          findMany: {
            args: Prisma.FareRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>[]
          }
          create: {
            args: Prisma.FareRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>
          }
          createMany: {
            args: Prisma.FareRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FareRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>[]
          }
          delete: {
            args: Prisma.FareRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>
          }
          update: {
            args: Prisma.FareRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>
          }
          deleteMany: {
            args: Prisma.FareRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FareRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FareRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>[]
          }
          upsert: {
            args: Prisma.FareRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FareRulePayload>
          }
          aggregate: {
            args: Prisma.FareRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFareRule>
          }
          groupBy: {
            args: Prisma.FareRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<FareRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.FareRuleCountArgs<ExtArgs>
            result: $Utils.Optional<FareRuleCountAggregateOutputType> | number
          }
        }
      }
      Shape: {
        payload: Prisma.$ShapePayload<ExtArgs>
        fields: Prisma.ShapeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShapeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShapeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>
          }
          findFirst: {
            args: Prisma.ShapeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShapeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>
          }
          findMany: {
            args: Prisma.ShapeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>[]
          }
          create: {
            args: Prisma.ShapeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>
          }
          createMany: {
            args: Prisma.ShapeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShapeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>[]
          }
          delete: {
            args: Prisma.ShapeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>
          }
          update: {
            args: Prisma.ShapeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>
          }
          deleteMany: {
            args: Prisma.ShapeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShapeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShapeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>[]
          }
          upsert: {
            args: Prisma.ShapeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShapePayload>
          }
          aggregate: {
            args: Prisma.ShapeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShape>
          }
          groupBy: {
            args: Prisma.ShapeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShapeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShapeCountArgs<ExtArgs>
            result: $Utils.Optional<ShapeCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      Frequency: {
        payload: Prisma.$FrequencyPayload<ExtArgs>
        fields: Prisma.FrequencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FrequencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FrequencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>
          }
          findFirst: {
            args: Prisma.FrequencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FrequencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>
          }
          findMany: {
            args: Prisma.FrequencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>[]
          }
          create: {
            args: Prisma.FrequencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>
          }
          createMany: {
            args: Prisma.FrequencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FrequencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>[]
          }
          delete: {
            args: Prisma.FrequencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>
          }
          update: {
            args: Prisma.FrequencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>
          }
          deleteMany: {
            args: Prisma.FrequencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FrequencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FrequencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>[]
          }
          upsert: {
            args: Prisma.FrequencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrequencyPayload>
          }
          aggregate: {
            args: Prisma.FrequencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFrequency>
          }
          groupBy: {
            args: Prisma.FrequencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FrequencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FrequencyCountArgs<ExtArgs>
            result: $Utils.Optional<FrequencyCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      Pathway: {
        payload: Prisma.$PathwayPayload<ExtArgs>
        fields: Prisma.PathwayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathwayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathwayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          findFirst: {
            args: Prisma.PathwayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathwayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          findMany: {
            args: Prisma.PathwayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>[]
          }
          create: {
            args: Prisma.PathwayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          createMany: {
            args: Prisma.PathwayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathwayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>[]
          }
          delete: {
            args: Prisma.PathwayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          update: {
            args: Prisma.PathwayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          deleteMany: {
            args: Prisma.PathwayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathwayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PathwayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>[]
          }
          upsert: {
            args: Prisma.PathwayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathwayPayload>
          }
          aggregate: {
            args: Prisma.PathwayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePathway>
          }
          groupBy: {
            args: Prisma.PathwayGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathwayGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathwayCountArgs<ExtArgs>
            result: $Utils.Optional<PathwayCountAggregateOutputType> | number
          }
        }
      }
      FeedInfo: {
        payload: Prisma.$FeedInfoPayload<ExtArgs>
        fields: Prisma.FeedInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>
          }
          findFirst: {
            args: Prisma.FeedInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>
          }
          findMany: {
            args: Prisma.FeedInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>[]
          }
          create: {
            args: Prisma.FeedInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>
          }
          createMany: {
            args: Prisma.FeedInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>[]
          }
          delete: {
            args: Prisma.FeedInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>
          }
          update: {
            args: Prisma.FeedInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>
          }
          deleteMany: {
            args: Prisma.FeedInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>[]
          }
          upsert: {
            args: Prisma.FeedInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedInfoPayload>
          }
          aggregate: {
            args: Prisma.FeedInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedInfo>
          }
          groupBy: {
            args: Prisma.FeedInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedInfoCountArgs<ExtArgs>
            result: $Utils.Optional<FeedInfoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userPreferences?: UserPreferencesOmit
    userProject?: UserProjectOmit
    projectShare?: ProjectShareOmit
    projectInvite?: ProjectInviteOmit
    passwordReset?: PasswordResetOmit
    userSession?: UserSessionOmit
    agency?: AgencyOmit
    stop?: StopOmit
    route?: RouteOmit
    trip?: TripOmit
    stopTime?: StopTimeOmit
    calendar?: CalendarOmit
    calendarDate?: CalendarDateOmit
    fareAttribute?: FareAttributeOmit
    fareRule?: FareRuleOmit
    shape?: ShapeOmit
    transfer?: TransferOmit
    frequency?: FrequencyOmit
    level?: LevelOmit
    pathway?: PathwayOmit
    feedInfo?: FeedInfoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedProjects: number
    sharedProjects: number
    invitedProjects: number
    passwordResets: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedProjects?: boolean | UserCountOutputTypeCountOwnedProjectsArgs
    sharedProjects?: boolean | UserCountOutputTypeCountSharedProjectsArgs
    invitedProjects?: boolean | UserCountOutputTypeCountInvitedProjectsArgs
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type UserProjectCountOutputType
   */

  export type UserProjectCountOutputType = {
    shares: number
    invites: number
    agencies: number
    stops: number
    routes: number
    trips: number
    stopTimes: number
    calendars: number
    calendarDates: number
    fareAttributes: number
    fareRules: number
    shapes: number
    transfers: number
    frequencies: number
    levels: number
    pathways: number
    feedInfo: number
  }

  export type UserProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shares?: boolean | UserProjectCountOutputTypeCountSharesArgs
    invites?: boolean | UserProjectCountOutputTypeCountInvitesArgs
    agencies?: boolean | UserProjectCountOutputTypeCountAgenciesArgs
    stops?: boolean | UserProjectCountOutputTypeCountStopsArgs
    routes?: boolean | UserProjectCountOutputTypeCountRoutesArgs
    trips?: boolean | UserProjectCountOutputTypeCountTripsArgs
    stopTimes?: boolean | UserProjectCountOutputTypeCountStopTimesArgs
    calendars?: boolean | UserProjectCountOutputTypeCountCalendarsArgs
    calendarDates?: boolean | UserProjectCountOutputTypeCountCalendarDatesArgs
    fareAttributes?: boolean | UserProjectCountOutputTypeCountFareAttributesArgs
    fareRules?: boolean | UserProjectCountOutputTypeCountFareRulesArgs
    shapes?: boolean | UserProjectCountOutputTypeCountShapesArgs
    transfers?: boolean | UserProjectCountOutputTypeCountTransfersArgs
    frequencies?: boolean | UserProjectCountOutputTypeCountFrequenciesArgs
    levels?: boolean | UserProjectCountOutputTypeCountLevelsArgs
    pathways?: boolean | UserProjectCountOutputTypeCountPathwaysArgs
    feedInfo?: boolean | UserProjectCountOutputTypeCountFeedInfoArgs
  }

  // Custom InputTypes
  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProjectCountOutputType
     */
    select?: UserProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectShareWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInviteWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountAgenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountStopTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopTimeWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountCalendarDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDateWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountFareAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareAttributeWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountFareRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareRuleWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountShapesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShapeWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountFrequenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FrequencyWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }

  /**
   * UserProjectCountOutputType without action
   */
  export type UserProjectCountOutputTypeCountFeedInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedInfoWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    routes: number
    fareAttributes: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routes?: boolean | AgencyCountOutputTypeCountRoutesArgs
    fareAttributes?: boolean | AgencyCountOutputTypeCountFareAttributesArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountFareAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareAttributeWhereInput
  }


  /**
   * Count Type StopCountOutputType
   */

  export type StopCountOutputType = {
    stopTimes: number
    transfers: number
    transfersTo: number
    pathways: number
    pathwaysTo: number
    childStops: number
  }

  export type StopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stopTimes?: boolean | StopCountOutputTypeCountStopTimesArgs
    transfers?: boolean | StopCountOutputTypeCountTransfersArgs
    transfersTo?: boolean | StopCountOutputTypeCountTransfersToArgs
    pathways?: boolean | StopCountOutputTypeCountPathwaysArgs
    pathwaysTo?: boolean | StopCountOutputTypeCountPathwaysToArgs
    childStops?: boolean | StopCountOutputTypeCountChildStopsArgs
  }

  // Custom InputTypes
  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopCountOutputType
     */
    select?: StopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountStopTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopTimeWhereInput
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountPathwaysToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountChildStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
  }


  /**
   * Count Type RouteCountOutputType
   */

  export type RouteCountOutputType = {
    trips: number
    fareRules: number
  }

  export type RouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | RouteCountOutputTypeCountTripsArgs
    fareRules?: boolean | RouteCountOutputTypeCountFareRulesArgs
  }

  // Custom InputTypes
  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCountOutputType
     */
    select?: RouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountFareRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareRuleWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    stopTimes: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stopTimes?: boolean | TripCountOutputTypeCountStopTimesArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountStopTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopTimeWhereInput
  }


  /**
   * Count Type CalendarCountOutputType
   */

  export type CalendarCountOutputType = {
    trips: number
    exceptions: number
  }

  export type CalendarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | CalendarCountOutputTypeCountTripsArgs
    exceptions?: boolean | CalendarCountOutputTypeCountExceptionsArgs
  }

  // Custom InputTypes
  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCountOutputType
     */
    select?: CalendarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountExceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDateWhereInput
  }


  /**
   * Count Type FareAttributeCountOutputType
   */

  export type FareAttributeCountOutputType = {
    fareRules: number
  }

  export type FareAttributeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fareRules?: boolean | FareAttributeCountOutputTypeCountFareRulesArgs
  }

  // Custom InputTypes
  /**
   * FareAttributeCountOutputType without action
   */
  export type FareAttributeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttributeCountOutputType
     */
    select?: FareAttributeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FareAttributeCountOutputType without action
   */
  export type FareAttributeCountOutputTypeCountFareRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareRuleWhereInput
  }


  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    stops: number
    pathways: number
  }

  export type LevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stops?: boolean | LevelCountOutputTypeCountStopsArgs
    pathways?: boolean | LevelCountOutputTypeCountPathwaysArgs
  }

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountPathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password_hash: string | null
    avatar_url: string | null
    first_name: string | null
    last_name: string | null
    is_active: boolean | null
    is_verified: boolean | null
    last_login: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password_hash: string | null
    avatar_url: string | null
    first_name: string | null
    last_name: string | null
    is_active: boolean | null
    is_verified: boolean | null
    last_login: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password_hash: number
    avatar_url: number
    first_name: number
    last_name: number
    is_active: number
    is_verified: number
    last_login: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password_hash?: true
    avatar_url?: true
    first_name?: true
    last_name?: true
    is_active?: true
    is_verified?: true
    last_login?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password_hash?: true
    avatar_url?: true
    first_name?: true
    last_name?: true
    is_active?: true
    is_verified?: true
    last_login?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password_hash?: true
    avatar_url?: true
    first_name?: true
    last_name?: true
    is_active?: true
    is_verified?: true
    last_login?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password_hash: string
    avatar_url: string | null
    first_name: string | null
    last_name: string | null
    is_active: boolean
    is_verified: boolean
    last_login: Date | null
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    avatar_url?: boolean
    first_name?: boolean
    last_name?: boolean
    is_active?: boolean
    is_verified?: boolean
    last_login?: boolean
    created_at?: boolean
    updated_at?: boolean
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    sharedProjects?: boolean | User$sharedProjectsArgs<ExtArgs>
    invitedProjects?: boolean | User$invitedProjectsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    avatar_url?: boolean
    first_name?: boolean
    last_name?: boolean
    is_active?: boolean
    is_verified?: boolean
    last_login?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    avatar_url?: boolean
    first_name?: boolean
    last_name?: boolean
    is_active?: boolean
    is_verified?: boolean
    last_login?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    avatar_url?: boolean
    first_name?: boolean
    last_name?: boolean
    is_active?: boolean
    is_verified?: boolean
    last_login?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password_hash" | "avatar_url" | "first_name" | "last_name" | "is_active" | "is_verified" | "last_login" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    sharedProjects?: boolean | User$sharedProjectsArgs<ExtArgs>
    invitedProjects?: boolean | User$invitedProjectsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      preferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      ownedProjects: Prisma.$UserProjectPayload<ExtArgs>[]
      sharedProjects: Prisma.$ProjectSharePayload<ExtArgs>[]
      invitedProjects: Prisma.$ProjectInvitePayload<ExtArgs>[]
      passwordResets: Prisma.$PasswordResetPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password_hash: string
      avatar_url: string | null
      first_name: string | null
      last_name: string | null
      is_active: boolean
      is_verified: boolean
      last_login: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedProjects<T extends User$ownedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedProjects<T extends User$sharedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitedProjects<T extends User$invitedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly avatar_url: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly is_verified: FieldRef<"User", 'Boolean'>
    readonly last_login: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.ownedProjects
   */
  export type User$ownedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    where?: UserProjectWhereInput
    orderBy?: UserProjectOrderByWithRelationInput | UserProjectOrderByWithRelationInput[]
    cursor?: UserProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProjectScalarFieldEnum | UserProjectScalarFieldEnum[]
  }

  /**
   * User.sharedProjects
   */
  export type User$sharedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    where?: ProjectShareWhereInput
    orderBy?: ProjectShareOrderByWithRelationInput | ProjectShareOrderByWithRelationInput[]
    cursor?: ProjectShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectShareScalarFieldEnum | ProjectShareScalarFieldEnum[]
  }

  /**
   * User.invitedProjects
   */
  export type User$invitedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    where?: ProjectInviteWhereInput
    orderBy?: ProjectInviteOrderByWithRelationInput | ProjectInviteOrderByWithRelationInput[]
    cursor?: ProjectInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInviteScalarFieldEnum | ProjectInviteScalarFieldEnum[]
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    cursor?: PasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    map_default_lat: number | null
    map_default_lon: number | null
    map_default_zoom: number | null
    table_page_size: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    map_default_lat: number | null
    map_default_lon: number | null
    map_default_zoom: number | null
    table_page_size: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    theme: string | null
    language: string | null
    timezone: string | null
    map_default_lat: number | null
    map_default_lon: number | null
    map_default_zoom: number | null
    table_page_size: number | null
    notifications: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    theme: string | null
    language: string | null
    timezone: string | null
    map_default_lat: number | null
    map_default_lon: number | null
    map_default_zoom: number | null
    table_page_size: number | null
    notifications: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    user_id: number
    theme: number
    language: number
    timezone: number
    map_default_lat: number
    map_default_lon: number
    map_default_zoom: number
    table_page_size: number
    notifications: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    map_default_lat?: true
    map_default_lon?: true
    map_default_zoom?: true
    table_page_size?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    map_default_lat?: true
    map_default_lon?: true
    map_default_zoom?: true
    table_page_size?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    user_id?: true
    theme?: true
    language?: true
    timezone?: true
    map_default_lat?: true
    map_default_lon?: true
    map_default_zoom?: true
    table_page_size?: true
    notifications?: true
    created_at?: true
    updated_at?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    user_id?: true
    theme?: true
    language?: true
    timezone?: true
    map_default_lat?: true
    map_default_lon?: true
    map_default_zoom?: true
    table_page_size?: true
    notifications?: true
    created_at?: true
    updated_at?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    user_id?: true
    theme?: true
    language?: true
    timezone?: true
    map_default_lat?: true
    map_default_lon?: true
    map_default_zoom?: true
    table_page_size?: true
    notifications?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    user_id: string
    theme: string
    language: string
    timezone: string
    map_default_lat: number
    map_default_lon: number
    map_default_zoom: number
    table_page_size: number
    notifications: boolean
    created_at: Date
    updated_at: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    map_default_lat?: boolean
    map_default_lon?: boolean
    map_default_zoom?: boolean
    table_page_size?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    map_default_lat?: boolean
    map_default_lon?: boolean
    map_default_zoom?: boolean
    table_page_size?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    map_default_lat?: boolean
    map_default_lon?: boolean
    map_default_zoom?: boolean
    table_page_size?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    user_id?: boolean
    theme?: boolean
    language?: boolean
    timezone?: boolean
    map_default_lat?: boolean
    map_default_lon?: boolean
    map_default_zoom?: boolean
    table_page_size?: boolean
    notifications?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "theme" | "language" | "timezone" | "map_default_lat" | "map_default_lon" | "map_default_zoom" | "table_page_size" | "notifications" | "created_at" | "updated_at", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      theme: string
      language: string
      timezone: string
      map_default_lat: number
      map_default_lon: number
      map_default_zoom: number
      table_page_size: number
      notifications: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly user_id: FieldRef<"UserPreferences", 'String'>
    readonly theme: FieldRef<"UserPreferences", 'String'>
    readonly language: FieldRef<"UserPreferences", 'String'>
    readonly timezone: FieldRef<"UserPreferences", 'String'>
    readonly map_default_lat: FieldRef<"UserPreferences", 'Float'>
    readonly map_default_lon: FieldRef<"UserPreferences", 'Float'>
    readonly map_default_zoom: FieldRef<"UserPreferences", 'Int'>
    readonly table_page_size: FieldRef<"UserPreferences", 'Int'>
    readonly notifications: FieldRef<"UserPreferences", 'Boolean'>
    readonly created_at: FieldRef<"UserPreferences", 'DateTime'>
    readonly updated_at: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model UserProject
   */

  export type AggregateUserProject = {
    _count: UserProjectCountAggregateOutputType | null
    _min: UserProjectMinAggregateOutputType | null
    _max: UserProjectMaxAggregateOutputType | null
  }

  export type UserProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    owner_id: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    owner_id: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    owner_id: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    owner_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UserProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    owner_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UserProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    owner_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProject to aggregate.
     */
    where?: UserProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProjects to fetch.
     */
    orderBy?: UserProjectOrderByWithRelationInput | UserProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProjects
    **/
    _count?: true | UserProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProjectMaxAggregateInputType
  }

  export type GetUserProjectAggregateType<T extends UserProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProject[P]>
      : GetScalarType<T[P], AggregateUserProject[P]>
  }




  export type UserProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProjectWhereInput
    orderBy?: UserProjectOrderByWithAggregationInput | UserProjectOrderByWithAggregationInput[]
    by: UserProjectScalarFieldEnum[] | UserProjectScalarFieldEnum
    having?: UserProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProjectCountAggregateInputType | true
    _min?: UserProjectMinAggregateInputType
    _max?: UserProjectMaxAggregateInputType
  }

  export type UserProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    owner_id: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: UserProjectCountAggregateOutputType | null
    _min: UserProjectMinAggregateOutputType | null
    _max: UserProjectMaxAggregateOutputType | null
  }

  type GetUserProjectGroupByPayload<T extends UserProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProjectGroupByOutputType[P]>
            : GetScalarType<T[P], UserProjectGroupByOutputType[P]>
        }
      >
    >


  export type UserProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    owner_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    shares?: boolean | UserProject$sharesArgs<ExtArgs>
    invites?: boolean | UserProject$invitesArgs<ExtArgs>
    agencies?: boolean | UserProject$agenciesArgs<ExtArgs>
    stops?: boolean | UserProject$stopsArgs<ExtArgs>
    routes?: boolean | UserProject$routesArgs<ExtArgs>
    trips?: boolean | UserProject$tripsArgs<ExtArgs>
    stopTimes?: boolean | UserProject$stopTimesArgs<ExtArgs>
    calendars?: boolean | UserProject$calendarsArgs<ExtArgs>
    calendarDates?: boolean | UserProject$calendarDatesArgs<ExtArgs>
    fareAttributes?: boolean | UserProject$fareAttributesArgs<ExtArgs>
    fareRules?: boolean | UserProject$fareRulesArgs<ExtArgs>
    shapes?: boolean | UserProject$shapesArgs<ExtArgs>
    transfers?: boolean | UserProject$transfersArgs<ExtArgs>
    frequencies?: boolean | UserProject$frequenciesArgs<ExtArgs>
    levels?: boolean | UserProject$levelsArgs<ExtArgs>
    pathways?: boolean | UserProject$pathwaysArgs<ExtArgs>
    feedInfo?: boolean | UserProject$feedInfoArgs<ExtArgs>
    _count?: boolean | UserProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProject"]>

  export type UserProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    owner_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProject"]>

  export type UserProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    owner_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProject"]>

  export type UserProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    owner_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "owner_id" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["userProject"]>
  export type UserProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    shares?: boolean | UserProject$sharesArgs<ExtArgs>
    invites?: boolean | UserProject$invitesArgs<ExtArgs>
    agencies?: boolean | UserProject$agenciesArgs<ExtArgs>
    stops?: boolean | UserProject$stopsArgs<ExtArgs>
    routes?: boolean | UserProject$routesArgs<ExtArgs>
    trips?: boolean | UserProject$tripsArgs<ExtArgs>
    stopTimes?: boolean | UserProject$stopTimesArgs<ExtArgs>
    calendars?: boolean | UserProject$calendarsArgs<ExtArgs>
    calendarDates?: boolean | UserProject$calendarDatesArgs<ExtArgs>
    fareAttributes?: boolean | UserProject$fareAttributesArgs<ExtArgs>
    fareRules?: boolean | UserProject$fareRulesArgs<ExtArgs>
    shapes?: boolean | UserProject$shapesArgs<ExtArgs>
    transfers?: boolean | UserProject$transfersArgs<ExtArgs>
    frequencies?: boolean | UserProject$frequenciesArgs<ExtArgs>
    levels?: boolean | UserProject$levelsArgs<ExtArgs>
    pathways?: boolean | UserProject$pathwaysArgs<ExtArgs>
    feedInfo?: boolean | UserProject$feedInfoArgs<ExtArgs>
    _count?: boolean | UserProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProject"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      shares: Prisma.$ProjectSharePayload<ExtArgs>[]
      invites: Prisma.$ProjectInvitePayload<ExtArgs>[]
      agencies: Prisma.$AgencyPayload<ExtArgs>[]
      stops: Prisma.$StopPayload<ExtArgs>[]
      routes: Prisma.$RoutePayload<ExtArgs>[]
      trips: Prisma.$TripPayload<ExtArgs>[]
      stopTimes: Prisma.$StopTimePayload<ExtArgs>[]
      calendars: Prisma.$CalendarPayload<ExtArgs>[]
      calendarDates: Prisma.$CalendarDatePayload<ExtArgs>[]
      fareAttributes: Prisma.$FareAttributePayload<ExtArgs>[]
      fareRules: Prisma.$FareRulePayload<ExtArgs>[]
      shapes: Prisma.$ShapePayload<ExtArgs>[]
      transfers: Prisma.$TransferPayload<ExtArgs>[]
      frequencies: Prisma.$FrequencyPayload<ExtArgs>[]
      levels: Prisma.$LevelPayload<ExtArgs>[]
      pathways: Prisma.$PathwayPayload<ExtArgs>[]
      feedInfo: Prisma.$FeedInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      owner_id: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["userProject"]>
    composites: {}
  }

  type UserProjectGetPayload<S extends boolean | null | undefined | UserProjectDefaultArgs> = $Result.GetResult<Prisma.$UserProjectPayload, S>

  type UserProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProjectCountAggregateInputType | true
    }

  export interface UserProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProject'], meta: { name: 'UserProject' } }
    /**
     * Find zero or one UserProject that matches the filter.
     * @param {UserProjectFindUniqueArgs} args - Arguments to find a UserProject
     * @example
     * // Get one UserProject
     * const userProject = await prisma.userProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProjectFindUniqueArgs>(args: SelectSubset<T, UserProjectFindUniqueArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProjectFindUniqueOrThrowArgs} args - Arguments to find a UserProject
     * @example
     * // Get one UserProject
     * const userProject = await prisma.userProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectFindFirstArgs} args - Arguments to find a UserProject
     * @example
     * // Get one UserProject
     * const userProject = await prisma.userProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProjectFindFirstArgs>(args?: SelectSubset<T, UserProjectFindFirstArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectFindFirstOrThrowArgs} args - Arguments to find a UserProject
     * @example
     * // Get one UserProject
     * const userProject = await prisma.userProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProjects
     * const userProjects = await prisma.userProject.findMany()
     * 
     * // Get first 10 UserProjects
     * const userProjects = await prisma.userProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProjectWithIdOnly = await prisma.userProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProjectFindManyArgs>(args?: SelectSubset<T, UserProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProject.
     * @param {UserProjectCreateArgs} args - Arguments to create a UserProject.
     * @example
     * // Create one UserProject
     * const UserProject = await prisma.userProject.create({
     *   data: {
     *     // ... data to create a UserProject
     *   }
     * })
     * 
     */
    create<T extends UserProjectCreateArgs>(args: SelectSubset<T, UserProjectCreateArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProjects.
     * @param {UserProjectCreateManyArgs} args - Arguments to create many UserProjects.
     * @example
     * // Create many UserProjects
     * const userProject = await prisma.userProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProjectCreateManyArgs>(args?: SelectSubset<T, UserProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProjects and returns the data saved in the database.
     * @param {UserProjectCreateManyAndReturnArgs} args - Arguments to create many UserProjects.
     * @example
     * // Create many UserProjects
     * const userProject = await prisma.userProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProjects and only return the `id`
     * const userProjectWithIdOnly = await prisma.userProject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProject.
     * @param {UserProjectDeleteArgs} args - Arguments to delete one UserProject.
     * @example
     * // Delete one UserProject
     * const UserProject = await prisma.userProject.delete({
     *   where: {
     *     // ... filter to delete one UserProject
     *   }
     * })
     * 
     */
    delete<T extends UserProjectDeleteArgs>(args: SelectSubset<T, UserProjectDeleteArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProject.
     * @param {UserProjectUpdateArgs} args - Arguments to update one UserProject.
     * @example
     * // Update one UserProject
     * const userProject = await prisma.userProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProjectUpdateArgs>(args: SelectSubset<T, UserProjectUpdateArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProjects.
     * @param {UserProjectDeleteManyArgs} args - Arguments to filter UserProjects to delete.
     * @example
     * // Delete a few UserProjects
     * const { count } = await prisma.userProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProjectDeleteManyArgs>(args?: SelectSubset<T, UserProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProjects
     * const userProject = await prisma.userProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProjectUpdateManyArgs>(args: SelectSubset<T, UserProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProjects and returns the data updated in the database.
     * @param {UserProjectUpdateManyAndReturnArgs} args - Arguments to update many UserProjects.
     * @example
     * // Update many UserProjects
     * const userProject = await prisma.userProject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProjects and only return the `id`
     * const userProjectWithIdOnly = await prisma.userProject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProject.
     * @param {UserProjectUpsertArgs} args - Arguments to update or create a UserProject.
     * @example
     * // Update or create a UserProject
     * const userProject = await prisma.userProject.upsert({
     *   create: {
     *     // ... data to create a UserProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProject we want to update
     *   }
     * })
     */
    upsert<T extends UserProjectUpsertArgs>(args: SelectSubset<T, UserProjectUpsertArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectCountArgs} args - Arguments to filter UserProjects to count.
     * @example
     * // Count the number of UserProjects
     * const count = await prisma.userProject.count({
     *   where: {
     *     // ... the filter for the UserProjects we want to count
     *   }
     * })
    **/
    count<T extends UserProjectCountArgs>(
      args?: Subset<T, UserProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProjectAggregateArgs>(args: Subset<T, UserProjectAggregateArgs>): Prisma.PrismaPromise<GetUserProjectAggregateType<T>>

    /**
     * Group by UserProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProjectGroupByArgs['orderBy'] }
        : { orderBy?: UserProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProject model
   */
  readonly fields: UserProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shares<T extends UserProject$sharesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends UserProject$invitesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agencies<T extends UserProject$agenciesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$agenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stops<T extends UserProject$stopsArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    routes<T extends UserProject$routesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$routesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trips<T extends UserProject$tripsArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stopTimes<T extends UserProject$stopTimesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$stopTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendars<T extends UserProject$calendarsArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$calendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendarDates<T extends UserProject$calendarDatesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$calendarDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fareAttributes<T extends UserProject$fareAttributesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$fareAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fareRules<T extends UserProject$fareRulesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$fareRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shapes<T extends UserProject$shapesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$shapesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfers<T extends UserProject$transfersArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    frequencies<T extends UserProject$frequenciesArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$frequenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    levels<T extends UserProject$levelsArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pathways<T extends UserProject$pathwaysArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$pathwaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedInfo<T extends UserProject$feedInfoArgs<ExtArgs> = {}>(args?: Subset<T, UserProject$feedInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProject model
   */
  interface UserProjectFieldRefs {
    readonly id: FieldRef<"UserProject", 'String'>
    readonly name: FieldRef<"UserProject", 'String'>
    readonly description: FieldRef<"UserProject", 'String'>
    readonly owner_id: FieldRef<"UserProject", 'String'>
    readonly is_active: FieldRef<"UserProject", 'Boolean'>
    readonly created_at: FieldRef<"UserProject", 'DateTime'>
    readonly updated_at: FieldRef<"UserProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProject findUnique
   */
  export type UserProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserProject to fetch.
     */
    where: UserProjectWhereUniqueInput
  }

  /**
   * UserProject findUniqueOrThrow
   */
  export type UserProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserProject to fetch.
     */
    where: UserProjectWhereUniqueInput
  }

  /**
   * UserProject findFirst
   */
  export type UserProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserProject to fetch.
     */
    where?: UserProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProjects to fetch.
     */
    orderBy?: UserProjectOrderByWithRelationInput | UserProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProjects.
     */
    cursor?: UserProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProjects.
     */
    distinct?: UserProjectScalarFieldEnum | UserProjectScalarFieldEnum[]
  }

  /**
   * UserProject findFirstOrThrow
   */
  export type UserProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserProject to fetch.
     */
    where?: UserProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProjects to fetch.
     */
    orderBy?: UserProjectOrderByWithRelationInput | UserProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProjects.
     */
    cursor?: UserProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProjects.
     */
    distinct?: UserProjectScalarFieldEnum | UserProjectScalarFieldEnum[]
  }

  /**
   * UserProject findMany
   */
  export type UserProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * Filter, which UserProjects to fetch.
     */
    where?: UserProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProjects to fetch.
     */
    orderBy?: UserProjectOrderByWithRelationInput | UserProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProjects.
     */
    cursor?: UserProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProjects.
     */
    skip?: number
    distinct?: UserProjectScalarFieldEnum | UserProjectScalarFieldEnum[]
  }

  /**
   * UserProject create
   */
  export type UserProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProject.
     */
    data: XOR<UserProjectCreateInput, UserProjectUncheckedCreateInput>
  }

  /**
   * UserProject createMany
   */
  export type UserProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProjects.
     */
    data: UserProjectCreateManyInput | UserProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProject createManyAndReturn
   */
  export type UserProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * The data used to create many UserProjects.
     */
    data: UserProjectCreateManyInput | UserProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProject update
   */
  export type UserProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProject.
     */
    data: XOR<UserProjectUpdateInput, UserProjectUncheckedUpdateInput>
    /**
     * Choose, which UserProject to update.
     */
    where: UserProjectWhereUniqueInput
  }

  /**
   * UserProject updateMany
   */
  export type UserProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProjects.
     */
    data: XOR<UserProjectUpdateManyMutationInput, UserProjectUncheckedUpdateManyInput>
    /**
     * Filter which UserProjects to update
     */
    where?: UserProjectWhereInput
    /**
     * Limit how many UserProjects to update.
     */
    limit?: number
  }

  /**
   * UserProject updateManyAndReturn
   */
  export type UserProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * The data used to update UserProjects.
     */
    data: XOR<UserProjectUpdateManyMutationInput, UserProjectUncheckedUpdateManyInput>
    /**
     * Filter which UserProjects to update
     */
    where?: UserProjectWhereInput
    /**
     * Limit how many UserProjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProject upsert
   */
  export type UserProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProject to update in case it exists.
     */
    where: UserProjectWhereUniqueInput
    /**
     * In case the UserProject found by the `where` argument doesn't exist, create a new UserProject with this data.
     */
    create: XOR<UserProjectCreateInput, UserProjectUncheckedCreateInput>
    /**
     * In case the UserProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProjectUpdateInput, UserProjectUncheckedUpdateInput>
  }

  /**
   * UserProject delete
   */
  export type UserProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
    /**
     * Filter which UserProject to delete.
     */
    where: UserProjectWhereUniqueInput
  }

  /**
   * UserProject deleteMany
   */
  export type UserProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProjects to delete
     */
    where?: UserProjectWhereInput
    /**
     * Limit how many UserProjects to delete.
     */
    limit?: number
  }

  /**
   * UserProject.shares
   */
  export type UserProject$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    where?: ProjectShareWhereInput
    orderBy?: ProjectShareOrderByWithRelationInput | ProjectShareOrderByWithRelationInput[]
    cursor?: ProjectShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectShareScalarFieldEnum | ProjectShareScalarFieldEnum[]
  }

  /**
   * UserProject.invites
   */
  export type UserProject$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    where?: ProjectInviteWhereInput
    orderBy?: ProjectInviteOrderByWithRelationInput | ProjectInviteOrderByWithRelationInput[]
    cursor?: ProjectInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInviteScalarFieldEnum | ProjectInviteScalarFieldEnum[]
  }

  /**
   * UserProject.agencies
   */
  export type UserProject$agenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    cursor?: AgencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * UserProject.stops
   */
  export type UserProject$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    cursor?: StopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * UserProject.routes
   */
  export type UserProject$routesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    cursor?: RouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * UserProject.trips
   */
  export type UserProject$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * UserProject.stopTimes
   */
  export type UserProject$stopTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    where?: StopTimeWhereInput
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    cursor?: StopTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopTimeScalarFieldEnum | StopTimeScalarFieldEnum[]
  }

  /**
   * UserProject.calendars
   */
  export type UserProject$calendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * UserProject.calendarDates
   */
  export type UserProject$calendarDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    where?: CalendarDateWhereInput
    orderBy?: CalendarDateOrderByWithRelationInput | CalendarDateOrderByWithRelationInput[]
    cursor?: CalendarDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarDateScalarFieldEnum | CalendarDateScalarFieldEnum[]
  }

  /**
   * UserProject.fareAttributes
   */
  export type UserProject$fareAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    where?: FareAttributeWhereInput
    orderBy?: FareAttributeOrderByWithRelationInput | FareAttributeOrderByWithRelationInput[]
    cursor?: FareAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareAttributeScalarFieldEnum | FareAttributeScalarFieldEnum[]
  }

  /**
   * UserProject.fareRules
   */
  export type UserProject$fareRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    where?: FareRuleWhereInput
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    cursor?: FareRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareRuleScalarFieldEnum | FareRuleScalarFieldEnum[]
  }

  /**
   * UserProject.shapes
   */
  export type UserProject$shapesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    where?: ShapeWhereInput
    orderBy?: ShapeOrderByWithRelationInput | ShapeOrderByWithRelationInput[]
    cursor?: ShapeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShapeScalarFieldEnum | ShapeScalarFieldEnum[]
  }

  /**
   * UserProject.transfers
   */
  export type UserProject$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * UserProject.frequencies
   */
  export type UserProject$frequenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    where?: FrequencyWhereInput
    orderBy?: FrequencyOrderByWithRelationInput | FrequencyOrderByWithRelationInput[]
    cursor?: FrequencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FrequencyScalarFieldEnum | FrequencyScalarFieldEnum[]
  }

  /**
   * UserProject.levels
   */
  export type UserProject$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * UserProject.pathways
   */
  export type UserProject$pathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * UserProject.feedInfo
   */
  export type UserProject$feedInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    where?: FeedInfoWhereInput
    orderBy?: FeedInfoOrderByWithRelationInput | FeedInfoOrderByWithRelationInput[]
    cursor?: FeedInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedInfoScalarFieldEnum | FeedInfoScalarFieldEnum[]
  }

  /**
   * UserProject without action
   */
  export type UserProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProject
     */
    select?: UserProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProject
     */
    omit?: UserProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectShare
   */

  export type AggregateProjectShare = {
    _count: ProjectShareCountAggregateOutputType | null
    _min: ProjectShareMinAggregateOutputType | null
    _max: ProjectShareMaxAggregateOutputType | null
  }

  export type ProjectShareMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    user_id: string | null
    role: $Enums.ProjectRole | null
    shared_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProjectShareMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    user_id: string | null
    role: $Enums.ProjectRole | null
    shared_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProjectShareCountAggregateOutputType = {
    id: number
    project_id: number
    user_id: number
    role: number
    shared_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProjectShareMinAggregateInputType = {
    id?: true
    project_id?: true
    user_id?: true
    role?: true
    shared_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ProjectShareMaxAggregateInputType = {
    id?: true
    project_id?: true
    user_id?: true
    role?: true
    shared_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ProjectShareCountAggregateInputType = {
    id?: true
    project_id?: true
    user_id?: true
    role?: true
    shared_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProjectShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectShare to aggregate.
     */
    where?: ProjectShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectShares to fetch.
     */
    orderBy?: ProjectShareOrderByWithRelationInput | ProjectShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectShares
    **/
    _count?: true | ProjectShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectShareMaxAggregateInputType
  }

  export type GetProjectShareAggregateType<T extends ProjectShareAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectShare[P]>
      : GetScalarType<T[P], AggregateProjectShare[P]>
  }




  export type ProjectShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectShareWhereInput
    orderBy?: ProjectShareOrderByWithAggregationInput | ProjectShareOrderByWithAggregationInput[]
    by: ProjectShareScalarFieldEnum[] | ProjectShareScalarFieldEnum
    having?: ProjectShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectShareCountAggregateInputType | true
    _min?: ProjectShareMinAggregateInputType
    _max?: ProjectShareMaxAggregateInputType
  }

  export type ProjectShareGroupByOutputType = {
    id: string
    project_id: string
    user_id: string
    role: $Enums.ProjectRole
    shared_by: string
    created_at: Date
    updated_at: Date
    _count: ProjectShareCountAggregateOutputType | null
    _min: ProjectShareMinAggregateOutputType | null
    _max: ProjectShareMaxAggregateOutputType | null
  }

  type GetProjectShareGroupByPayload<T extends ProjectShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectShareGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectShareGroupByOutputType[P]>
        }
      >
    >


  export type ProjectShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    user_id?: boolean
    role?: boolean
    shared_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectShare"]>

  export type ProjectShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    user_id?: boolean
    role?: boolean
    shared_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectShare"]>

  export type ProjectShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    user_id?: boolean
    role?: boolean
    shared_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectShare"]>

  export type ProjectShareSelectScalar = {
    id?: boolean
    project_id?: boolean
    user_id?: boolean
    role?: boolean
    shared_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProjectShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "user_id" | "role" | "shared_by" | "created_at" | "updated_at", ExtArgs["result"]["projectShare"]>
  export type ProjectShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectShare"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string
      user_id: string
      role: $Enums.ProjectRole
      shared_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["projectShare"]>
    composites: {}
  }

  type ProjectShareGetPayload<S extends boolean | null | undefined | ProjectShareDefaultArgs> = $Result.GetResult<Prisma.$ProjectSharePayload, S>

  type ProjectShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectShareCountAggregateInputType | true
    }

  export interface ProjectShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectShare'], meta: { name: 'ProjectShare' } }
    /**
     * Find zero or one ProjectShare that matches the filter.
     * @param {ProjectShareFindUniqueArgs} args - Arguments to find a ProjectShare
     * @example
     * // Get one ProjectShare
     * const projectShare = await prisma.projectShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectShareFindUniqueArgs>(args: SelectSubset<T, ProjectShareFindUniqueArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectShareFindUniqueOrThrowArgs} args - Arguments to find a ProjectShare
     * @example
     * // Get one ProjectShare
     * const projectShare = await prisma.projectShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectShareFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareFindFirstArgs} args - Arguments to find a ProjectShare
     * @example
     * // Get one ProjectShare
     * const projectShare = await prisma.projectShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectShareFindFirstArgs>(args?: SelectSubset<T, ProjectShareFindFirstArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareFindFirstOrThrowArgs} args - Arguments to find a ProjectShare
     * @example
     * // Get one ProjectShare
     * const projectShare = await prisma.projectShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectShareFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectShares
     * const projectShares = await prisma.projectShare.findMany()
     * 
     * // Get first 10 ProjectShares
     * const projectShares = await prisma.projectShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectShareWithIdOnly = await prisma.projectShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectShareFindManyArgs>(args?: SelectSubset<T, ProjectShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectShare.
     * @param {ProjectShareCreateArgs} args - Arguments to create a ProjectShare.
     * @example
     * // Create one ProjectShare
     * const ProjectShare = await prisma.projectShare.create({
     *   data: {
     *     // ... data to create a ProjectShare
     *   }
     * })
     * 
     */
    create<T extends ProjectShareCreateArgs>(args: SelectSubset<T, ProjectShareCreateArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectShares.
     * @param {ProjectShareCreateManyArgs} args - Arguments to create many ProjectShares.
     * @example
     * // Create many ProjectShares
     * const projectShare = await prisma.projectShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectShareCreateManyArgs>(args?: SelectSubset<T, ProjectShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectShares and returns the data saved in the database.
     * @param {ProjectShareCreateManyAndReturnArgs} args - Arguments to create many ProjectShares.
     * @example
     * // Create many ProjectShares
     * const projectShare = await prisma.projectShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectShares and only return the `id`
     * const projectShareWithIdOnly = await prisma.projectShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectShareCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectShare.
     * @param {ProjectShareDeleteArgs} args - Arguments to delete one ProjectShare.
     * @example
     * // Delete one ProjectShare
     * const ProjectShare = await prisma.projectShare.delete({
     *   where: {
     *     // ... filter to delete one ProjectShare
     *   }
     * })
     * 
     */
    delete<T extends ProjectShareDeleteArgs>(args: SelectSubset<T, ProjectShareDeleteArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectShare.
     * @param {ProjectShareUpdateArgs} args - Arguments to update one ProjectShare.
     * @example
     * // Update one ProjectShare
     * const projectShare = await prisma.projectShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectShareUpdateArgs>(args: SelectSubset<T, ProjectShareUpdateArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectShares.
     * @param {ProjectShareDeleteManyArgs} args - Arguments to filter ProjectShares to delete.
     * @example
     * // Delete a few ProjectShares
     * const { count } = await prisma.projectShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectShareDeleteManyArgs>(args?: SelectSubset<T, ProjectShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectShares
     * const projectShare = await prisma.projectShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectShareUpdateManyArgs>(args: SelectSubset<T, ProjectShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectShares and returns the data updated in the database.
     * @param {ProjectShareUpdateManyAndReturnArgs} args - Arguments to update many ProjectShares.
     * @example
     * // Update many ProjectShares
     * const projectShare = await prisma.projectShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectShares and only return the `id`
     * const projectShareWithIdOnly = await prisma.projectShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectShareUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectShare.
     * @param {ProjectShareUpsertArgs} args - Arguments to update or create a ProjectShare.
     * @example
     * // Update or create a ProjectShare
     * const projectShare = await prisma.projectShare.upsert({
     *   create: {
     *     // ... data to create a ProjectShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectShare we want to update
     *   }
     * })
     */
    upsert<T extends ProjectShareUpsertArgs>(args: SelectSubset<T, ProjectShareUpsertArgs<ExtArgs>>): Prisma__ProjectShareClient<$Result.GetResult<Prisma.$ProjectSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareCountArgs} args - Arguments to filter ProjectShares to count.
     * @example
     * // Count the number of ProjectShares
     * const count = await prisma.projectShare.count({
     *   where: {
     *     // ... the filter for the ProjectShares we want to count
     *   }
     * })
    **/
    count<T extends ProjectShareCountArgs>(
      args?: Subset<T, ProjectShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectShareAggregateArgs>(args: Subset<T, ProjectShareAggregateArgs>): Prisma.PrismaPromise<GetProjectShareAggregateType<T>>

    /**
     * Group by ProjectShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectShareGroupByArgs['orderBy'] }
        : { orderBy?: ProjectShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectShare model
   */
  readonly fields: ProjectShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectShare model
   */
  interface ProjectShareFieldRefs {
    readonly id: FieldRef<"ProjectShare", 'String'>
    readonly project_id: FieldRef<"ProjectShare", 'String'>
    readonly user_id: FieldRef<"ProjectShare", 'String'>
    readonly role: FieldRef<"ProjectShare", 'ProjectRole'>
    readonly shared_by: FieldRef<"ProjectShare", 'String'>
    readonly created_at: FieldRef<"ProjectShare", 'DateTime'>
    readonly updated_at: FieldRef<"ProjectShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectShare findUnique
   */
  export type ProjectShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * Filter, which ProjectShare to fetch.
     */
    where: ProjectShareWhereUniqueInput
  }

  /**
   * ProjectShare findUniqueOrThrow
   */
  export type ProjectShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * Filter, which ProjectShare to fetch.
     */
    where: ProjectShareWhereUniqueInput
  }

  /**
   * ProjectShare findFirst
   */
  export type ProjectShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * Filter, which ProjectShare to fetch.
     */
    where?: ProjectShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectShares to fetch.
     */
    orderBy?: ProjectShareOrderByWithRelationInput | ProjectShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectShares.
     */
    cursor?: ProjectShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectShares.
     */
    distinct?: ProjectShareScalarFieldEnum | ProjectShareScalarFieldEnum[]
  }

  /**
   * ProjectShare findFirstOrThrow
   */
  export type ProjectShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * Filter, which ProjectShare to fetch.
     */
    where?: ProjectShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectShares to fetch.
     */
    orderBy?: ProjectShareOrderByWithRelationInput | ProjectShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectShares.
     */
    cursor?: ProjectShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectShares.
     */
    distinct?: ProjectShareScalarFieldEnum | ProjectShareScalarFieldEnum[]
  }

  /**
   * ProjectShare findMany
   */
  export type ProjectShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * Filter, which ProjectShares to fetch.
     */
    where?: ProjectShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectShares to fetch.
     */
    orderBy?: ProjectShareOrderByWithRelationInput | ProjectShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectShares.
     */
    cursor?: ProjectShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectShares.
     */
    skip?: number
    distinct?: ProjectShareScalarFieldEnum | ProjectShareScalarFieldEnum[]
  }

  /**
   * ProjectShare create
   */
  export type ProjectShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectShare.
     */
    data: XOR<ProjectShareCreateInput, ProjectShareUncheckedCreateInput>
  }

  /**
   * ProjectShare createMany
   */
  export type ProjectShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectShares.
     */
    data: ProjectShareCreateManyInput | ProjectShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectShare createManyAndReturn
   */
  export type ProjectShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectShares.
     */
    data: ProjectShareCreateManyInput | ProjectShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectShare update
   */
  export type ProjectShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectShare.
     */
    data: XOR<ProjectShareUpdateInput, ProjectShareUncheckedUpdateInput>
    /**
     * Choose, which ProjectShare to update.
     */
    where: ProjectShareWhereUniqueInput
  }

  /**
   * ProjectShare updateMany
   */
  export type ProjectShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectShares.
     */
    data: XOR<ProjectShareUpdateManyMutationInput, ProjectShareUncheckedUpdateManyInput>
    /**
     * Filter which ProjectShares to update
     */
    where?: ProjectShareWhereInput
    /**
     * Limit how many ProjectShares to update.
     */
    limit?: number
  }

  /**
   * ProjectShare updateManyAndReturn
   */
  export type ProjectShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * The data used to update ProjectShares.
     */
    data: XOR<ProjectShareUpdateManyMutationInput, ProjectShareUncheckedUpdateManyInput>
    /**
     * Filter which ProjectShares to update
     */
    where?: ProjectShareWhereInput
    /**
     * Limit how many ProjectShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectShare upsert
   */
  export type ProjectShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectShare to update in case it exists.
     */
    where: ProjectShareWhereUniqueInput
    /**
     * In case the ProjectShare found by the `where` argument doesn't exist, create a new ProjectShare with this data.
     */
    create: XOR<ProjectShareCreateInput, ProjectShareUncheckedCreateInput>
    /**
     * In case the ProjectShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectShareUpdateInput, ProjectShareUncheckedUpdateInput>
  }

  /**
   * ProjectShare delete
   */
  export type ProjectShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
    /**
     * Filter which ProjectShare to delete.
     */
    where: ProjectShareWhereUniqueInput
  }

  /**
   * ProjectShare deleteMany
   */
  export type ProjectShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectShares to delete
     */
    where?: ProjectShareWhereInput
    /**
     * Limit how many ProjectShares to delete.
     */
    limit?: number
  }

  /**
   * ProjectShare without action
   */
  export type ProjectShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectShare
     */
    select?: ProjectShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectShare
     */
    omit?: ProjectShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectShareInclude<ExtArgs> | null
  }


  /**
   * Model ProjectInvite
   */

  export type AggregateProjectInvite = {
    _count: ProjectInviteCountAggregateOutputType | null
    _min: ProjectInviteMinAggregateOutputType | null
    _max: ProjectInviteMaxAggregateOutputType | null
  }

  export type ProjectInviteMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    email: string | null
    user_id: string | null
    role: $Enums.ProjectRole | null
    token: string | null
    invited_by: string | null
    expires_at: Date | null
    accepted_at: Date | null
    created_at: Date | null
  }

  export type ProjectInviteMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    email: string | null
    user_id: string | null
    role: $Enums.ProjectRole | null
    token: string | null
    invited_by: string | null
    expires_at: Date | null
    accepted_at: Date | null
    created_at: Date | null
  }

  export type ProjectInviteCountAggregateOutputType = {
    id: number
    project_id: number
    email: number
    user_id: number
    role: number
    token: number
    invited_by: number
    expires_at: number
    accepted_at: number
    created_at: number
    _all: number
  }


  export type ProjectInviteMinAggregateInputType = {
    id?: true
    project_id?: true
    email?: true
    user_id?: true
    role?: true
    token?: true
    invited_by?: true
    expires_at?: true
    accepted_at?: true
    created_at?: true
  }

  export type ProjectInviteMaxAggregateInputType = {
    id?: true
    project_id?: true
    email?: true
    user_id?: true
    role?: true
    token?: true
    invited_by?: true
    expires_at?: true
    accepted_at?: true
    created_at?: true
  }

  export type ProjectInviteCountAggregateInputType = {
    id?: true
    project_id?: true
    email?: true
    user_id?: true
    role?: true
    token?: true
    invited_by?: true
    expires_at?: true
    accepted_at?: true
    created_at?: true
    _all?: true
  }

  export type ProjectInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectInvite to aggregate.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: ProjectInviteOrderByWithRelationInput | ProjectInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectInvites
    **/
    _count?: true | ProjectInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectInviteMaxAggregateInputType
  }

  export type GetProjectInviteAggregateType<T extends ProjectInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectInvite[P]>
      : GetScalarType<T[P], AggregateProjectInvite[P]>
  }




  export type ProjectInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInviteWhereInput
    orderBy?: ProjectInviteOrderByWithAggregationInput | ProjectInviteOrderByWithAggregationInput[]
    by: ProjectInviteScalarFieldEnum[] | ProjectInviteScalarFieldEnum
    having?: ProjectInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectInviteCountAggregateInputType | true
    _min?: ProjectInviteMinAggregateInputType
    _max?: ProjectInviteMaxAggregateInputType
  }

  export type ProjectInviteGroupByOutputType = {
    id: string
    project_id: string
    email: string
    user_id: string | null
    role: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date
    accepted_at: Date | null
    created_at: Date
    _count: ProjectInviteCountAggregateOutputType | null
    _min: ProjectInviteMinAggregateOutputType | null
    _max: ProjectInviteMaxAggregateOutputType | null
  }

  type GetProjectInviteGroupByPayload<T extends ProjectInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectInviteGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectInviteGroupByOutputType[P]>
        }
      >
    >


  export type ProjectInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    email?: boolean
    user_id?: boolean
    role?: boolean
    token?: boolean
    invited_by?: boolean
    expires_at?: boolean
    accepted_at?: boolean
    created_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | ProjectInvite$userArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvite"]>

  export type ProjectInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    email?: boolean
    user_id?: boolean
    role?: boolean
    token?: boolean
    invited_by?: boolean
    expires_at?: boolean
    accepted_at?: boolean
    created_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | ProjectInvite$userArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvite"]>

  export type ProjectInviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    email?: boolean
    user_id?: boolean
    role?: boolean
    token?: boolean
    invited_by?: boolean
    expires_at?: boolean
    accepted_at?: boolean
    created_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | ProjectInvite$userArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvite"]>

  export type ProjectInviteSelectScalar = {
    id?: boolean
    project_id?: boolean
    email?: boolean
    user_id?: boolean
    role?: boolean
    token?: boolean
    invited_by?: boolean
    expires_at?: boolean
    accepted_at?: boolean
    created_at?: boolean
  }

  export type ProjectInviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "email" | "user_id" | "role" | "token" | "invited_by" | "expires_at" | "accepted_at" | "created_at", ExtArgs["result"]["projectInvite"]>
  export type ProjectInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | ProjectInvite$userArgs<ExtArgs>
  }
  export type ProjectInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | ProjectInvite$userArgs<ExtArgs>
  }
  export type ProjectInviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    user?: boolean | ProjectInvite$userArgs<ExtArgs>
  }

  export type $ProjectInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectInvite"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string
      email: string
      user_id: string | null
      role: $Enums.ProjectRole
      token: string
      invited_by: string
      expires_at: Date
      accepted_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["projectInvite"]>
    composites: {}
  }

  type ProjectInviteGetPayload<S extends boolean | null | undefined | ProjectInviteDefaultArgs> = $Result.GetResult<Prisma.$ProjectInvitePayload, S>

  type ProjectInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectInviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectInviteCountAggregateInputType | true
    }

  export interface ProjectInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectInvite'], meta: { name: 'ProjectInvite' } }
    /**
     * Find zero or one ProjectInvite that matches the filter.
     * @param {ProjectInviteFindUniqueArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectInviteFindUniqueArgs>(args: SelectSubset<T, ProjectInviteFindUniqueArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectInviteFindUniqueOrThrowArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteFindFirstArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectInviteFindFirstArgs>(args?: SelectSubset<T, ProjectInviteFindFirstArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteFindFirstOrThrowArgs} args - Arguments to find a ProjectInvite
     * @example
     * // Get one ProjectInvite
     * const projectInvite = await prisma.projectInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectInvites
     * const projectInvites = await prisma.projectInvite.findMany()
     * 
     * // Get first 10 ProjectInvites
     * const projectInvites = await prisma.projectInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectInviteWithIdOnly = await prisma.projectInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectInviteFindManyArgs>(args?: SelectSubset<T, ProjectInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectInvite.
     * @param {ProjectInviteCreateArgs} args - Arguments to create a ProjectInvite.
     * @example
     * // Create one ProjectInvite
     * const ProjectInvite = await prisma.projectInvite.create({
     *   data: {
     *     // ... data to create a ProjectInvite
     *   }
     * })
     * 
     */
    create<T extends ProjectInviteCreateArgs>(args: SelectSubset<T, ProjectInviteCreateArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectInvites.
     * @param {ProjectInviteCreateManyArgs} args - Arguments to create many ProjectInvites.
     * @example
     * // Create many ProjectInvites
     * const projectInvite = await prisma.projectInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectInviteCreateManyArgs>(args?: SelectSubset<T, ProjectInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectInvites and returns the data saved in the database.
     * @param {ProjectInviteCreateManyAndReturnArgs} args - Arguments to create many ProjectInvites.
     * @example
     * // Create many ProjectInvites
     * const projectInvite = await prisma.projectInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectInvites and only return the `id`
     * const projectInviteWithIdOnly = await prisma.projectInvite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectInvite.
     * @param {ProjectInviteDeleteArgs} args - Arguments to delete one ProjectInvite.
     * @example
     * // Delete one ProjectInvite
     * const ProjectInvite = await prisma.projectInvite.delete({
     *   where: {
     *     // ... filter to delete one ProjectInvite
     *   }
     * })
     * 
     */
    delete<T extends ProjectInviteDeleteArgs>(args: SelectSubset<T, ProjectInviteDeleteArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectInvite.
     * @param {ProjectInviteUpdateArgs} args - Arguments to update one ProjectInvite.
     * @example
     * // Update one ProjectInvite
     * const projectInvite = await prisma.projectInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectInviteUpdateArgs>(args: SelectSubset<T, ProjectInviteUpdateArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectInvites.
     * @param {ProjectInviteDeleteManyArgs} args - Arguments to filter ProjectInvites to delete.
     * @example
     * // Delete a few ProjectInvites
     * const { count } = await prisma.projectInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectInviteDeleteManyArgs>(args?: SelectSubset<T, ProjectInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectInvites
     * const projectInvite = await prisma.projectInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectInviteUpdateManyArgs>(args: SelectSubset<T, ProjectInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvites and returns the data updated in the database.
     * @param {ProjectInviteUpdateManyAndReturnArgs} args - Arguments to update many ProjectInvites.
     * @example
     * // Update many ProjectInvites
     * const projectInvite = await prisma.projectInvite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectInvites and only return the `id`
     * const projectInviteWithIdOnly = await prisma.projectInvite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectInviteUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectInviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectInvite.
     * @param {ProjectInviteUpsertArgs} args - Arguments to update or create a ProjectInvite.
     * @example
     * // Update or create a ProjectInvite
     * const projectInvite = await prisma.projectInvite.upsert({
     *   create: {
     *     // ... data to create a ProjectInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectInvite we want to update
     *   }
     * })
     */
    upsert<T extends ProjectInviteUpsertArgs>(args: SelectSubset<T, ProjectInviteUpsertArgs<ExtArgs>>): Prisma__ProjectInviteClient<$Result.GetResult<Prisma.$ProjectInvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteCountArgs} args - Arguments to filter ProjectInvites to count.
     * @example
     * // Count the number of ProjectInvites
     * const count = await prisma.projectInvite.count({
     *   where: {
     *     // ... the filter for the ProjectInvites we want to count
     *   }
     * })
    **/
    count<T extends ProjectInviteCountArgs>(
      args?: Subset<T, ProjectInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectInviteAggregateArgs>(args: Subset<T, ProjectInviteAggregateArgs>): Prisma.PrismaPromise<GetProjectInviteAggregateType<T>>

    /**
     * Group by ProjectInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectInviteGroupByArgs['orderBy'] }
        : { orderBy?: ProjectInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectInvite model
   */
  readonly fields: ProjectInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ProjectInvite$userArgs<ExtArgs> = {}>(args?: Subset<T, ProjectInvite$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectInvite model
   */
  interface ProjectInviteFieldRefs {
    readonly id: FieldRef<"ProjectInvite", 'String'>
    readonly project_id: FieldRef<"ProjectInvite", 'String'>
    readonly email: FieldRef<"ProjectInvite", 'String'>
    readonly user_id: FieldRef<"ProjectInvite", 'String'>
    readonly role: FieldRef<"ProjectInvite", 'ProjectRole'>
    readonly token: FieldRef<"ProjectInvite", 'String'>
    readonly invited_by: FieldRef<"ProjectInvite", 'String'>
    readonly expires_at: FieldRef<"ProjectInvite", 'DateTime'>
    readonly accepted_at: FieldRef<"ProjectInvite", 'DateTime'>
    readonly created_at: FieldRef<"ProjectInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectInvite findUnique
   */
  export type ProjectInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where: ProjectInviteWhereUniqueInput
  }

  /**
   * ProjectInvite findUniqueOrThrow
   */
  export type ProjectInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where: ProjectInviteWhereUniqueInput
  }

  /**
   * ProjectInvite findFirst
   */
  export type ProjectInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: ProjectInviteOrderByWithRelationInput | ProjectInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvites.
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvites.
     */
    distinct?: ProjectInviteScalarFieldEnum | ProjectInviteScalarFieldEnum[]
  }

  /**
   * ProjectInvite findFirstOrThrow
   */
  export type ProjectInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvite to fetch.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: ProjectInviteOrderByWithRelationInput | ProjectInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvites.
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvites.
     */
    distinct?: ProjectInviteScalarFieldEnum | ProjectInviteScalarFieldEnum[]
  }

  /**
   * ProjectInvite findMany
   */
  export type ProjectInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvites to fetch.
     */
    where?: ProjectInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvites to fetch.
     */
    orderBy?: ProjectInviteOrderByWithRelationInput | ProjectInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectInvites.
     */
    cursor?: ProjectInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvites.
     */
    skip?: number
    distinct?: ProjectInviteScalarFieldEnum | ProjectInviteScalarFieldEnum[]
  }

  /**
   * ProjectInvite create
   */
  export type ProjectInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectInvite.
     */
    data: XOR<ProjectInviteCreateInput, ProjectInviteUncheckedCreateInput>
  }

  /**
   * ProjectInvite createMany
   */
  export type ProjectInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectInvites.
     */
    data: ProjectInviteCreateManyInput | ProjectInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectInvite createManyAndReturn
   */
  export type ProjectInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectInvites.
     */
    data: ProjectInviteCreateManyInput | ProjectInviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectInvite update
   */
  export type ProjectInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectInvite.
     */
    data: XOR<ProjectInviteUpdateInput, ProjectInviteUncheckedUpdateInput>
    /**
     * Choose, which ProjectInvite to update.
     */
    where: ProjectInviteWhereUniqueInput
  }

  /**
   * ProjectInvite updateMany
   */
  export type ProjectInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectInvites.
     */
    data: XOR<ProjectInviteUpdateManyMutationInput, ProjectInviteUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvites to update
     */
    where?: ProjectInviteWhereInput
    /**
     * Limit how many ProjectInvites to update.
     */
    limit?: number
  }

  /**
   * ProjectInvite updateManyAndReturn
   */
  export type ProjectInviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * The data used to update ProjectInvites.
     */
    data: XOR<ProjectInviteUpdateManyMutationInput, ProjectInviteUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvites to update
     */
    where?: ProjectInviteWhereInput
    /**
     * Limit how many ProjectInvites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectInvite upsert
   */
  export type ProjectInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectInvite to update in case it exists.
     */
    where: ProjectInviteWhereUniqueInput
    /**
     * In case the ProjectInvite found by the `where` argument doesn't exist, create a new ProjectInvite with this data.
     */
    create: XOR<ProjectInviteCreateInput, ProjectInviteUncheckedCreateInput>
    /**
     * In case the ProjectInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectInviteUpdateInput, ProjectInviteUncheckedUpdateInput>
  }

  /**
   * ProjectInvite delete
   */
  export type ProjectInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
    /**
     * Filter which ProjectInvite to delete.
     */
    where: ProjectInviteWhereUniqueInput
  }

  /**
   * ProjectInvite deleteMany
   */
  export type ProjectInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectInvites to delete
     */
    where?: ProjectInviteWhereInput
    /**
     * Limit how many ProjectInvites to delete.
     */
    limit?: number
  }

  /**
   * ProjectInvite.user
   */
  export type ProjectInvite$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProjectInvite without action
   */
  export type ProjectInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvite
     */
    select?: ProjectInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvite
     */
    omit?: ProjectInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInviteInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    token: string | null
    expires_at: Date | null
    used_at: Date | null
    created_at: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    token: string | null
    expires_at: Date | null
    used_at: Date | null
    created_at: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    expires_at: number
    used_at: number
    created_at: number
    _all: number
  }


  export type PasswordResetMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    used_at?: true
    created_at?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    used_at?: true
    created_at?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    used_at?: true
    created_at?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: string
    user_id: string
    token: string
    expires_at: Date
    used_at: Date | null
    created_at: Date
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    used_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    used_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    used_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    used_at?: boolean
    created_at?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token" | "expires_at" | "used_at" | "created_at", ExtArgs["result"]["passwordReset"]>
  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      token: string
      expires_at: Date
      used_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {PasswordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'String'>
    readonly user_id: FieldRef<"PasswordReset", 'String'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly expires_at: FieldRef<"PasswordReset", 'DateTime'>
    readonly used_at: FieldRef<"PasswordReset", 'DateTime'>
    readonly created_at: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset updateManyAndReturn
   */
  export type PasswordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    session_token: string | null
    expires_at: Date | null
    user_agent: string | null
    ip_address: string | null
    created_at: Date | null
    last_active: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    session_token: string | null
    expires_at: Date | null
    user_agent: string | null
    ip_address: string | null
    created_at: Date | null
    last_active: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    user_id: number
    session_token: number
    expires_at: number
    user_agent: number
    ip_address: number
    created_at: number
    last_active: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    expires_at?: true
    user_agent?: true
    ip_address?: true
    created_at?: true
    last_active?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    expires_at?: true
    user_agent?: true
    ip_address?: true
    created_at?: true
    last_active?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    user_id?: true
    session_token?: true
    expires_at?: true
    user_agent?: true
    ip_address?: true
    created_at?: true
    last_active?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    user_id: string
    session_token: string
    expires_at: Date
    user_agent: string | null
    ip_address: string | null
    created_at: Date
    last_active: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    expires_at?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    last_active?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    expires_at?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    last_active?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    expires_at?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    last_active?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    session_token?: boolean
    expires_at?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    last_active?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "session_token" | "expires_at" | "user_agent" | "ip_address" | "created_at" | "last_active", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      session_token: string
      expires_at: Date
      user_agent: string | null
      ip_address: string | null
      created_at: Date
      last_active: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly user_id: FieldRef<"UserSession", 'String'>
    readonly session_token: FieldRef<"UserSession", 'String'>
    readonly expires_at: FieldRef<"UserSession", 'DateTime'>
    readonly user_agent: FieldRef<"UserSession", 'String'>
    readonly ip_address: FieldRef<"UserSession", 'String'>
    readonly created_at: FieldRef<"UserSession", 'DateTime'>
    readonly last_active: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    agency_id: string | null
    agency_name: string | null
    agency_url: string | null
    agency_timezone: string | null
    agency_lang: string | null
    agency_phone: string | null
    agency_fare_url: string | null
    agency_email: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    agency_id: string | null
    agency_name: string | null
    agency_url: string | null
    agency_timezone: string | null
    agency_lang: string | null
    agency_phone: string | null
    agency_fare_url: string | null
    agency_email: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    agency_id: number
    agency_name: number
    agency_url: number
    agency_timezone: number
    agency_lang: number
    agency_phone: number
    agency_fare_url: number
    agency_email: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AgencyMinAggregateInputType = {
    id?: true
    agency_id?: true
    agency_name?: true
    agency_url?: true
    agency_timezone?: true
    agency_lang?: true
    agency_phone?: true
    agency_fare_url?: true
    agency_email?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    agency_id?: true
    agency_name?: true
    agency_url?: true
    agency_timezone?: true
    agency_lang?: true
    agency_phone?: true
    agency_fare_url?: true
    agency_email?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    agency_id?: true
    agency_name?: true
    agency_url?: true
    agency_timezone?: true
    agency_lang?: true
    agency_phone?: true
    agency_fare_url?: true
    agency_email?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang: string | null
    agency_phone: string | null
    agency_fare_url: string | null
    agency_email: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: AgencyCountAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agency_id?: boolean
    agency_name?: boolean
    agency_url?: boolean
    agency_timezone?: boolean
    agency_lang?: boolean
    agency_phone?: boolean
    agency_fare_url?: boolean
    agency_email?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    routes?: boolean | Agency$routesArgs<ExtArgs>
    fareAttributes?: boolean | Agency$fareAttributesArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agency_id?: boolean
    agency_name?: boolean
    agency_url?: boolean
    agency_timezone?: boolean
    agency_lang?: boolean
    agency_phone?: boolean
    agency_fare_url?: boolean
    agency_email?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agency_id?: boolean
    agency_name?: boolean
    agency_url?: boolean
    agency_timezone?: boolean
    agency_lang?: boolean
    agency_phone?: boolean
    agency_fare_url?: boolean
    agency_email?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    agency_id?: boolean
    agency_name?: boolean
    agency_url?: boolean
    agency_timezone?: boolean
    agency_lang?: boolean
    agency_phone?: boolean
    agency_fare_url?: boolean
    agency_email?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agency_id" | "agency_name" | "agency_url" | "agency_timezone" | "agency_lang" | "agency_phone" | "agency_fare_url" | "agency_email" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    routes?: boolean | Agency$routesArgs<ExtArgs>
    fareAttributes?: boolean | Agency$fareAttributesArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      routes: Prisma.$RoutePayload<ExtArgs>[]
      fareAttributes: Prisma.$FareAttributePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agency_id: string
      agency_name: string
      agency_url: string
      agency_timezone: string
      agency_lang: string | null
      agency_phone: string | null
      agency_fare_url: string | null
      agency_email: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    routes<T extends Agency$routesArgs<ExtArgs> = {}>(args?: Subset<T, Agency$routesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fareAttributes<T extends Agency$fareAttributesArgs<ExtArgs> = {}>(args?: Subset<T, Agency$fareAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly agency_id: FieldRef<"Agency", 'String'>
    readonly agency_name: FieldRef<"Agency", 'String'>
    readonly agency_url: FieldRef<"Agency", 'String'>
    readonly agency_timezone: FieldRef<"Agency", 'String'>
    readonly agency_lang: FieldRef<"Agency", 'String'>
    readonly agency_phone: FieldRef<"Agency", 'String'>
    readonly agency_fare_url: FieldRef<"Agency", 'String'>
    readonly agency_email: FieldRef<"Agency", 'String'>
    readonly project_id: FieldRef<"Agency", 'String'>
    readonly created_by: FieldRef<"Agency", 'String'>
    readonly created_at: FieldRef<"Agency", 'DateTime'>
    readonly updated_at: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.routes
   */
  export type Agency$routesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    cursor?: RouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Agency.fareAttributes
   */
  export type Agency$fareAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    where?: FareAttributeWhereInput
    orderBy?: FareAttributeOrderByWithRelationInput | FareAttributeOrderByWithRelationInput[]
    cursor?: FareAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareAttributeScalarFieldEnum | FareAttributeScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model Stop
   */

  export type AggregateStop = {
    _count: StopCountAggregateOutputType | null
    _avg: StopAvgAggregateOutputType | null
    _sum: StopSumAggregateOutputType | null
    _min: StopMinAggregateOutputType | null
    _max: StopMaxAggregateOutputType | null
  }

  export type StopAvgAggregateOutputType = {
    stop_lat: number | null
    stop_lon: number | null
    location_type: number | null
    wheelchair_boarding: number | null
  }

  export type StopSumAggregateOutputType = {
    stop_lat: number | null
    stop_lon: number | null
    location_type: number | null
    wheelchair_boarding: number | null
  }

  export type StopMinAggregateOutputType = {
    id: string | null
    stop_id: string | null
    stop_code: string | null
    stop_name: string | null
    stop_desc: string | null
    stop_lat: number | null
    stop_lon: number | null
    zone_id: string | null
    stop_url: string | null
    location_type: number | null
    wheelchair_boarding: number | null
    parent_station: string | null
    platform_code: string | null
    level_id: string | null
    tts_stop_name: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StopMaxAggregateOutputType = {
    id: string | null
    stop_id: string | null
    stop_code: string | null
    stop_name: string | null
    stop_desc: string | null
    stop_lat: number | null
    stop_lon: number | null
    zone_id: string | null
    stop_url: string | null
    location_type: number | null
    wheelchair_boarding: number | null
    parent_station: string | null
    platform_code: string | null
    level_id: string | null
    tts_stop_name: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StopCountAggregateOutputType = {
    id: number
    stop_id: number
    stop_code: number
    stop_name: number
    stop_desc: number
    stop_lat: number
    stop_lon: number
    zone_id: number
    stop_url: number
    location_type: number
    wheelchair_boarding: number
    parent_station: number
    platform_code: number
    level_id: number
    tts_stop_name: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StopAvgAggregateInputType = {
    stop_lat?: true
    stop_lon?: true
    location_type?: true
    wheelchair_boarding?: true
  }

  export type StopSumAggregateInputType = {
    stop_lat?: true
    stop_lon?: true
    location_type?: true
    wheelchair_boarding?: true
  }

  export type StopMinAggregateInputType = {
    id?: true
    stop_id?: true
    stop_code?: true
    stop_name?: true
    stop_desc?: true
    stop_lat?: true
    stop_lon?: true
    zone_id?: true
    stop_url?: true
    location_type?: true
    wheelchair_boarding?: true
    parent_station?: true
    platform_code?: true
    level_id?: true
    tts_stop_name?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type StopMaxAggregateInputType = {
    id?: true
    stop_id?: true
    stop_code?: true
    stop_name?: true
    stop_desc?: true
    stop_lat?: true
    stop_lon?: true
    zone_id?: true
    stop_url?: true
    location_type?: true
    wheelchair_boarding?: true
    parent_station?: true
    platform_code?: true
    level_id?: true
    tts_stop_name?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type StopCountAggregateInputType = {
    id?: true
    stop_id?: true
    stop_code?: true
    stop_name?: true
    stop_desc?: true
    stop_lat?: true
    stop_lon?: true
    zone_id?: true
    stop_url?: true
    location_type?: true
    wheelchair_boarding?: true
    parent_station?: true
    platform_code?: true
    level_id?: true
    tts_stop_name?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stop to aggregate.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stops
    **/
    _count?: true | StopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StopMaxAggregateInputType
  }

  export type GetStopAggregateType<T extends StopAggregateArgs> = {
        [P in keyof T & keyof AggregateStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStop[P]>
      : GetScalarType<T[P], AggregateStop[P]>
  }




  export type StopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
    orderBy?: StopOrderByWithAggregationInput | StopOrderByWithAggregationInput[]
    by: StopScalarFieldEnum[] | StopScalarFieldEnum
    having?: StopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StopCountAggregateInputType | true
    _avg?: StopAvgAggregateInputType
    _sum?: StopSumAggregateInputType
    _min?: StopMinAggregateInputType
    _max?: StopMaxAggregateInputType
  }

  export type StopGroupByOutputType = {
    id: string
    stop_id: string
    stop_code: string | null
    stop_name: string
    stop_desc: string | null
    stop_lat: number
    stop_lon: number
    zone_id: string | null
    stop_url: string | null
    location_type: number | null
    wheelchair_boarding: number | null
    parent_station: string | null
    platform_code: string | null
    level_id: string | null
    tts_stop_name: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: StopCountAggregateOutputType | null
    _avg: StopAvgAggregateOutputType | null
    _sum: StopSumAggregateOutputType | null
    _min: StopMinAggregateOutputType | null
    _max: StopMaxAggregateOutputType | null
  }

  type GetStopGroupByPayload<T extends StopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StopGroupByOutputType[P]>
            : GetScalarType<T[P], StopGroupByOutputType[P]>
        }
      >
    >


  export type StopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stop_id?: boolean
    stop_code?: boolean
    stop_name?: boolean
    stop_desc?: boolean
    stop_lat?: boolean
    stop_lon?: boolean
    zone_id?: boolean
    stop_url?: boolean
    location_type?: boolean
    wheelchair_boarding?: boolean
    parent_station?: boolean
    platform_code?: boolean
    level_id?: boolean
    tts_stop_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    stopTimes?: boolean | Stop$stopTimesArgs<ExtArgs>
    transfers?: boolean | Stop$transfersArgs<ExtArgs>
    transfersTo?: boolean | Stop$transfersToArgs<ExtArgs>
    pathways?: boolean | Stop$pathwaysArgs<ExtArgs>
    pathwaysTo?: boolean | Stop$pathwaysToArgs<ExtArgs>
    parentStop?: boolean | Stop$parentStopArgs<ExtArgs>
    childStops?: boolean | Stop$childStopsArgs<ExtArgs>
    level?: boolean | Stop$levelArgs<ExtArgs>
    _count?: boolean | StopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stop"]>

  export type StopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stop_id?: boolean
    stop_code?: boolean
    stop_name?: boolean
    stop_desc?: boolean
    stop_lat?: boolean
    stop_lon?: boolean
    zone_id?: boolean
    stop_url?: boolean
    location_type?: boolean
    wheelchair_boarding?: boolean
    parent_station?: boolean
    platform_code?: boolean
    level_id?: boolean
    tts_stop_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    parentStop?: boolean | Stop$parentStopArgs<ExtArgs>
    level?: boolean | Stop$levelArgs<ExtArgs>
  }, ExtArgs["result"]["stop"]>

  export type StopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stop_id?: boolean
    stop_code?: boolean
    stop_name?: boolean
    stop_desc?: boolean
    stop_lat?: boolean
    stop_lon?: boolean
    zone_id?: boolean
    stop_url?: boolean
    location_type?: boolean
    wheelchair_boarding?: boolean
    parent_station?: boolean
    platform_code?: boolean
    level_id?: boolean
    tts_stop_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    parentStop?: boolean | Stop$parentStopArgs<ExtArgs>
    level?: boolean | Stop$levelArgs<ExtArgs>
  }, ExtArgs["result"]["stop"]>

  export type StopSelectScalar = {
    id?: boolean
    stop_id?: boolean
    stop_code?: boolean
    stop_name?: boolean
    stop_desc?: boolean
    stop_lat?: boolean
    stop_lon?: boolean
    zone_id?: boolean
    stop_url?: boolean
    location_type?: boolean
    wheelchair_boarding?: boolean
    parent_station?: boolean
    platform_code?: boolean
    level_id?: boolean
    tts_stop_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stop_id" | "stop_code" | "stop_name" | "stop_desc" | "stop_lat" | "stop_lon" | "zone_id" | "stop_url" | "location_type" | "wheelchair_boarding" | "parent_station" | "platform_code" | "level_id" | "tts_stop_name" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["stop"]>
  export type StopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    stopTimes?: boolean | Stop$stopTimesArgs<ExtArgs>
    transfers?: boolean | Stop$transfersArgs<ExtArgs>
    transfersTo?: boolean | Stop$transfersToArgs<ExtArgs>
    pathways?: boolean | Stop$pathwaysArgs<ExtArgs>
    pathwaysTo?: boolean | Stop$pathwaysToArgs<ExtArgs>
    parentStop?: boolean | Stop$parentStopArgs<ExtArgs>
    childStops?: boolean | Stop$childStopsArgs<ExtArgs>
    level?: boolean | Stop$levelArgs<ExtArgs>
    _count?: boolean | StopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    parentStop?: boolean | Stop$parentStopArgs<ExtArgs>
    level?: boolean | Stop$levelArgs<ExtArgs>
  }
  export type StopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    parentStop?: boolean | Stop$parentStopArgs<ExtArgs>
    level?: boolean | Stop$levelArgs<ExtArgs>
  }

  export type $StopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stop"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      stopTimes: Prisma.$StopTimePayload<ExtArgs>[]
      transfers: Prisma.$TransferPayload<ExtArgs>[]
      transfersTo: Prisma.$TransferPayload<ExtArgs>[]
      pathways: Prisma.$PathwayPayload<ExtArgs>[]
      pathwaysTo: Prisma.$PathwayPayload<ExtArgs>[]
      parentStop: Prisma.$StopPayload<ExtArgs> | null
      childStops: Prisma.$StopPayload<ExtArgs>[]
      level: Prisma.$LevelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stop_id: string
      stop_code: string | null
      stop_name: string
      stop_desc: string | null
      stop_lat: number
      stop_lon: number
      zone_id: string | null
      stop_url: string | null
      location_type: number | null
      wheelchair_boarding: number | null
      parent_station: string | null
      platform_code: string | null
      level_id: string | null
      tts_stop_name: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stop"]>
    composites: {}
  }

  type StopGetPayload<S extends boolean | null | undefined | StopDefaultArgs> = $Result.GetResult<Prisma.$StopPayload, S>

  type StopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StopCountAggregateInputType | true
    }

  export interface StopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stop'], meta: { name: 'Stop' } }
    /**
     * Find zero or one Stop that matches the filter.
     * @param {StopFindUniqueArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StopFindUniqueArgs>(args: SelectSubset<T, StopFindUniqueArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StopFindUniqueOrThrowArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StopFindUniqueOrThrowArgs>(args: SelectSubset<T, StopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindFirstArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StopFindFirstArgs>(args?: SelectSubset<T, StopFindFirstArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindFirstOrThrowArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StopFindFirstOrThrowArgs>(args?: SelectSubset<T, StopFindFirstOrThrowArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stops
     * const stops = await prisma.stop.findMany()
     * 
     * // Get first 10 Stops
     * const stops = await prisma.stop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stopWithIdOnly = await prisma.stop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StopFindManyArgs>(args?: SelectSubset<T, StopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stop.
     * @param {StopCreateArgs} args - Arguments to create a Stop.
     * @example
     * // Create one Stop
     * const Stop = await prisma.stop.create({
     *   data: {
     *     // ... data to create a Stop
     *   }
     * })
     * 
     */
    create<T extends StopCreateArgs>(args: SelectSubset<T, StopCreateArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stops.
     * @param {StopCreateManyArgs} args - Arguments to create many Stops.
     * @example
     * // Create many Stops
     * const stop = await prisma.stop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StopCreateManyArgs>(args?: SelectSubset<T, StopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stops and returns the data saved in the database.
     * @param {StopCreateManyAndReturnArgs} args - Arguments to create many Stops.
     * @example
     * // Create many Stops
     * const stop = await prisma.stop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stops and only return the `id`
     * const stopWithIdOnly = await prisma.stop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StopCreateManyAndReturnArgs>(args?: SelectSubset<T, StopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stop.
     * @param {StopDeleteArgs} args - Arguments to delete one Stop.
     * @example
     * // Delete one Stop
     * const Stop = await prisma.stop.delete({
     *   where: {
     *     // ... filter to delete one Stop
     *   }
     * })
     * 
     */
    delete<T extends StopDeleteArgs>(args: SelectSubset<T, StopDeleteArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stop.
     * @param {StopUpdateArgs} args - Arguments to update one Stop.
     * @example
     * // Update one Stop
     * const stop = await prisma.stop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StopUpdateArgs>(args: SelectSubset<T, StopUpdateArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stops.
     * @param {StopDeleteManyArgs} args - Arguments to filter Stops to delete.
     * @example
     * // Delete a few Stops
     * const { count } = await prisma.stop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StopDeleteManyArgs>(args?: SelectSubset<T, StopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stops
     * const stop = await prisma.stop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StopUpdateManyArgs>(args: SelectSubset<T, StopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stops and returns the data updated in the database.
     * @param {StopUpdateManyAndReturnArgs} args - Arguments to update many Stops.
     * @example
     * // Update many Stops
     * const stop = await prisma.stop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stops and only return the `id`
     * const stopWithIdOnly = await prisma.stop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StopUpdateManyAndReturnArgs>(args: SelectSubset<T, StopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stop.
     * @param {StopUpsertArgs} args - Arguments to update or create a Stop.
     * @example
     * // Update or create a Stop
     * const stop = await prisma.stop.upsert({
     *   create: {
     *     // ... data to create a Stop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stop we want to update
     *   }
     * })
     */
    upsert<T extends StopUpsertArgs>(args: SelectSubset<T, StopUpsertArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopCountArgs} args - Arguments to filter Stops to count.
     * @example
     * // Count the number of Stops
     * const count = await prisma.stop.count({
     *   where: {
     *     // ... the filter for the Stops we want to count
     *   }
     * })
    **/
    count<T extends StopCountArgs>(
      args?: Subset<T, StopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StopAggregateArgs>(args: Subset<T, StopAggregateArgs>): Prisma.PrismaPromise<GetStopAggregateType<T>>

    /**
     * Group by Stop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StopGroupByArgs['orderBy'] }
        : { orderBy?: StopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stop model
   */
  readonly fields: StopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stopTimes<T extends Stop$stopTimesArgs<ExtArgs> = {}>(args?: Subset<T, Stop$stopTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfers<T extends Stop$transfersArgs<ExtArgs> = {}>(args?: Subset<T, Stop$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends Stop$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, Stop$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pathways<T extends Stop$pathwaysArgs<ExtArgs> = {}>(args?: Subset<T, Stop$pathwaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pathwaysTo<T extends Stop$pathwaysToArgs<ExtArgs> = {}>(args?: Subset<T, Stop$pathwaysToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentStop<T extends Stop$parentStopArgs<ExtArgs> = {}>(args?: Subset<T, Stop$parentStopArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childStops<T extends Stop$childStopsArgs<ExtArgs> = {}>(args?: Subset<T, Stop$childStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    level<T extends Stop$levelArgs<ExtArgs> = {}>(args?: Subset<T, Stop$levelArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stop model
   */
  interface StopFieldRefs {
    readonly id: FieldRef<"Stop", 'String'>
    readonly stop_id: FieldRef<"Stop", 'String'>
    readonly stop_code: FieldRef<"Stop", 'String'>
    readonly stop_name: FieldRef<"Stop", 'String'>
    readonly stop_desc: FieldRef<"Stop", 'String'>
    readonly stop_lat: FieldRef<"Stop", 'Float'>
    readonly stop_lon: FieldRef<"Stop", 'Float'>
    readonly zone_id: FieldRef<"Stop", 'String'>
    readonly stop_url: FieldRef<"Stop", 'String'>
    readonly location_type: FieldRef<"Stop", 'Int'>
    readonly wheelchair_boarding: FieldRef<"Stop", 'Int'>
    readonly parent_station: FieldRef<"Stop", 'String'>
    readonly platform_code: FieldRef<"Stop", 'String'>
    readonly level_id: FieldRef<"Stop", 'String'>
    readonly tts_stop_name: FieldRef<"Stop", 'String'>
    readonly project_id: FieldRef<"Stop", 'String'>
    readonly created_by: FieldRef<"Stop", 'String'>
    readonly created_at: FieldRef<"Stop", 'DateTime'>
    readonly updated_at: FieldRef<"Stop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stop findUnique
   */
  export type StopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop findUniqueOrThrow
   */
  export type StopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop findFirst
   */
  export type StopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stops.
     */
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop findFirstOrThrow
   */
  export type StopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stops.
     */
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop findMany
   */
  export type StopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stops to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop create
   */
  export type StopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The data needed to create a Stop.
     */
    data: XOR<StopCreateInput, StopUncheckedCreateInput>
  }

  /**
   * Stop createMany
   */
  export type StopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stops.
     */
    data: StopCreateManyInput | StopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stop createManyAndReturn
   */
  export type StopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * The data used to create many Stops.
     */
    data: StopCreateManyInput | StopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stop update
   */
  export type StopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The data needed to update a Stop.
     */
    data: XOR<StopUpdateInput, StopUncheckedUpdateInput>
    /**
     * Choose, which Stop to update.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop updateMany
   */
  export type StopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stops.
     */
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyInput>
    /**
     * Filter which Stops to update
     */
    where?: StopWhereInput
    /**
     * Limit how many Stops to update.
     */
    limit?: number
  }

  /**
   * Stop updateManyAndReturn
   */
  export type StopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * The data used to update Stops.
     */
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyInput>
    /**
     * Filter which Stops to update
     */
    where?: StopWhereInput
    /**
     * Limit how many Stops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stop upsert
   */
  export type StopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The filter to search for the Stop to update in case it exists.
     */
    where: StopWhereUniqueInput
    /**
     * In case the Stop found by the `where` argument doesn't exist, create a new Stop with this data.
     */
    create: XOR<StopCreateInput, StopUncheckedCreateInput>
    /**
     * In case the Stop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StopUpdateInput, StopUncheckedUpdateInput>
  }

  /**
   * Stop delete
   */
  export type StopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter which Stop to delete.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop deleteMany
   */
  export type StopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stops to delete
     */
    where?: StopWhereInput
    /**
     * Limit how many Stops to delete.
     */
    limit?: number
  }

  /**
   * Stop.stopTimes
   */
  export type Stop$stopTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    where?: StopTimeWhereInput
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    cursor?: StopTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopTimeScalarFieldEnum | StopTimeScalarFieldEnum[]
  }

  /**
   * Stop.transfers
   */
  export type Stop$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Stop.transfersTo
   */
  export type Stop$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Stop.pathways
   */
  export type Stop$pathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Stop.pathwaysTo
   */
  export type Stop$pathwaysToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Stop.parentStop
   */
  export type Stop$parentStopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
  }

  /**
   * Stop.childStops
   */
  export type Stop$childStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    cursor?: StopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop.level
   */
  export type Stop$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
  }

  /**
   * Stop without action
   */
  export type StopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
  }


  /**
   * Model Route
   */

  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteAvgAggregateOutputType = {
    route_type: number | null
    route_sort_order: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
  }

  export type RouteSumAggregateOutputType = {
    route_type: number | null
    route_sort_order: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
  }

  export type RouteMinAggregateOutputType = {
    id: string | null
    route_id: string | null
    agency_id: string | null
    route_short_name: string | null
    route_long_name: string | null
    route_desc: string | null
    route_type: number | null
    route_url: string | null
    route_color: string | null
    route_text_color: string | null
    route_sort_order: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    network_id: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RouteMaxAggregateOutputType = {
    id: string | null
    route_id: string | null
    agency_id: string | null
    route_short_name: string | null
    route_long_name: string | null
    route_desc: string | null
    route_type: number | null
    route_url: string | null
    route_color: string | null
    route_text_color: string | null
    route_sort_order: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    network_id: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RouteCountAggregateOutputType = {
    id: number
    route_id: number
    agency_id: number
    route_short_name: number
    route_long_name: number
    route_desc: number
    route_type: number
    route_url: number
    route_color: number
    route_text_color: number
    route_sort_order: number
    continuous_pickup: number
    continuous_drop_off: number
    network_id: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RouteAvgAggregateInputType = {
    route_type?: true
    route_sort_order?: true
    continuous_pickup?: true
    continuous_drop_off?: true
  }

  export type RouteSumAggregateInputType = {
    route_type?: true
    route_sort_order?: true
    continuous_pickup?: true
    continuous_drop_off?: true
  }

  export type RouteMinAggregateInputType = {
    id?: true
    route_id?: true
    agency_id?: true
    route_short_name?: true
    route_long_name?: true
    route_desc?: true
    route_type?: true
    route_url?: true
    route_color?: true
    route_text_color?: true
    route_sort_order?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    network_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type RouteMaxAggregateInputType = {
    id?: true
    route_id?: true
    agency_id?: true
    route_short_name?: true
    route_long_name?: true
    route_desc?: true
    route_type?: true
    route_url?: true
    route_color?: true
    route_text_color?: true
    route_sort_order?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    network_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type RouteCountAggregateInputType = {
    id?: true
    route_id?: true
    agency_id?: true
    route_short_name?: true
    route_long_name?: true
    route_desc?: true
    route_type?: true
    route_url?: true
    route_color?: true
    route_text_color?: true
    route_sort_order?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    network_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithAggregationInput | RouteOrderByWithAggregationInput[]
    by: RouteScalarFieldEnum[] | RouteScalarFieldEnum
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _avg?: RouteAvgAggregateInputType
    _sum?: RouteSumAggregateInputType
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }

  export type RouteGroupByOutputType = {
    id: string
    route_id: string
    agency_id: string | null
    route_short_name: string | null
    route_long_name: string | null
    route_desc: string | null
    route_type: number
    route_url: string | null
    route_color: string | null
    route_text_color: string | null
    route_sort_order: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    network_id: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_id?: boolean
    agency_id?: boolean
    route_short_name?: boolean
    route_long_name?: boolean
    route_desc?: boolean
    route_type?: boolean
    route_url?: boolean
    route_color?: boolean
    route_text_color?: boolean
    route_sort_order?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    network_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | Route$agencyArgs<ExtArgs>
    trips?: boolean | Route$tripsArgs<ExtArgs>
    fareRules?: boolean | Route$fareRulesArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_id?: boolean
    agency_id?: boolean
    route_short_name?: boolean
    route_long_name?: boolean
    route_desc?: boolean
    route_type?: boolean
    route_url?: boolean
    route_color?: boolean
    route_text_color?: boolean
    route_sort_order?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    network_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | Route$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_id?: boolean
    agency_id?: boolean
    route_short_name?: boolean
    route_long_name?: boolean
    route_desc?: boolean
    route_type?: boolean
    route_url?: boolean
    route_color?: boolean
    route_text_color?: boolean
    route_sort_order?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    network_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | Route$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectScalar = {
    id?: boolean
    route_id?: boolean
    agency_id?: boolean
    route_short_name?: boolean
    route_long_name?: boolean
    route_desc?: boolean
    route_type?: boolean
    route_url?: boolean
    route_color?: boolean
    route_text_color?: boolean
    route_sort_order?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    network_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "route_id" | "agency_id" | "route_short_name" | "route_long_name" | "route_desc" | "route_type" | "route_url" | "route_color" | "route_text_color" | "route_sort_order" | "continuous_pickup" | "continuous_drop_off" | "network_id" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["route"]>
  export type RouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | Route$agencyArgs<ExtArgs>
    trips?: boolean | Route$tripsArgs<ExtArgs>
    fareRules?: boolean | Route$fareRulesArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | Route$agencyArgs<ExtArgs>
  }
  export type RouteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | Route$agencyArgs<ExtArgs>
  }

  export type $RoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Route"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs> | null
      trips: Prisma.$TripPayload<ExtArgs>[]
      fareRules: Prisma.$FareRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      route_id: string
      agency_id: string | null
      route_short_name: string | null
      route_long_name: string | null
      route_desc: string | null
      route_type: number
      route_url: string | null
      route_color: string | null
      route_text_color: string | null
      route_sort_order: number | null
      continuous_pickup: number | null
      continuous_drop_off: number | null
      network_id: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["route"]>
    composites: {}
  }

  type RouteGetPayload<S extends boolean | null | undefined | RouteDefaultArgs> = $Result.GetResult<Prisma.$RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFindUniqueArgs>(args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Route that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFindFirstArgs>(args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeWithIdOnly = await prisma.route.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFindManyArgs>(args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
     */
    create<T extends RouteCreateArgs>(args: SelectSubset<T, RouteCreateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Routes.
     * @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCreateManyArgs>(args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routes and returns the data saved in the database.
     * @param {RouteCreateManyAndReturnArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
     */
    delete<T extends RouteDeleteArgs>(args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteUpdateArgs>(args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDeleteManyArgs>(args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteUpdateManyArgs>(args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes and returns the data updated in the database.
     * @param {RouteUpdateManyAndReturnArgs} args - Arguments to update many Routes.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
     */
    upsert<T extends RouteUpsertArgs>(args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Route model
   */
  readonly fields: RouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends Route$agencyArgs<ExtArgs> = {}>(args?: Subset<T, Route$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trips<T extends Route$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Route$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fareRules<T extends Route$fareRulesArgs<ExtArgs> = {}>(args?: Subset<T, Route$fareRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Route model
   */
  interface RouteFieldRefs {
    readonly id: FieldRef<"Route", 'String'>
    readonly route_id: FieldRef<"Route", 'String'>
    readonly agency_id: FieldRef<"Route", 'String'>
    readonly route_short_name: FieldRef<"Route", 'String'>
    readonly route_long_name: FieldRef<"Route", 'String'>
    readonly route_desc: FieldRef<"Route", 'String'>
    readonly route_type: FieldRef<"Route", 'Int'>
    readonly route_url: FieldRef<"Route", 'String'>
    readonly route_color: FieldRef<"Route", 'String'>
    readonly route_text_color: FieldRef<"Route", 'String'>
    readonly route_sort_order: FieldRef<"Route", 'Int'>
    readonly continuous_pickup: FieldRef<"Route", 'Int'>
    readonly continuous_drop_off: FieldRef<"Route", 'Int'>
    readonly network_id: FieldRef<"Route", 'String'>
    readonly project_id: FieldRef<"Route", 'String'>
    readonly created_by: FieldRef<"Route", 'String'>
    readonly created_at: FieldRef<"Route", 'DateTime'>
    readonly updated_at: FieldRef<"Route", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Route findUnique
   */
  export type RouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findFirst
   */
  export type RouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }

  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route createManyAndReturn
   */
  export type RouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route updateManyAndReturn
   */
  export type RouteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }

  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to delete.
     */
    limit?: number
  }

  /**
   * Route.agency
   */
  export type Route$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Route.trips
   */
  export type Route$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Route.fareRules
   */
  export type Route$fareRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    where?: FareRuleWhereInput
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    cursor?: FareRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareRuleScalarFieldEnum | FareRuleScalarFieldEnum[]
  }

  /**
   * Route without action
   */
  export type RouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripAvgAggregateOutputType = {
    direction_id: number | null
    wheelchair_accessible: number | null
    bikes_allowed: number | null
  }

  export type TripSumAggregateOutputType = {
    direction_id: number | null
    wheelchair_accessible: number | null
    bikes_allowed: number | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    trip_id: string | null
    route_id: string | null
    service_id: string | null
    trip_headsign: string | null
    trip_short_name: string | null
    direction_id: number | null
    block_id: string | null
    shape_id: string | null
    wheelchair_accessible: number | null
    bikes_allowed: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    trip_id: string | null
    route_id: string | null
    service_id: string | null
    trip_headsign: string | null
    trip_short_name: string | null
    direction_id: number | null
    block_id: string | null
    shape_id: string | null
    wheelchair_accessible: number | null
    bikes_allowed: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    trip_id: number
    route_id: number
    service_id: number
    trip_headsign: number
    trip_short_name: number
    direction_id: number
    block_id: number
    shape_id: number
    wheelchair_accessible: number
    bikes_allowed: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TripAvgAggregateInputType = {
    direction_id?: true
    wheelchair_accessible?: true
    bikes_allowed?: true
  }

  export type TripSumAggregateInputType = {
    direction_id?: true
    wheelchair_accessible?: true
    bikes_allowed?: true
  }

  export type TripMinAggregateInputType = {
    id?: true
    trip_id?: true
    route_id?: true
    service_id?: true
    trip_headsign?: true
    trip_short_name?: true
    direction_id?: true
    block_id?: true
    shape_id?: true
    wheelchair_accessible?: true
    bikes_allowed?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    trip_id?: true
    route_id?: true
    service_id?: true
    trip_headsign?: true
    trip_short_name?: true
    direction_id?: true
    block_id?: true
    shape_id?: true
    wheelchair_accessible?: true
    bikes_allowed?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    trip_id?: true
    route_id?: true
    service_id?: true
    trip_headsign?: true
    trip_short_name?: true
    direction_id?: true
    block_id?: true
    shape_id?: true
    wheelchair_accessible?: true
    bikes_allowed?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _avg?: TripAvgAggregateInputType
    _sum?: TripSumAggregateInputType
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    trip_id: string
    route_id: string
    service_id: string
    trip_headsign: string | null
    trip_short_name: string | null
    direction_id: number | null
    block_id: string | null
    shape_id: string | null
    wheelchair_accessible: number | null
    bikes_allowed: number | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    route_id?: boolean
    service_id?: boolean
    trip_headsign?: boolean
    trip_short_name?: boolean
    direction_id?: boolean
    block_id?: boolean
    shape_id?: boolean
    wheelchair_accessible?: boolean
    bikes_allowed?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    calendar?: boolean | Trip$calendarArgs<ExtArgs>
    stopTimes?: boolean | Trip$stopTimesArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    route_id?: boolean
    service_id?: boolean
    trip_headsign?: boolean
    trip_short_name?: boolean
    direction_id?: boolean
    block_id?: boolean
    shape_id?: boolean
    wheelchair_accessible?: boolean
    bikes_allowed?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    calendar?: boolean | Trip$calendarArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    route_id?: boolean
    service_id?: boolean
    trip_headsign?: boolean
    trip_short_name?: boolean
    direction_id?: boolean
    block_id?: boolean
    shape_id?: boolean
    wheelchair_accessible?: boolean
    bikes_allowed?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    calendar?: boolean | Trip$calendarArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    trip_id?: boolean
    route_id?: boolean
    service_id?: boolean
    trip_headsign?: boolean
    trip_short_name?: boolean
    direction_id?: boolean
    block_id?: boolean
    shape_id?: boolean
    wheelchair_accessible?: boolean
    bikes_allowed?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TripOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trip_id" | "route_id" | "service_id" | "trip_headsign" | "trip_short_name" | "direction_id" | "block_id" | "shape_id" | "wheelchair_accessible" | "bikes_allowed" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["trip"]>
  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    calendar?: boolean | Trip$calendarArgs<ExtArgs>
    stopTimes?: boolean | Trip$stopTimesArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    calendar?: boolean | Trip$calendarArgs<ExtArgs>
  }
  export type TripIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    calendar?: boolean | Trip$calendarArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs>
      calendar: Prisma.$CalendarPayload<ExtArgs> | null
      stopTimes: Prisma.$StopTimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trip_id: string
      route_id: string
      service_id: string
      trip_headsign: string | null
      trip_short_name: string | null
      direction_id: number | null
      block_id: string | null
      shape_id: string | null
      wheelchair_accessible: number | null
      bikes_allowed: number | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips and returns the data updated in the database.
     * @param {TripUpdateManyAndReturnArgs} args - Arguments to update many Trips.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripUpdateManyAndReturnArgs>(args: SelectSubset<T, TripUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calendar<T extends Trip$calendarArgs<ExtArgs> = {}>(args?: Subset<T, Trip$calendarArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stopTimes<T extends Trip$stopTimesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$stopTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly trip_id: FieldRef<"Trip", 'String'>
    readonly route_id: FieldRef<"Trip", 'String'>
    readonly service_id: FieldRef<"Trip", 'String'>
    readonly trip_headsign: FieldRef<"Trip", 'String'>
    readonly trip_short_name: FieldRef<"Trip", 'String'>
    readonly direction_id: FieldRef<"Trip", 'Int'>
    readonly block_id: FieldRef<"Trip", 'String'>
    readonly shape_id: FieldRef<"Trip", 'String'>
    readonly wheelchair_accessible: FieldRef<"Trip", 'Int'>
    readonly bikes_allowed: FieldRef<"Trip", 'Int'>
    readonly project_id: FieldRef<"Trip", 'String'>
    readonly created_by: FieldRef<"Trip", 'String'>
    readonly created_at: FieldRef<"Trip", 'DateTime'>
    readonly updated_at: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
  }

  /**
   * Trip updateManyAndReturn
   */
  export type TripUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to delete.
     */
    limit?: number
  }

  /**
   * Trip.calendar
   */
  export type Trip$calendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
  }

  /**
   * Trip.stopTimes
   */
  export type Trip$stopTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    where?: StopTimeWhereInput
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    cursor?: StopTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopTimeScalarFieldEnum | StopTimeScalarFieldEnum[]
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model StopTime
   */

  export type AggregateStopTime = {
    _count: StopTimeCountAggregateOutputType | null
    _avg: StopTimeAvgAggregateOutputType | null
    _sum: StopTimeSumAggregateOutputType | null
    _min: StopTimeMinAggregateOutputType | null
    _max: StopTimeMaxAggregateOutputType | null
  }

  export type StopTimeAvgAggregateOutputType = {
    stop_sequence: number | null
    pickup_type: number | null
    drop_off_type: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    shape_dist_traveled: number | null
    timepoint: number | null
  }

  export type StopTimeSumAggregateOutputType = {
    stop_sequence: number | null
    pickup_type: number | null
    drop_off_type: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    shape_dist_traveled: number | null
    timepoint: number | null
  }

  export type StopTimeMinAggregateOutputType = {
    id: string | null
    trip_id: string | null
    stop_id: string | null
    arrival_time: string | null
    departure_time: string | null
    stop_sequence: number | null
    stop_headsign: string | null
    pickup_type: number | null
    drop_off_type: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    shape_dist_traveled: number | null
    timepoint: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StopTimeMaxAggregateOutputType = {
    id: string | null
    trip_id: string | null
    stop_id: string | null
    arrival_time: string | null
    departure_time: string | null
    stop_sequence: number | null
    stop_headsign: string | null
    pickup_type: number | null
    drop_off_type: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    shape_dist_traveled: number | null
    timepoint: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StopTimeCountAggregateOutputType = {
    id: number
    trip_id: number
    stop_id: number
    arrival_time: number
    departure_time: number
    stop_sequence: number
    stop_headsign: number
    pickup_type: number
    drop_off_type: number
    continuous_pickup: number
    continuous_drop_off: number
    shape_dist_traveled: number
    timepoint: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StopTimeAvgAggregateInputType = {
    stop_sequence?: true
    pickup_type?: true
    drop_off_type?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    shape_dist_traveled?: true
    timepoint?: true
  }

  export type StopTimeSumAggregateInputType = {
    stop_sequence?: true
    pickup_type?: true
    drop_off_type?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    shape_dist_traveled?: true
    timepoint?: true
  }

  export type StopTimeMinAggregateInputType = {
    id?: true
    trip_id?: true
    stop_id?: true
    arrival_time?: true
    departure_time?: true
    stop_sequence?: true
    stop_headsign?: true
    pickup_type?: true
    drop_off_type?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    shape_dist_traveled?: true
    timepoint?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type StopTimeMaxAggregateInputType = {
    id?: true
    trip_id?: true
    stop_id?: true
    arrival_time?: true
    departure_time?: true
    stop_sequence?: true
    stop_headsign?: true
    pickup_type?: true
    drop_off_type?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    shape_dist_traveled?: true
    timepoint?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type StopTimeCountAggregateInputType = {
    id?: true
    trip_id?: true
    stop_id?: true
    arrival_time?: true
    departure_time?: true
    stop_sequence?: true
    stop_headsign?: true
    pickup_type?: true
    drop_off_type?: true
    continuous_pickup?: true
    continuous_drop_off?: true
    shape_dist_traveled?: true
    timepoint?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StopTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StopTime to aggregate.
     */
    where?: StopTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopTimes to fetch.
     */
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StopTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StopTimes
    **/
    _count?: true | StopTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StopTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StopTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StopTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StopTimeMaxAggregateInputType
  }

  export type GetStopTimeAggregateType<T extends StopTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateStopTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStopTime[P]>
      : GetScalarType<T[P], AggregateStopTime[P]>
  }




  export type StopTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopTimeWhereInput
    orderBy?: StopTimeOrderByWithAggregationInput | StopTimeOrderByWithAggregationInput[]
    by: StopTimeScalarFieldEnum[] | StopTimeScalarFieldEnum
    having?: StopTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StopTimeCountAggregateInputType | true
    _avg?: StopTimeAvgAggregateInputType
    _sum?: StopTimeSumAggregateInputType
    _min?: StopTimeMinAggregateInputType
    _max?: StopTimeMaxAggregateInputType
  }

  export type StopTimeGroupByOutputType = {
    id: string
    trip_id: string
    stop_id: string
    arrival_time: string | null
    departure_time: string | null
    stop_sequence: number
    stop_headsign: string | null
    pickup_type: number | null
    drop_off_type: number | null
    continuous_pickup: number | null
    continuous_drop_off: number | null
    shape_dist_traveled: number | null
    timepoint: number | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: StopTimeCountAggregateOutputType | null
    _avg: StopTimeAvgAggregateOutputType | null
    _sum: StopTimeSumAggregateOutputType | null
    _min: StopTimeMinAggregateOutputType | null
    _max: StopTimeMaxAggregateOutputType | null
  }

  type GetStopTimeGroupByPayload<T extends StopTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StopTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StopTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StopTimeGroupByOutputType[P]>
            : GetScalarType<T[P], StopTimeGroupByOutputType[P]>
        }
      >
    >


  export type StopTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    stop_id?: boolean
    arrival_time?: boolean
    departure_time?: boolean
    stop_sequence?: boolean
    stop_headsign?: boolean
    pickup_type?: boolean
    drop_off_type?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    shape_dist_traveled?: boolean
    timepoint?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stopTime"]>

  export type StopTimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    stop_id?: boolean
    arrival_time?: boolean
    departure_time?: boolean
    stop_sequence?: boolean
    stop_headsign?: boolean
    pickup_type?: boolean
    drop_off_type?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    shape_dist_traveled?: boolean
    timepoint?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stopTime"]>

  export type StopTimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    stop_id?: boolean
    arrival_time?: boolean
    departure_time?: boolean
    stop_sequence?: boolean
    stop_headsign?: boolean
    pickup_type?: boolean
    drop_off_type?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    shape_dist_traveled?: boolean
    timepoint?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stopTime"]>

  export type StopTimeSelectScalar = {
    id?: boolean
    trip_id?: boolean
    stop_id?: boolean
    arrival_time?: boolean
    departure_time?: boolean
    stop_sequence?: boolean
    stop_headsign?: boolean
    pickup_type?: boolean
    drop_off_type?: boolean
    continuous_pickup?: boolean
    continuous_drop_off?: boolean
    shape_dist_traveled?: boolean
    timepoint?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StopTimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trip_id" | "stop_id" | "arrival_time" | "departure_time" | "stop_sequence" | "stop_headsign" | "pickup_type" | "drop_off_type" | "continuous_pickup" | "continuous_drop_off" | "shape_dist_traveled" | "timepoint" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["stopTime"]>
  export type StopTimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }
  export type StopTimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }
  export type StopTimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }

  export type $StopTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StopTime"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      trip: Prisma.$TripPayload<ExtArgs>
      stop: Prisma.$StopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trip_id: string
      stop_id: string
      arrival_time: string | null
      departure_time: string | null
      stop_sequence: number
      stop_headsign: string | null
      pickup_type: number | null
      drop_off_type: number | null
      continuous_pickup: number | null
      continuous_drop_off: number | null
      shape_dist_traveled: number | null
      timepoint: number | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stopTime"]>
    composites: {}
  }

  type StopTimeGetPayload<S extends boolean | null | undefined | StopTimeDefaultArgs> = $Result.GetResult<Prisma.$StopTimePayload, S>

  type StopTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StopTimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StopTimeCountAggregateInputType | true
    }

  export interface StopTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StopTime'], meta: { name: 'StopTime' } }
    /**
     * Find zero or one StopTime that matches the filter.
     * @param {StopTimeFindUniqueArgs} args - Arguments to find a StopTime
     * @example
     * // Get one StopTime
     * const stopTime = await prisma.stopTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StopTimeFindUniqueArgs>(args: SelectSubset<T, StopTimeFindUniqueArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StopTime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StopTimeFindUniqueOrThrowArgs} args - Arguments to find a StopTime
     * @example
     * // Get one StopTime
     * const stopTime = await prisma.stopTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StopTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, StopTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StopTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeFindFirstArgs} args - Arguments to find a StopTime
     * @example
     * // Get one StopTime
     * const stopTime = await prisma.stopTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StopTimeFindFirstArgs>(args?: SelectSubset<T, StopTimeFindFirstArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StopTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeFindFirstOrThrowArgs} args - Arguments to find a StopTime
     * @example
     * // Get one StopTime
     * const stopTime = await prisma.stopTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StopTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, StopTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StopTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StopTimes
     * const stopTimes = await prisma.stopTime.findMany()
     * 
     * // Get first 10 StopTimes
     * const stopTimes = await prisma.stopTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stopTimeWithIdOnly = await prisma.stopTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StopTimeFindManyArgs>(args?: SelectSubset<T, StopTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StopTime.
     * @param {StopTimeCreateArgs} args - Arguments to create a StopTime.
     * @example
     * // Create one StopTime
     * const StopTime = await prisma.stopTime.create({
     *   data: {
     *     // ... data to create a StopTime
     *   }
     * })
     * 
     */
    create<T extends StopTimeCreateArgs>(args: SelectSubset<T, StopTimeCreateArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StopTimes.
     * @param {StopTimeCreateManyArgs} args - Arguments to create many StopTimes.
     * @example
     * // Create many StopTimes
     * const stopTime = await prisma.stopTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StopTimeCreateManyArgs>(args?: SelectSubset<T, StopTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StopTimes and returns the data saved in the database.
     * @param {StopTimeCreateManyAndReturnArgs} args - Arguments to create many StopTimes.
     * @example
     * // Create many StopTimes
     * const stopTime = await prisma.stopTime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StopTimes and only return the `id`
     * const stopTimeWithIdOnly = await prisma.stopTime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StopTimeCreateManyAndReturnArgs>(args?: SelectSubset<T, StopTimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StopTime.
     * @param {StopTimeDeleteArgs} args - Arguments to delete one StopTime.
     * @example
     * // Delete one StopTime
     * const StopTime = await prisma.stopTime.delete({
     *   where: {
     *     // ... filter to delete one StopTime
     *   }
     * })
     * 
     */
    delete<T extends StopTimeDeleteArgs>(args: SelectSubset<T, StopTimeDeleteArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StopTime.
     * @param {StopTimeUpdateArgs} args - Arguments to update one StopTime.
     * @example
     * // Update one StopTime
     * const stopTime = await prisma.stopTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StopTimeUpdateArgs>(args: SelectSubset<T, StopTimeUpdateArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StopTimes.
     * @param {StopTimeDeleteManyArgs} args - Arguments to filter StopTimes to delete.
     * @example
     * // Delete a few StopTimes
     * const { count } = await prisma.stopTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StopTimeDeleteManyArgs>(args?: SelectSubset<T, StopTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StopTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StopTimes
     * const stopTime = await prisma.stopTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StopTimeUpdateManyArgs>(args: SelectSubset<T, StopTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StopTimes and returns the data updated in the database.
     * @param {StopTimeUpdateManyAndReturnArgs} args - Arguments to update many StopTimes.
     * @example
     * // Update many StopTimes
     * const stopTime = await prisma.stopTime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StopTimes and only return the `id`
     * const stopTimeWithIdOnly = await prisma.stopTime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StopTimeUpdateManyAndReturnArgs>(args: SelectSubset<T, StopTimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StopTime.
     * @param {StopTimeUpsertArgs} args - Arguments to update or create a StopTime.
     * @example
     * // Update or create a StopTime
     * const stopTime = await prisma.stopTime.upsert({
     *   create: {
     *     // ... data to create a StopTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StopTime we want to update
     *   }
     * })
     */
    upsert<T extends StopTimeUpsertArgs>(args: SelectSubset<T, StopTimeUpsertArgs<ExtArgs>>): Prisma__StopTimeClient<$Result.GetResult<Prisma.$StopTimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StopTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeCountArgs} args - Arguments to filter StopTimes to count.
     * @example
     * // Count the number of StopTimes
     * const count = await prisma.stopTime.count({
     *   where: {
     *     // ... the filter for the StopTimes we want to count
     *   }
     * })
    **/
    count<T extends StopTimeCountArgs>(
      args?: Subset<T, StopTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StopTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StopTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StopTimeAggregateArgs>(args: Subset<T, StopTimeAggregateArgs>): Prisma.PrismaPromise<GetStopTimeAggregateType<T>>

    /**
     * Group by StopTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StopTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StopTimeGroupByArgs['orderBy'] }
        : { orderBy?: StopTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StopTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStopTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StopTime model
   */
  readonly fields: StopTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StopTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StopTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StopTime model
   */
  interface StopTimeFieldRefs {
    readonly id: FieldRef<"StopTime", 'String'>
    readonly trip_id: FieldRef<"StopTime", 'String'>
    readonly stop_id: FieldRef<"StopTime", 'String'>
    readonly arrival_time: FieldRef<"StopTime", 'String'>
    readonly departure_time: FieldRef<"StopTime", 'String'>
    readonly stop_sequence: FieldRef<"StopTime", 'Int'>
    readonly stop_headsign: FieldRef<"StopTime", 'String'>
    readonly pickup_type: FieldRef<"StopTime", 'Int'>
    readonly drop_off_type: FieldRef<"StopTime", 'Int'>
    readonly continuous_pickup: FieldRef<"StopTime", 'Int'>
    readonly continuous_drop_off: FieldRef<"StopTime", 'Int'>
    readonly shape_dist_traveled: FieldRef<"StopTime", 'Float'>
    readonly timepoint: FieldRef<"StopTime", 'Int'>
    readonly project_id: FieldRef<"StopTime", 'String'>
    readonly created_by: FieldRef<"StopTime", 'String'>
    readonly created_at: FieldRef<"StopTime", 'DateTime'>
    readonly updated_at: FieldRef<"StopTime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StopTime findUnique
   */
  export type StopTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * Filter, which StopTime to fetch.
     */
    where: StopTimeWhereUniqueInput
  }

  /**
   * StopTime findUniqueOrThrow
   */
  export type StopTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * Filter, which StopTime to fetch.
     */
    where: StopTimeWhereUniqueInput
  }

  /**
   * StopTime findFirst
   */
  export type StopTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * Filter, which StopTime to fetch.
     */
    where?: StopTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopTimes to fetch.
     */
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StopTimes.
     */
    cursor?: StopTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StopTimes.
     */
    distinct?: StopTimeScalarFieldEnum | StopTimeScalarFieldEnum[]
  }

  /**
   * StopTime findFirstOrThrow
   */
  export type StopTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * Filter, which StopTime to fetch.
     */
    where?: StopTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopTimes to fetch.
     */
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StopTimes.
     */
    cursor?: StopTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StopTimes.
     */
    distinct?: StopTimeScalarFieldEnum | StopTimeScalarFieldEnum[]
  }

  /**
   * StopTime findMany
   */
  export type StopTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * Filter, which StopTimes to fetch.
     */
    where?: StopTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopTimes to fetch.
     */
    orderBy?: StopTimeOrderByWithRelationInput | StopTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StopTimes.
     */
    cursor?: StopTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopTimes.
     */
    skip?: number
    distinct?: StopTimeScalarFieldEnum | StopTimeScalarFieldEnum[]
  }

  /**
   * StopTime create
   */
  export type StopTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * The data needed to create a StopTime.
     */
    data: XOR<StopTimeCreateInput, StopTimeUncheckedCreateInput>
  }

  /**
   * StopTime createMany
   */
  export type StopTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StopTimes.
     */
    data: StopTimeCreateManyInput | StopTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StopTime createManyAndReturn
   */
  export type StopTimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * The data used to create many StopTimes.
     */
    data: StopTimeCreateManyInput | StopTimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StopTime update
   */
  export type StopTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * The data needed to update a StopTime.
     */
    data: XOR<StopTimeUpdateInput, StopTimeUncheckedUpdateInput>
    /**
     * Choose, which StopTime to update.
     */
    where: StopTimeWhereUniqueInput
  }

  /**
   * StopTime updateMany
   */
  export type StopTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StopTimes.
     */
    data: XOR<StopTimeUpdateManyMutationInput, StopTimeUncheckedUpdateManyInput>
    /**
     * Filter which StopTimes to update
     */
    where?: StopTimeWhereInput
    /**
     * Limit how many StopTimes to update.
     */
    limit?: number
  }

  /**
   * StopTime updateManyAndReturn
   */
  export type StopTimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * The data used to update StopTimes.
     */
    data: XOR<StopTimeUpdateManyMutationInput, StopTimeUncheckedUpdateManyInput>
    /**
     * Filter which StopTimes to update
     */
    where?: StopTimeWhereInput
    /**
     * Limit how many StopTimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StopTime upsert
   */
  export type StopTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * The filter to search for the StopTime to update in case it exists.
     */
    where: StopTimeWhereUniqueInput
    /**
     * In case the StopTime found by the `where` argument doesn't exist, create a new StopTime with this data.
     */
    create: XOR<StopTimeCreateInput, StopTimeUncheckedCreateInput>
    /**
     * In case the StopTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StopTimeUpdateInput, StopTimeUncheckedUpdateInput>
  }

  /**
   * StopTime delete
   */
  export type StopTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
    /**
     * Filter which StopTime to delete.
     */
    where: StopTimeWhereUniqueInput
  }

  /**
   * StopTime deleteMany
   */
  export type StopTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StopTimes to delete
     */
    where?: StopTimeWhereInput
    /**
     * Limit how many StopTimes to delete.
     */
    limit?: number
  }

  /**
   * StopTime without action
   */
  export type StopTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopTime
     */
    select?: StopTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopTime
     */
    omit?: StopTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopTimeInclude<ExtArgs> | null
  }


  /**
   * Model Calendar
   */

  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _avg: CalendarAvgAggregateOutputType | null
    _sum: CalendarSumAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarAvgAggregateOutputType = {
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
  }

  export type CalendarSumAggregateOutputType = {
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
  }

  export type CalendarMinAggregateOutputType = {
    id: string | null
    service_id: string | null
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
    start_date: string | null
    end_date: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: string | null
    service_id: string | null
    monday: number | null
    tuesday: number | null
    wednesday: number | null
    thursday: number | null
    friday: number | null
    saturday: number | null
    sunday: number | null
    start_date: string | null
    end_date: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    service_id: number
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: number
    end_date: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CalendarAvgAggregateInputType = {
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
  }

  export type CalendarSumAggregateInputType = {
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
  }

  export type CalendarMinAggregateInputType = {
    id?: true
    service_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    start_date?: true
    end_date?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    service_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    start_date?: true
    end_date?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    service_id?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    start_date?: true
    end_date?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendar to aggregate.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type CalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithAggregationInput | CalendarOrderByWithAggregationInput[]
    by: CalendarScalarFieldEnum[] | CalendarScalarFieldEnum
    having?: CalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _avg?: CalendarAvgAggregateInputType
    _sum?: CalendarSumAggregateInputType
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }

  export type CalendarGroupByOutputType = {
    id: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: CalendarCountAggregateOutputType | null
    _avg: CalendarAvgAggregateOutputType | null
    _sum: CalendarSumAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends CalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type CalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    start_date?: boolean
    end_date?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trips?: boolean | Calendar$tripsArgs<ExtArgs>
    exceptions?: boolean | Calendar$exceptionsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    start_date?: boolean
    end_date?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    start_date?: boolean
    end_date?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type CalendarSelectScalar = {
    id?: boolean
    service_id?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    start_date?: boolean
    end_date?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CalendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday" | "start_date" | "end_date" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["calendar"]>
  export type CalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    trips?: boolean | Calendar$tripsArgs<ExtArgs>
    exceptions?: boolean | Calendar$exceptionsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type CalendarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }

  export type $CalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Calendar"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      trips: Prisma.$TripPayload<ExtArgs>[]
      exceptions: Prisma.$CalendarDatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_id: string
      monday: number
      tuesday: number
      wednesday: number
      thursday: number
      friday: number
      saturday: number
      sunday: number
      start_date: string
      end_date: string
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["calendar"]>
    composites: {}
  }

  type CalendarGetPayload<S extends boolean | null | undefined | CalendarDefaultArgs> = $Result.GetResult<Prisma.$CalendarPayload, S>

  type CalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface CalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Calendar'], meta: { name: 'Calendar' } }
    /**
     * Find zero or one Calendar that matches the filter.
     * @param {CalendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarFindUniqueArgs>(args: SelectSubset<T, CalendarFindUniqueArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarFindFirstArgs>(args?: SelectSubset<T, CalendarFindFirstArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarFindManyArgs>(args?: SelectSubset<T, CalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calendar.
     * @param {CalendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
     */
    create<T extends CalendarCreateArgs>(args: SelectSubset<T, CalendarCreateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calendars.
     * @param {CalendarCreateManyArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarCreateManyArgs>(args?: SelectSubset<T, CalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calendars and returns the data saved in the database.
     * @param {CalendarCreateManyAndReturnArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calendars and only return the `id`
     * const calendarWithIdOnly = await prisma.calendar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Calendar.
     * @param {CalendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
     */
    delete<T extends CalendarDeleteArgs>(args: SelectSubset<T, CalendarDeleteArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calendar.
     * @param {CalendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarUpdateArgs>(args: SelectSubset<T, CalendarUpdateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calendars.
     * @param {CalendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarDeleteManyArgs>(args?: SelectSubset<T, CalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarUpdateManyArgs>(args: SelectSubset<T, CalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars and returns the data updated in the database.
     * @param {CalendarUpdateManyAndReturnArgs} args - Arguments to update many Calendars.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calendars and only return the `id`
     * const calendarWithIdOnly = await prisma.calendar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Calendar.
     * @param {CalendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
     */
    upsert<T extends CalendarUpsertArgs>(args: SelectSubset<T, CalendarUpsertArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends CalendarCountArgs>(
      args?: Subset<T, CalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarGroupByArgs['orderBy'] }
        : { orderBy?: CalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Calendar model
   */
  readonly fields: CalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trips<T extends Calendar$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exceptions<T extends Calendar$exceptionsArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$exceptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Calendar model
   */
  interface CalendarFieldRefs {
    readonly id: FieldRef<"Calendar", 'String'>
    readonly service_id: FieldRef<"Calendar", 'String'>
    readonly monday: FieldRef<"Calendar", 'Int'>
    readonly tuesday: FieldRef<"Calendar", 'Int'>
    readonly wednesday: FieldRef<"Calendar", 'Int'>
    readonly thursday: FieldRef<"Calendar", 'Int'>
    readonly friday: FieldRef<"Calendar", 'Int'>
    readonly saturday: FieldRef<"Calendar", 'Int'>
    readonly sunday: FieldRef<"Calendar", 'Int'>
    readonly start_date: FieldRef<"Calendar", 'String'>
    readonly end_date: FieldRef<"Calendar", 'String'>
    readonly project_id: FieldRef<"Calendar", 'String'>
    readonly created_by: FieldRef<"Calendar", 'String'>
    readonly created_at: FieldRef<"Calendar", 'DateTime'>
    readonly updated_at: FieldRef<"Calendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Calendar findUnique
   */
  export type CalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findUniqueOrThrow
   */
  export type CalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findFirst
   */
  export type CalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findFirstOrThrow
   */
  export type CalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findMany
   */
  export type CalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendars to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar create
   */
  export type CalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a Calendar.
     */
    data: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
  }

  /**
   * Calendar createMany
   */
  export type CalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Calendar createManyAndReturn
   */
  export type CalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calendar update
   */
  export type CalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a Calendar.
     */
    data: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
    /**
     * Choose, which Calendar to update.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar updateMany
   */
  export type CalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
    /**
     * Limit how many Calendars to update.
     */
    limit?: number
  }

  /**
   * Calendar updateManyAndReturn
   */
  export type CalendarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
    /**
     * Limit how many Calendars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Calendar upsert
   */
  export type CalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the Calendar to update in case it exists.
     */
    where: CalendarWhereUniqueInput
    /**
     * In case the Calendar found by the `where` argument doesn't exist, create a new Calendar with this data.
     */
    create: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
    /**
     * In case the Calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
  }

  /**
   * Calendar delete
   */
  export type CalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter which Calendar to delete.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar deleteMany
   */
  export type CalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendars to delete
     */
    where?: CalendarWhereInput
    /**
     * Limit how many Calendars to delete.
     */
    limit?: number
  }

  /**
   * Calendar.trips
   */
  export type Calendar$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Calendar.exceptions
   */
  export type Calendar$exceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    where?: CalendarDateWhereInput
    orderBy?: CalendarDateOrderByWithRelationInput | CalendarDateOrderByWithRelationInput[]
    cursor?: CalendarDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarDateScalarFieldEnum | CalendarDateScalarFieldEnum[]
  }

  /**
   * Calendar without action
   */
  export type CalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
  }


  /**
   * Model CalendarDate
   */

  export type AggregateCalendarDate = {
    _count: CalendarDateCountAggregateOutputType | null
    _avg: CalendarDateAvgAggregateOutputType | null
    _sum: CalendarDateSumAggregateOutputType | null
    _min: CalendarDateMinAggregateOutputType | null
    _max: CalendarDateMaxAggregateOutputType | null
  }

  export type CalendarDateAvgAggregateOutputType = {
    exception_type: number | null
  }

  export type CalendarDateSumAggregateOutputType = {
    exception_type: number | null
  }

  export type CalendarDateMinAggregateOutputType = {
    id: string | null
    service_id: string | null
    date: string | null
    exception_type: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CalendarDateMaxAggregateOutputType = {
    id: string | null
    service_id: string | null
    date: string | null
    exception_type: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CalendarDateCountAggregateOutputType = {
    id: number
    service_id: number
    date: number
    exception_type: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CalendarDateAvgAggregateInputType = {
    exception_type?: true
  }

  export type CalendarDateSumAggregateInputType = {
    exception_type?: true
  }

  export type CalendarDateMinAggregateInputType = {
    id?: true
    service_id?: true
    date?: true
    exception_type?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CalendarDateMaxAggregateInputType = {
    id?: true
    service_id?: true
    date?: true
    exception_type?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CalendarDateCountAggregateInputType = {
    id?: true
    service_id?: true
    date?: true
    exception_type?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CalendarDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarDate to aggregate.
     */
    where?: CalendarDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDates to fetch.
     */
    orderBy?: CalendarDateOrderByWithRelationInput | CalendarDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarDates
    **/
    _count?: true | CalendarDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarDateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarDateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarDateMaxAggregateInputType
  }

  export type GetCalendarDateAggregateType<T extends CalendarDateAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarDate[P]>
      : GetScalarType<T[P], AggregateCalendarDate[P]>
  }




  export type CalendarDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarDateWhereInput
    orderBy?: CalendarDateOrderByWithAggregationInput | CalendarDateOrderByWithAggregationInput[]
    by: CalendarDateScalarFieldEnum[] | CalendarDateScalarFieldEnum
    having?: CalendarDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarDateCountAggregateInputType | true
    _avg?: CalendarDateAvgAggregateInputType
    _sum?: CalendarDateSumAggregateInputType
    _min?: CalendarDateMinAggregateInputType
    _max?: CalendarDateMaxAggregateInputType
  }

  export type CalendarDateGroupByOutputType = {
    id: string
    service_id: string
    date: string
    exception_type: number
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: CalendarDateCountAggregateOutputType | null
    _avg: CalendarDateAvgAggregateOutputType | null
    _sum: CalendarDateSumAggregateOutputType | null
    _min: CalendarDateMinAggregateOutputType | null
    _max: CalendarDateMaxAggregateOutputType | null
  }

  type GetCalendarDateGroupByPayload<T extends CalendarDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarDateGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarDateGroupByOutputType[P]>
        }
      >
    >


  export type CalendarDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    date?: boolean
    exception_type?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarDate"]>

  export type CalendarDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    date?: boolean
    exception_type?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarDate"]>

  export type CalendarDateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    date?: boolean
    exception_type?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarDate"]>

  export type CalendarDateSelectScalar = {
    id?: boolean
    service_id?: boolean
    date?: boolean
    exception_type?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CalendarDateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "date" | "exception_type" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["calendarDate"]>
  export type CalendarDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }
  export type CalendarDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }
  export type CalendarDateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    calendar?: boolean | CalendarDefaultArgs<ExtArgs>
  }

  export type $CalendarDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarDate"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      calendar: Prisma.$CalendarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_id: string
      date: string
      exception_type: number
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["calendarDate"]>
    composites: {}
  }

  type CalendarDateGetPayload<S extends boolean | null | undefined | CalendarDateDefaultArgs> = $Result.GetResult<Prisma.$CalendarDatePayload, S>

  type CalendarDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarDateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarDateCountAggregateInputType | true
    }

  export interface CalendarDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarDate'], meta: { name: 'CalendarDate' } }
    /**
     * Find zero or one CalendarDate that matches the filter.
     * @param {CalendarDateFindUniqueArgs} args - Arguments to find a CalendarDate
     * @example
     * // Get one CalendarDate
     * const calendarDate = await prisma.calendarDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarDateFindUniqueArgs>(args: SelectSubset<T, CalendarDateFindUniqueArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarDate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarDateFindUniqueOrThrowArgs} args - Arguments to find a CalendarDate
     * @example
     * // Get one CalendarDate
     * const calendarDate = await prisma.calendarDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarDateFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateFindFirstArgs} args - Arguments to find a CalendarDate
     * @example
     * // Get one CalendarDate
     * const calendarDate = await prisma.calendarDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarDateFindFirstArgs>(args?: SelectSubset<T, CalendarDateFindFirstArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateFindFirstOrThrowArgs} args - Arguments to find a CalendarDate
     * @example
     * // Get one CalendarDate
     * const calendarDate = await prisma.calendarDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarDateFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarDates
     * const calendarDates = await prisma.calendarDate.findMany()
     * 
     * // Get first 10 CalendarDates
     * const calendarDates = await prisma.calendarDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarDateWithIdOnly = await prisma.calendarDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarDateFindManyArgs>(args?: SelectSubset<T, CalendarDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarDate.
     * @param {CalendarDateCreateArgs} args - Arguments to create a CalendarDate.
     * @example
     * // Create one CalendarDate
     * const CalendarDate = await prisma.calendarDate.create({
     *   data: {
     *     // ... data to create a CalendarDate
     *   }
     * })
     * 
     */
    create<T extends CalendarDateCreateArgs>(args: SelectSubset<T, CalendarDateCreateArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarDates.
     * @param {CalendarDateCreateManyArgs} args - Arguments to create many CalendarDates.
     * @example
     * // Create many CalendarDates
     * const calendarDate = await prisma.calendarDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarDateCreateManyArgs>(args?: SelectSubset<T, CalendarDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarDates and returns the data saved in the database.
     * @param {CalendarDateCreateManyAndReturnArgs} args - Arguments to create many CalendarDates.
     * @example
     * // Create many CalendarDates
     * const calendarDate = await prisma.calendarDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarDates and only return the `id`
     * const calendarDateWithIdOnly = await prisma.calendarDate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarDateCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarDate.
     * @param {CalendarDateDeleteArgs} args - Arguments to delete one CalendarDate.
     * @example
     * // Delete one CalendarDate
     * const CalendarDate = await prisma.calendarDate.delete({
     *   where: {
     *     // ... filter to delete one CalendarDate
     *   }
     * })
     * 
     */
    delete<T extends CalendarDateDeleteArgs>(args: SelectSubset<T, CalendarDateDeleteArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarDate.
     * @param {CalendarDateUpdateArgs} args - Arguments to update one CalendarDate.
     * @example
     * // Update one CalendarDate
     * const calendarDate = await prisma.calendarDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarDateUpdateArgs>(args: SelectSubset<T, CalendarDateUpdateArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarDates.
     * @param {CalendarDateDeleteManyArgs} args - Arguments to filter CalendarDates to delete.
     * @example
     * // Delete a few CalendarDates
     * const { count } = await prisma.calendarDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarDateDeleteManyArgs>(args?: SelectSubset<T, CalendarDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarDates
     * const calendarDate = await prisma.calendarDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarDateUpdateManyArgs>(args: SelectSubset<T, CalendarDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarDates and returns the data updated in the database.
     * @param {CalendarDateUpdateManyAndReturnArgs} args - Arguments to update many CalendarDates.
     * @example
     * // Update many CalendarDates
     * const calendarDate = await prisma.calendarDate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarDates and only return the `id`
     * const calendarDateWithIdOnly = await prisma.calendarDate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarDateUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarDateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarDate.
     * @param {CalendarDateUpsertArgs} args - Arguments to update or create a CalendarDate.
     * @example
     * // Update or create a CalendarDate
     * const calendarDate = await prisma.calendarDate.upsert({
     *   create: {
     *     // ... data to create a CalendarDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarDate we want to update
     *   }
     * })
     */
    upsert<T extends CalendarDateUpsertArgs>(args: SelectSubset<T, CalendarDateUpsertArgs<ExtArgs>>): Prisma__CalendarDateClient<$Result.GetResult<Prisma.$CalendarDatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateCountArgs} args - Arguments to filter CalendarDates to count.
     * @example
     * // Count the number of CalendarDates
     * const count = await prisma.calendarDate.count({
     *   where: {
     *     // ... the filter for the CalendarDates we want to count
     *   }
     * })
    **/
    count<T extends CalendarDateCountArgs>(
      args?: Subset<T, CalendarDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarDateAggregateArgs>(args: Subset<T, CalendarDateAggregateArgs>): Prisma.PrismaPromise<GetCalendarDateAggregateType<T>>

    /**
     * Group by CalendarDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarDateGroupByArgs['orderBy'] }
        : { orderBy?: CalendarDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarDate model
   */
  readonly fields: CalendarDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calendar<T extends CalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarDefaultArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarDate model
   */
  interface CalendarDateFieldRefs {
    readonly id: FieldRef<"CalendarDate", 'String'>
    readonly service_id: FieldRef<"CalendarDate", 'String'>
    readonly date: FieldRef<"CalendarDate", 'String'>
    readonly exception_type: FieldRef<"CalendarDate", 'Int'>
    readonly project_id: FieldRef<"CalendarDate", 'String'>
    readonly created_by: FieldRef<"CalendarDate", 'String'>
    readonly created_at: FieldRef<"CalendarDate", 'DateTime'>
    readonly updated_at: FieldRef<"CalendarDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarDate findUnique
   */
  export type CalendarDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDate to fetch.
     */
    where: CalendarDateWhereUniqueInput
  }

  /**
   * CalendarDate findUniqueOrThrow
   */
  export type CalendarDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDate to fetch.
     */
    where: CalendarDateWhereUniqueInput
  }

  /**
   * CalendarDate findFirst
   */
  export type CalendarDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDate to fetch.
     */
    where?: CalendarDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDates to fetch.
     */
    orderBy?: CalendarDateOrderByWithRelationInput | CalendarDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarDates.
     */
    cursor?: CalendarDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarDates.
     */
    distinct?: CalendarDateScalarFieldEnum | CalendarDateScalarFieldEnum[]
  }

  /**
   * CalendarDate findFirstOrThrow
   */
  export type CalendarDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDate to fetch.
     */
    where?: CalendarDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDates to fetch.
     */
    orderBy?: CalendarDateOrderByWithRelationInput | CalendarDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarDates.
     */
    cursor?: CalendarDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarDates.
     */
    distinct?: CalendarDateScalarFieldEnum | CalendarDateScalarFieldEnum[]
  }

  /**
   * CalendarDate findMany
   */
  export type CalendarDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * Filter, which CalendarDates to fetch.
     */
    where?: CalendarDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarDates to fetch.
     */
    orderBy?: CalendarDateOrderByWithRelationInput | CalendarDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarDates.
     */
    cursor?: CalendarDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarDates.
     */
    skip?: number
    distinct?: CalendarDateScalarFieldEnum | CalendarDateScalarFieldEnum[]
  }

  /**
   * CalendarDate create
   */
  export type CalendarDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarDate.
     */
    data: XOR<CalendarDateCreateInput, CalendarDateUncheckedCreateInput>
  }

  /**
   * CalendarDate createMany
   */
  export type CalendarDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarDates.
     */
    data: CalendarDateCreateManyInput | CalendarDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarDate createManyAndReturn
   */
  export type CalendarDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarDates.
     */
    data: CalendarDateCreateManyInput | CalendarDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarDate update
   */
  export type CalendarDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarDate.
     */
    data: XOR<CalendarDateUpdateInput, CalendarDateUncheckedUpdateInput>
    /**
     * Choose, which CalendarDate to update.
     */
    where: CalendarDateWhereUniqueInput
  }

  /**
   * CalendarDate updateMany
   */
  export type CalendarDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarDates.
     */
    data: XOR<CalendarDateUpdateManyMutationInput, CalendarDateUncheckedUpdateManyInput>
    /**
     * Filter which CalendarDates to update
     */
    where?: CalendarDateWhereInput
    /**
     * Limit how many CalendarDates to update.
     */
    limit?: number
  }

  /**
   * CalendarDate updateManyAndReturn
   */
  export type CalendarDateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * The data used to update CalendarDates.
     */
    data: XOR<CalendarDateUpdateManyMutationInput, CalendarDateUncheckedUpdateManyInput>
    /**
     * Filter which CalendarDates to update
     */
    where?: CalendarDateWhereInput
    /**
     * Limit how many CalendarDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarDate upsert
   */
  export type CalendarDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarDate to update in case it exists.
     */
    where: CalendarDateWhereUniqueInput
    /**
     * In case the CalendarDate found by the `where` argument doesn't exist, create a new CalendarDate with this data.
     */
    create: XOR<CalendarDateCreateInput, CalendarDateUncheckedCreateInput>
    /**
     * In case the CalendarDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarDateUpdateInput, CalendarDateUncheckedUpdateInput>
  }

  /**
   * CalendarDate delete
   */
  export type CalendarDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
    /**
     * Filter which CalendarDate to delete.
     */
    where: CalendarDateWhereUniqueInput
  }

  /**
   * CalendarDate deleteMany
   */
  export type CalendarDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarDates to delete
     */
    where?: CalendarDateWhereInput
    /**
     * Limit how many CalendarDates to delete.
     */
    limit?: number
  }

  /**
   * CalendarDate without action
   */
  export type CalendarDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarDate
     */
    select?: CalendarDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarDate
     */
    omit?: CalendarDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarDateInclude<ExtArgs> | null
  }


  /**
   * Model FareAttribute
   */

  export type AggregateFareAttribute = {
    _count: FareAttributeCountAggregateOutputType | null
    _avg: FareAttributeAvgAggregateOutputType | null
    _sum: FareAttributeSumAggregateOutputType | null
    _min: FareAttributeMinAggregateOutputType | null
    _max: FareAttributeMaxAggregateOutputType | null
  }

  export type FareAttributeAvgAggregateOutputType = {
    price: number | null
    payment_method: number | null
    transfers: number | null
    transfer_duration: number | null
  }

  export type FareAttributeSumAggregateOutputType = {
    price: number | null
    payment_method: number | null
    transfers: number | null
    transfer_duration: number | null
  }

  export type FareAttributeMinAggregateOutputType = {
    id: string | null
    fare_id: string | null
    price: number | null
    currency_type: string | null
    payment_method: number | null
    transfers: number | null
    agency_id: string | null
    transfer_duration: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FareAttributeMaxAggregateOutputType = {
    id: string | null
    fare_id: string | null
    price: number | null
    currency_type: string | null
    payment_method: number | null
    transfers: number | null
    agency_id: string | null
    transfer_duration: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FareAttributeCountAggregateOutputType = {
    id: number
    fare_id: number
    price: number
    currency_type: number
    payment_method: number
    transfers: number
    agency_id: number
    transfer_duration: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FareAttributeAvgAggregateInputType = {
    price?: true
    payment_method?: true
    transfers?: true
    transfer_duration?: true
  }

  export type FareAttributeSumAggregateInputType = {
    price?: true
    payment_method?: true
    transfers?: true
    transfer_duration?: true
  }

  export type FareAttributeMinAggregateInputType = {
    id?: true
    fare_id?: true
    price?: true
    currency_type?: true
    payment_method?: true
    transfers?: true
    agency_id?: true
    transfer_duration?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FareAttributeMaxAggregateInputType = {
    id?: true
    fare_id?: true
    price?: true
    currency_type?: true
    payment_method?: true
    transfers?: true
    agency_id?: true
    transfer_duration?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FareAttributeCountAggregateInputType = {
    id?: true
    fare_id?: true
    price?: true
    currency_type?: true
    payment_method?: true
    transfers?: true
    agency_id?: true
    transfer_duration?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FareAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FareAttribute to aggregate.
     */
    where?: FareAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareAttributes to fetch.
     */
    orderBy?: FareAttributeOrderByWithRelationInput | FareAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FareAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FareAttributes
    **/
    _count?: true | FareAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FareAttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FareAttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FareAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FareAttributeMaxAggregateInputType
  }

  export type GetFareAttributeAggregateType<T extends FareAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateFareAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFareAttribute[P]>
      : GetScalarType<T[P], AggregateFareAttribute[P]>
  }




  export type FareAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareAttributeWhereInput
    orderBy?: FareAttributeOrderByWithAggregationInput | FareAttributeOrderByWithAggregationInput[]
    by: FareAttributeScalarFieldEnum[] | FareAttributeScalarFieldEnum
    having?: FareAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FareAttributeCountAggregateInputType | true
    _avg?: FareAttributeAvgAggregateInputType
    _sum?: FareAttributeSumAggregateInputType
    _min?: FareAttributeMinAggregateInputType
    _max?: FareAttributeMaxAggregateInputType
  }

  export type FareAttributeGroupByOutputType = {
    id: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers: number | null
    agency_id: string | null
    transfer_duration: number | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: FareAttributeCountAggregateOutputType | null
    _avg: FareAttributeAvgAggregateOutputType | null
    _sum: FareAttributeSumAggregateOutputType | null
    _min: FareAttributeMinAggregateOutputType | null
    _max: FareAttributeMaxAggregateOutputType | null
  }

  type GetFareAttributeGroupByPayload<T extends FareAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FareAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FareAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FareAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], FareAttributeGroupByOutputType[P]>
        }
      >
    >


  export type FareAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fare_id?: boolean
    price?: boolean
    currency_type?: boolean
    payment_method?: boolean
    transfers?: boolean
    agency_id?: boolean
    transfer_duration?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | FareAttribute$agencyArgs<ExtArgs>
    fareRules?: boolean | FareAttribute$fareRulesArgs<ExtArgs>
    _count?: boolean | FareAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fareAttribute"]>

  export type FareAttributeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fare_id?: boolean
    price?: boolean
    currency_type?: boolean
    payment_method?: boolean
    transfers?: boolean
    agency_id?: boolean
    transfer_duration?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | FareAttribute$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["fareAttribute"]>

  export type FareAttributeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fare_id?: boolean
    price?: boolean
    currency_type?: boolean
    payment_method?: boolean
    transfers?: boolean
    agency_id?: boolean
    transfer_duration?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | FareAttribute$agencyArgs<ExtArgs>
  }, ExtArgs["result"]["fareAttribute"]>

  export type FareAttributeSelectScalar = {
    id?: boolean
    fare_id?: boolean
    price?: boolean
    currency_type?: boolean
    payment_method?: boolean
    transfers?: boolean
    agency_id?: boolean
    transfer_duration?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FareAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fare_id" | "price" | "currency_type" | "payment_method" | "transfers" | "agency_id" | "transfer_duration" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["fareAttribute"]>
  export type FareAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | FareAttribute$agencyArgs<ExtArgs>
    fareRules?: boolean | FareAttribute$fareRulesArgs<ExtArgs>
    _count?: boolean | FareAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FareAttributeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | FareAttribute$agencyArgs<ExtArgs>
  }
  export type FareAttributeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    agency?: boolean | FareAttribute$agencyArgs<ExtArgs>
  }

  export type $FareAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FareAttribute"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      agency: Prisma.$AgencyPayload<ExtArgs> | null
      fareRules: Prisma.$FareRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fare_id: string
      price: number
      currency_type: string
      payment_method: number
      transfers: number | null
      agency_id: string | null
      transfer_duration: number | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["fareAttribute"]>
    composites: {}
  }

  type FareAttributeGetPayload<S extends boolean | null | undefined | FareAttributeDefaultArgs> = $Result.GetResult<Prisma.$FareAttributePayload, S>

  type FareAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FareAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FareAttributeCountAggregateInputType | true
    }

  export interface FareAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FareAttribute'], meta: { name: 'FareAttribute' } }
    /**
     * Find zero or one FareAttribute that matches the filter.
     * @param {FareAttributeFindUniqueArgs} args - Arguments to find a FareAttribute
     * @example
     * // Get one FareAttribute
     * const fareAttribute = await prisma.fareAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FareAttributeFindUniqueArgs>(args: SelectSubset<T, FareAttributeFindUniqueArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FareAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FareAttributeFindUniqueOrThrowArgs} args - Arguments to find a FareAttribute
     * @example
     * // Get one FareAttribute
     * const fareAttribute = await prisma.fareAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FareAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, FareAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FareAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeFindFirstArgs} args - Arguments to find a FareAttribute
     * @example
     * // Get one FareAttribute
     * const fareAttribute = await prisma.fareAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FareAttributeFindFirstArgs>(args?: SelectSubset<T, FareAttributeFindFirstArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FareAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeFindFirstOrThrowArgs} args - Arguments to find a FareAttribute
     * @example
     * // Get one FareAttribute
     * const fareAttribute = await prisma.fareAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FareAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, FareAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FareAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FareAttributes
     * const fareAttributes = await prisma.fareAttribute.findMany()
     * 
     * // Get first 10 FareAttributes
     * const fareAttributes = await prisma.fareAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fareAttributeWithIdOnly = await prisma.fareAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FareAttributeFindManyArgs>(args?: SelectSubset<T, FareAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FareAttribute.
     * @param {FareAttributeCreateArgs} args - Arguments to create a FareAttribute.
     * @example
     * // Create one FareAttribute
     * const FareAttribute = await prisma.fareAttribute.create({
     *   data: {
     *     // ... data to create a FareAttribute
     *   }
     * })
     * 
     */
    create<T extends FareAttributeCreateArgs>(args: SelectSubset<T, FareAttributeCreateArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FareAttributes.
     * @param {FareAttributeCreateManyArgs} args - Arguments to create many FareAttributes.
     * @example
     * // Create many FareAttributes
     * const fareAttribute = await prisma.fareAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FareAttributeCreateManyArgs>(args?: SelectSubset<T, FareAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FareAttributes and returns the data saved in the database.
     * @param {FareAttributeCreateManyAndReturnArgs} args - Arguments to create many FareAttributes.
     * @example
     * // Create many FareAttributes
     * const fareAttribute = await prisma.fareAttribute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FareAttributes and only return the `id`
     * const fareAttributeWithIdOnly = await prisma.fareAttribute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FareAttributeCreateManyAndReturnArgs>(args?: SelectSubset<T, FareAttributeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FareAttribute.
     * @param {FareAttributeDeleteArgs} args - Arguments to delete one FareAttribute.
     * @example
     * // Delete one FareAttribute
     * const FareAttribute = await prisma.fareAttribute.delete({
     *   where: {
     *     // ... filter to delete one FareAttribute
     *   }
     * })
     * 
     */
    delete<T extends FareAttributeDeleteArgs>(args: SelectSubset<T, FareAttributeDeleteArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FareAttribute.
     * @param {FareAttributeUpdateArgs} args - Arguments to update one FareAttribute.
     * @example
     * // Update one FareAttribute
     * const fareAttribute = await prisma.fareAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FareAttributeUpdateArgs>(args: SelectSubset<T, FareAttributeUpdateArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FareAttributes.
     * @param {FareAttributeDeleteManyArgs} args - Arguments to filter FareAttributes to delete.
     * @example
     * // Delete a few FareAttributes
     * const { count } = await prisma.fareAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FareAttributeDeleteManyArgs>(args?: SelectSubset<T, FareAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FareAttributes
     * const fareAttribute = await prisma.fareAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FareAttributeUpdateManyArgs>(args: SelectSubset<T, FareAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareAttributes and returns the data updated in the database.
     * @param {FareAttributeUpdateManyAndReturnArgs} args - Arguments to update many FareAttributes.
     * @example
     * // Update many FareAttributes
     * const fareAttribute = await prisma.fareAttribute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FareAttributes and only return the `id`
     * const fareAttributeWithIdOnly = await prisma.fareAttribute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FareAttributeUpdateManyAndReturnArgs>(args: SelectSubset<T, FareAttributeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FareAttribute.
     * @param {FareAttributeUpsertArgs} args - Arguments to update or create a FareAttribute.
     * @example
     * // Update or create a FareAttribute
     * const fareAttribute = await prisma.fareAttribute.upsert({
     *   create: {
     *     // ... data to create a FareAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FareAttribute we want to update
     *   }
     * })
     */
    upsert<T extends FareAttributeUpsertArgs>(args: SelectSubset<T, FareAttributeUpsertArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FareAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeCountArgs} args - Arguments to filter FareAttributes to count.
     * @example
     * // Count the number of FareAttributes
     * const count = await prisma.fareAttribute.count({
     *   where: {
     *     // ... the filter for the FareAttributes we want to count
     *   }
     * })
    **/
    count<T extends FareAttributeCountArgs>(
      args?: Subset<T, FareAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FareAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FareAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FareAttributeAggregateArgs>(args: Subset<T, FareAttributeAggregateArgs>): Prisma.PrismaPromise<GetFareAttributeAggregateType<T>>

    /**
     * Group by FareAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FareAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FareAttributeGroupByArgs['orderBy'] }
        : { orderBy?: FareAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FareAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFareAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FareAttribute model
   */
  readonly fields: FareAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FareAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FareAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agency<T extends FareAttribute$agencyArgs<ExtArgs> = {}>(args?: Subset<T, FareAttribute$agencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fareRules<T extends FareAttribute$fareRulesArgs<ExtArgs> = {}>(args?: Subset<T, FareAttribute$fareRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FareAttribute model
   */
  interface FareAttributeFieldRefs {
    readonly id: FieldRef<"FareAttribute", 'String'>
    readonly fare_id: FieldRef<"FareAttribute", 'String'>
    readonly price: FieldRef<"FareAttribute", 'Float'>
    readonly currency_type: FieldRef<"FareAttribute", 'String'>
    readonly payment_method: FieldRef<"FareAttribute", 'Int'>
    readonly transfers: FieldRef<"FareAttribute", 'Int'>
    readonly agency_id: FieldRef<"FareAttribute", 'String'>
    readonly transfer_duration: FieldRef<"FareAttribute", 'Int'>
    readonly project_id: FieldRef<"FareAttribute", 'String'>
    readonly created_by: FieldRef<"FareAttribute", 'String'>
    readonly created_at: FieldRef<"FareAttribute", 'DateTime'>
    readonly updated_at: FieldRef<"FareAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FareAttribute findUnique
   */
  export type FareAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * Filter, which FareAttribute to fetch.
     */
    where: FareAttributeWhereUniqueInput
  }

  /**
   * FareAttribute findUniqueOrThrow
   */
  export type FareAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * Filter, which FareAttribute to fetch.
     */
    where: FareAttributeWhereUniqueInput
  }

  /**
   * FareAttribute findFirst
   */
  export type FareAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * Filter, which FareAttribute to fetch.
     */
    where?: FareAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareAttributes to fetch.
     */
    orderBy?: FareAttributeOrderByWithRelationInput | FareAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FareAttributes.
     */
    cursor?: FareAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FareAttributes.
     */
    distinct?: FareAttributeScalarFieldEnum | FareAttributeScalarFieldEnum[]
  }

  /**
   * FareAttribute findFirstOrThrow
   */
  export type FareAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * Filter, which FareAttribute to fetch.
     */
    where?: FareAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareAttributes to fetch.
     */
    orderBy?: FareAttributeOrderByWithRelationInput | FareAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FareAttributes.
     */
    cursor?: FareAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FareAttributes.
     */
    distinct?: FareAttributeScalarFieldEnum | FareAttributeScalarFieldEnum[]
  }

  /**
   * FareAttribute findMany
   */
  export type FareAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * Filter, which FareAttributes to fetch.
     */
    where?: FareAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareAttributes to fetch.
     */
    orderBy?: FareAttributeOrderByWithRelationInput | FareAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FareAttributes.
     */
    cursor?: FareAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareAttributes.
     */
    skip?: number
    distinct?: FareAttributeScalarFieldEnum | FareAttributeScalarFieldEnum[]
  }

  /**
   * FareAttribute create
   */
  export type FareAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a FareAttribute.
     */
    data: XOR<FareAttributeCreateInput, FareAttributeUncheckedCreateInput>
  }

  /**
   * FareAttribute createMany
   */
  export type FareAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FareAttributes.
     */
    data: FareAttributeCreateManyInput | FareAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FareAttribute createManyAndReturn
   */
  export type FareAttributeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * The data used to create many FareAttributes.
     */
    data: FareAttributeCreateManyInput | FareAttributeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FareAttribute update
   */
  export type FareAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a FareAttribute.
     */
    data: XOR<FareAttributeUpdateInput, FareAttributeUncheckedUpdateInput>
    /**
     * Choose, which FareAttribute to update.
     */
    where: FareAttributeWhereUniqueInput
  }

  /**
   * FareAttribute updateMany
   */
  export type FareAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FareAttributes.
     */
    data: XOR<FareAttributeUpdateManyMutationInput, FareAttributeUncheckedUpdateManyInput>
    /**
     * Filter which FareAttributes to update
     */
    where?: FareAttributeWhereInput
    /**
     * Limit how many FareAttributes to update.
     */
    limit?: number
  }

  /**
   * FareAttribute updateManyAndReturn
   */
  export type FareAttributeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * The data used to update FareAttributes.
     */
    data: XOR<FareAttributeUpdateManyMutationInput, FareAttributeUncheckedUpdateManyInput>
    /**
     * Filter which FareAttributes to update
     */
    where?: FareAttributeWhereInput
    /**
     * Limit how many FareAttributes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FareAttribute upsert
   */
  export type FareAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the FareAttribute to update in case it exists.
     */
    where: FareAttributeWhereUniqueInput
    /**
     * In case the FareAttribute found by the `where` argument doesn't exist, create a new FareAttribute with this data.
     */
    create: XOR<FareAttributeCreateInput, FareAttributeUncheckedCreateInput>
    /**
     * In case the FareAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FareAttributeUpdateInput, FareAttributeUncheckedUpdateInput>
  }

  /**
   * FareAttribute delete
   */
  export type FareAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
    /**
     * Filter which FareAttribute to delete.
     */
    where: FareAttributeWhereUniqueInput
  }

  /**
   * FareAttribute deleteMany
   */
  export type FareAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FareAttributes to delete
     */
    where?: FareAttributeWhereInput
    /**
     * Limit how many FareAttributes to delete.
     */
    limit?: number
  }

  /**
   * FareAttribute.agency
   */
  export type FareAttribute$agencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * FareAttribute.fareRules
   */
  export type FareAttribute$fareRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    where?: FareRuleWhereInput
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    cursor?: FareRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FareRuleScalarFieldEnum | FareRuleScalarFieldEnum[]
  }

  /**
   * FareAttribute without action
   */
  export type FareAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareAttribute
     */
    select?: FareAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareAttribute
     */
    omit?: FareAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareAttributeInclude<ExtArgs> | null
  }


  /**
   * Model FareRule
   */

  export type AggregateFareRule = {
    _count: FareRuleCountAggregateOutputType | null
    _min: FareRuleMinAggregateOutputType | null
    _max: FareRuleMaxAggregateOutputType | null
  }

  export type FareRuleMinAggregateOutputType = {
    id: string | null
    fare_id: string | null
    route_id: string | null
    origin_id: string | null
    destination_id: string | null
    contains_id: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FareRuleMaxAggregateOutputType = {
    id: string | null
    fare_id: string | null
    route_id: string | null
    origin_id: string | null
    destination_id: string | null
    contains_id: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FareRuleCountAggregateOutputType = {
    id: number
    fare_id: number
    route_id: number
    origin_id: number
    destination_id: number
    contains_id: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FareRuleMinAggregateInputType = {
    id?: true
    fare_id?: true
    route_id?: true
    origin_id?: true
    destination_id?: true
    contains_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FareRuleMaxAggregateInputType = {
    id?: true
    fare_id?: true
    route_id?: true
    origin_id?: true
    destination_id?: true
    contains_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FareRuleCountAggregateInputType = {
    id?: true
    fare_id?: true
    route_id?: true
    origin_id?: true
    destination_id?: true
    contains_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FareRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FareRule to aggregate.
     */
    where?: FareRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareRules to fetch.
     */
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FareRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FareRules
    **/
    _count?: true | FareRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FareRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FareRuleMaxAggregateInputType
  }

  export type GetFareRuleAggregateType<T extends FareRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateFareRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFareRule[P]>
      : GetScalarType<T[P], AggregateFareRule[P]>
  }




  export type FareRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FareRuleWhereInput
    orderBy?: FareRuleOrderByWithAggregationInput | FareRuleOrderByWithAggregationInput[]
    by: FareRuleScalarFieldEnum[] | FareRuleScalarFieldEnum
    having?: FareRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FareRuleCountAggregateInputType | true
    _min?: FareRuleMinAggregateInputType
    _max?: FareRuleMaxAggregateInputType
  }

  export type FareRuleGroupByOutputType = {
    id: string
    fare_id: string
    route_id: string | null
    origin_id: string | null
    destination_id: string | null
    contains_id: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: FareRuleCountAggregateOutputType | null
    _min: FareRuleMinAggregateOutputType | null
    _max: FareRuleMaxAggregateOutputType | null
  }

  type GetFareRuleGroupByPayload<T extends FareRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FareRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FareRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FareRuleGroupByOutputType[P]>
            : GetScalarType<T[P], FareRuleGroupByOutputType[P]>
        }
      >
    >


  export type FareRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fare_id?: boolean
    route_id?: boolean
    origin_id?: boolean
    destination_id?: boolean
    contains_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fare_attribute?: boolean | FareAttributeDefaultArgs<ExtArgs>
    route?: boolean | FareRule$routeArgs<ExtArgs>
  }, ExtArgs["result"]["fareRule"]>

  export type FareRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fare_id?: boolean
    route_id?: boolean
    origin_id?: boolean
    destination_id?: boolean
    contains_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fare_attribute?: boolean | FareAttributeDefaultArgs<ExtArgs>
    route?: boolean | FareRule$routeArgs<ExtArgs>
  }, ExtArgs["result"]["fareRule"]>

  export type FareRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fare_id?: boolean
    route_id?: boolean
    origin_id?: boolean
    destination_id?: boolean
    contains_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fare_attribute?: boolean | FareAttributeDefaultArgs<ExtArgs>
    route?: boolean | FareRule$routeArgs<ExtArgs>
  }, ExtArgs["result"]["fareRule"]>

  export type FareRuleSelectScalar = {
    id?: boolean
    fare_id?: boolean
    route_id?: boolean
    origin_id?: boolean
    destination_id?: boolean
    contains_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FareRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fare_id" | "route_id" | "origin_id" | "destination_id" | "contains_id" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["fareRule"]>
  export type FareRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fare_attribute?: boolean | FareAttributeDefaultArgs<ExtArgs>
    route?: boolean | FareRule$routeArgs<ExtArgs>
  }
  export type FareRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fare_attribute?: boolean | FareAttributeDefaultArgs<ExtArgs>
    route?: boolean | FareRule$routeArgs<ExtArgs>
  }
  export type FareRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fare_attribute?: boolean | FareAttributeDefaultArgs<ExtArgs>
    route?: boolean | FareRule$routeArgs<ExtArgs>
  }

  export type $FareRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FareRule"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      fare_attribute: Prisma.$FareAttributePayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fare_id: string
      route_id: string | null
      origin_id: string | null
      destination_id: string | null
      contains_id: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["fareRule"]>
    composites: {}
  }

  type FareRuleGetPayload<S extends boolean | null | undefined | FareRuleDefaultArgs> = $Result.GetResult<Prisma.$FareRulePayload, S>

  type FareRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FareRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FareRuleCountAggregateInputType | true
    }

  export interface FareRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FareRule'], meta: { name: 'FareRule' } }
    /**
     * Find zero or one FareRule that matches the filter.
     * @param {FareRuleFindUniqueArgs} args - Arguments to find a FareRule
     * @example
     * // Get one FareRule
     * const fareRule = await prisma.fareRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FareRuleFindUniqueArgs>(args: SelectSubset<T, FareRuleFindUniqueArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FareRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FareRuleFindUniqueOrThrowArgs} args - Arguments to find a FareRule
     * @example
     * // Get one FareRule
     * const fareRule = await prisma.fareRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FareRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, FareRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FareRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleFindFirstArgs} args - Arguments to find a FareRule
     * @example
     * // Get one FareRule
     * const fareRule = await prisma.fareRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FareRuleFindFirstArgs>(args?: SelectSubset<T, FareRuleFindFirstArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FareRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleFindFirstOrThrowArgs} args - Arguments to find a FareRule
     * @example
     * // Get one FareRule
     * const fareRule = await prisma.fareRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FareRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, FareRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FareRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FareRules
     * const fareRules = await prisma.fareRule.findMany()
     * 
     * // Get first 10 FareRules
     * const fareRules = await prisma.fareRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fareRuleWithIdOnly = await prisma.fareRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FareRuleFindManyArgs>(args?: SelectSubset<T, FareRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FareRule.
     * @param {FareRuleCreateArgs} args - Arguments to create a FareRule.
     * @example
     * // Create one FareRule
     * const FareRule = await prisma.fareRule.create({
     *   data: {
     *     // ... data to create a FareRule
     *   }
     * })
     * 
     */
    create<T extends FareRuleCreateArgs>(args: SelectSubset<T, FareRuleCreateArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FareRules.
     * @param {FareRuleCreateManyArgs} args - Arguments to create many FareRules.
     * @example
     * // Create many FareRules
     * const fareRule = await prisma.fareRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FareRuleCreateManyArgs>(args?: SelectSubset<T, FareRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FareRules and returns the data saved in the database.
     * @param {FareRuleCreateManyAndReturnArgs} args - Arguments to create many FareRules.
     * @example
     * // Create many FareRules
     * const fareRule = await prisma.fareRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FareRules and only return the `id`
     * const fareRuleWithIdOnly = await prisma.fareRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FareRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, FareRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FareRule.
     * @param {FareRuleDeleteArgs} args - Arguments to delete one FareRule.
     * @example
     * // Delete one FareRule
     * const FareRule = await prisma.fareRule.delete({
     *   where: {
     *     // ... filter to delete one FareRule
     *   }
     * })
     * 
     */
    delete<T extends FareRuleDeleteArgs>(args: SelectSubset<T, FareRuleDeleteArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FareRule.
     * @param {FareRuleUpdateArgs} args - Arguments to update one FareRule.
     * @example
     * // Update one FareRule
     * const fareRule = await prisma.fareRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FareRuleUpdateArgs>(args: SelectSubset<T, FareRuleUpdateArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FareRules.
     * @param {FareRuleDeleteManyArgs} args - Arguments to filter FareRules to delete.
     * @example
     * // Delete a few FareRules
     * const { count } = await prisma.fareRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FareRuleDeleteManyArgs>(args?: SelectSubset<T, FareRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FareRules
     * const fareRule = await prisma.fareRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FareRuleUpdateManyArgs>(args: SelectSubset<T, FareRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FareRules and returns the data updated in the database.
     * @param {FareRuleUpdateManyAndReturnArgs} args - Arguments to update many FareRules.
     * @example
     * // Update many FareRules
     * const fareRule = await prisma.fareRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FareRules and only return the `id`
     * const fareRuleWithIdOnly = await prisma.fareRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FareRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, FareRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FareRule.
     * @param {FareRuleUpsertArgs} args - Arguments to update or create a FareRule.
     * @example
     * // Update or create a FareRule
     * const fareRule = await prisma.fareRule.upsert({
     *   create: {
     *     // ... data to create a FareRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FareRule we want to update
     *   }
     * })
     */
    upsert<T extends FareRuleUpsertArgs>(args: SelectSubset<T, FareRuleUpsertArgs<ExtArgs>>): Prisma__FareRuleClient<$Result.GetResult<Prisma.$FareRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FareRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleCountArgs} args - Arguments to filter FareRules to count.
     * @example
     * // Count the number of FareRules
     * const count = await prisma.fareRule.count({
     *   where: {
     *     // ... the filter for the FareRules we want to count
     *   }
     * })
    **/
    count<T extends FareRuleCountArgs>(
      args?: Subset<T, FareRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FareRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FareRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FareRuleAggregateArgs>(args: Subset<T, FareRuleAggregateArgs>): Prisma.PrismaPromise<GetFareRuleAggregateType<T>>

    /**
     * Group by FareRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FareRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FareRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FareRuleGroupByArgs['orderBy'] }
        : { orderBy?: FareRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FareRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFareRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FareRule model
   */
  readonly fields: FareRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FareRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FareRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fare_attribute<T extends FareAttributeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FareAttributeDefaultArgs<ExtArgs>>): Prisma__FareAttributeClient<$Result.GetResult<Prisma.$FareAttributePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends FareRule$routeArgs<ExtArgs> = {}>(args?: Subset<T, FareRule$routeArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FareRule model
   */
  interface FareRuleFieldRefs {
    readonly id: FieldRef<"FareRule", 'String'>
    readonly fare_id: FieldRef<"FareRule", 'String'>
    readonly route_id: FieldRef<"FareRule", 'String'>
    readonly origin_id: FieldRef<"FareRule", 'String'>
    readonly destination_id: FieldRef<"FareRule", 'String'>
    readonly contains_id: FieldRef<"FareRule", 'String'>
    readonly project_id: FieldRef<"FareRule", 'String'>
    readonly created_by: FieldRef<"FareRule", 'String'>
    readonly created_at: FieldRef<"FareRule", 'DateTime'>
    readonly updated_at: FieldRef<"FareRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FareRule findUnique
   */
  export type FareRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * Filter, which FareRule to fetch.
     */
    where: FareRuleWhereUniqueInput
  }

  /**
   * FareRule findUniqueOrThrow
   */
  export type FareRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * Filter, which FareRule to fetch.
     */
    where: FareRuleWhereUniqueInput
  }

  /**
   * FareRule findFirst
   */
  export type FareRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * Filter, which FareRule to fetch.
     */
    where?: FareRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareRules to fetch.
     */
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FareRules.
     */
    cursor?: FareRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FareRules.
     */
    distinct?: FareRuleScalarFieldEnum | FareRuleScalarFieldEnum[]
  }

  /**
   * FareRule findFirstOrThrow
   */
  export type FareRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * Filter, which FareRule to fetch.
     */
    where?: FareRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareRules to fetch.
     */
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FareRules.
     */
    cursor?: FareRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FareRules.
     */
    distinct?: FareRuleScalarFieldEnum | FareRuleScalarFieldEnum[]
  }

  /**
   * FareRule findMany
   */
  export type FareRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * Filter, which FareRules to fetch.
     */
    where?: FareRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FareRules to fetch.
     */
    orderBy?: FareRuleOrderByWithRelationInput | FareRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FareRules.
     */
    cursor?: FareRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FareRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FareRules.
     */
    skip?: number
    distinct?: FareRuleScalarFieldEnum | FareRuleScalarFieldEnum[]
  }

  /**
   * FareRule create
   */
  export type FareRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a FareRule.
     */
    data: XOR<FareRuleCreateInput, FareRuleUncheckedCreateInput>
  }

  /**
   * FareRule createMany
   */
  export type FareRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FareRules.
     */
    data: FareRuleCreateManyInput | FareRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FareRule createManyAndReturn
   */
  export type FareRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * The data used to create many FareRules.
     */
    data: FareRuleCreateManyInput | FareRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FareRule update
   */
  export type FareRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a FareRule.
     */
    data: XOR<FareRuleUpdateInput, FareRuleUncheckedUpdateInput>
    /**
     * Choose, which FareRule to update.
     */
    where: FareRuleWhereUniqueInput
  }

  /**
   * FareRule updateMany
   */
  export type FareRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FareRules.
     */
    data: XOR<FareRuleUpdateManyMutationInput, FareRuleUncheckedUpdateManyInput>
    /**
     * Filter which FareRules to update
     */
    where?: FareRuleWhereInput
    /**
     * Limit how many FareRules to update.
     */
    limit?: number
  }

  /**
   * FareRule updateManyAndReturn
   */
  export type FareRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * The data used to update FareRules.
     */
    data: XOR<FareRuleUpdateManyMutationInput, FareRuleUncheckedUpdateManyInput>
    /**
     * Filter which FareRules to update
     */
    where?: FareRuleWhereInput
    /**
     * Limit how many FareRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FareRule upsert
   */
  export type FareRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the FareRule to update in case it exists.
     */
    where: FareRuleWhereUniqueInput
    /**
     * In case the FareRule found by the `where` argument doesn't exist, create a new FareRule with this data.
     */
    create: XOR<FareRuleCreateInput, FareRuleUncheckedCreateInput>
    /**
     * In case the FareRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FareRuleUpdateInput, FareRuleUncheckedUpdateInput>
  }

  /**
   * FareRule delete
   */
  export type FareRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
    /**
     * Filter which FareRule to delete.
     */
    where: FareRuleWhereUniqueInput
  }

  /**
   * FareRule deleteMany
   */
  export type FareRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FareRules to delete
     */
    where?: FareRuleWhereInput
    /**
     * Limit how many FareRules to delete.
     */
    limit?: number
  }

  /**
   * FareRule.route
   */
  export type FareRule$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    where?: RouteWhereInput
  }

  /**
   * FareRule without action
   */
  export type FareRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FareRule
     */
    select?: FareRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FareRule
     */
    omit?: FareRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FareRuleInclude<ExtArgs> | null
  }


  /**
   * Model Shape
   */

  export type AggregateShape = {
    _count: ShapeCountAggregateOutputType | null
    _avg: ShapeAvgAggregateOutputType | null
    _sum: ShapeSumAggregateOutputType | null
    _min: ShapeMinAggregateOutputType | null
    _max: ShapeMaxAggregateOutputType | null
  }

  export type ShapeAvgAggregateOutputType = {
    shape_pt_sequence: number | null
    shape_pt_lat: number | null
    shape_pt_lon: number | null
    shape_dist_traveled: number | null
  }

  export type ShapeSumAggregateOutputType = {
    shape_pt_sequence: number | null
    shape_pt_lat: number | null
    shape_pt_lon: number | null
    shape_dist_traveled: number | null
  }

  export type ShapeMinAggregateOutputType = {
    id: string | null
    shape_id: string | null
    shape_pt_sequence: number | null
    shape_pt_lat: number | null
    shape_pt_lon: number | null
    shape_dist_traveled: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ShapeMaxAggregateOutputType = {
    id: string | null
    shape_id: string | null
    shape_pt_sequence: number | null
    shape_pt_lat: number | null
    shape_pt_lon: number | null
    shape_dist_traveled: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ShapeCountAggregateOutputType = {
    id: number
    shape_id: number
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ShapeAvgAggregateInputType = {
    shape_pt_sequence?: true
    shape_pt_lat?: true
    shape_pt_lon?: true
    shape_dist_traveled?: true
  }

  export type ShapeSumAggregateInputType = {
    shape_pt_sequence?: true
    shape_pt_lat?: true
    shape_pt_lon?: true
    shape_dist_traveled?: true
  }

  export type ShapeMinAggregateInputType = {
    id?: true
    shape_id?: true
    shape_pt_sequence?: true
    shape_pt_lat?: true
    shape_pt_lon?: true
    shape_dist_traveled?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ShapeMaxAggregateInputType = {
    id?: true
    shape_id?: true
    shape_pt_sequence?: true
    shape_pt_lat?: true
    shape_pt_lon?: true
    shape_dist_traveled?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ShapeCountAggregateInputType = {
    id?: true
    shape_id?: true
    shape_pt_sequence?: true
    shape_pt_lat?: true
    shape_pt_lon?: true
    shape_dist_traveled?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ShapeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shape to aggregate.
     */
    where?: ShapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shapes to fetch.
     */
    orderBy?: ShapeOrderByWithRelationInput | ShapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shapes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shapes
    **/
    _count?: true | ShapeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShapeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShapeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShapeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShapeMaxAggregateInputType
  }

  export type GetShapeAggregateType<T extends ShapeAggregateArgs> = {
        [P in keyof T & keyof AggregateShape]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShape[P]>
      : GetScalarType<T[P], AggregateShape[P]>
  }




  export type ShapeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShapeWhereInput
    orderBy?: ShapeOrderByWithAggregationInput | ShapeOrderByWithAggregationInput[]
    by: ShapeScalarFieldEnum[] | ShapeScalarFieldEnum
    having?: ShapeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShapeCountAggregateInputType | true
    _avg?: ShapeAvgAggregateInputType
    _sum?: ShapeSumAggregateInputType
    _min?: ShapeMinAggregateInputType
    _max?: ShapeMaxAggregateInputType
  }

  export type ShapeGroupByOutputType = {
    id: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled: number | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: ShapeCountAggregateOutputType | null
    _avg: ShapeAvgAggregateOutputType | null
    _sum: ShapeSumAggregateOutputType | null
    _min: ShapeMinAggregateOutputType | null
    _max: ShapeMaxAggregateOutputType | null
  }

  type GetShapeGroupByPayload<T extends ShapeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShapeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShapeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShapeGroupByOutputType[P]>
            : GetScalarType<T[P], ShapeGroupByOutputType[P]>
        }
      >
    >


  export type ShapeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shape_id?: boolean
    shape_pt_sequence?: boolean
    shape_pt_lat?: boolean
    shape_pt_lon?: boolean
    shape_dist_traveled?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shape"]>

  export type ShapeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shape_id?: boolean
    shape_pt_sequence?: boolean
    shape_pt_lat?: boolean
    shape_pt_lon?: boolean
    shape_dist_traveled?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shape"]>

  export type ShapeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shape_id?: boolean
    shape_pt_sequence?: boolean
    shape_pt_lat?: boolean
    shape_pt_lon?: boolean
    shape_dist_traveled?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shape"]>

  export type ShapeSelectScalar = {
    id?: boolean
    shape_id?: boolean
    shape_pt_sequence?: boolean
    shape_pt_lat?: boolean
    shape_pt_lon?: boolean
    shape_dist_traveled?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ShapeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shape_id" | "shape_pt_sequence" | "shape_pt_lat" | "shape_pt_lon" | "shape_dist_traveled" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["shape"]>
  export type ShapeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type ShapeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type ShapeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }

  export type $ShapePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shape"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shape_id: string
      shape_pt_sequence: number
      shape_pt_lat: number
      shape_pt_lon: number
      shape_dist_traveled: number | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["shape"]>
    composites: {}
  }

  type ShapeGetPayload<S extends boolean | null | undefined | ShapeDefaultArgs> = $Result.GetResult<Prisma.$ShapePayload, S>

  type ShapeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShapeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShapeCountAggregateInputType | true
    }

  export interface ShapeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shape'], meta: { name: 'Shape' } }
    /**
     * Find zero or one Shape that matches the filter.
     * @param {ShapeFindUniqueArgs} args - Arguments to find a Shape
     * @example
     * // Get one Shape
     * const shape = await prisma.shape.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShapeFindUniqueArgs>(args: SelectSubset<T, ShapeFindUniqueArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shape that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShapeFindUniqueOrThrowArgs} args - Arguments to find a Shape
     * @example
     * // Get one Shape
     * const shape = await prisma.shape.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShapeFindUniqueOrThrowArgs>(args: SelectSubset<T, ShapeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shape that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeFindFirstArgs} args - Arguments to find a Shape
     * @example
     * // Get one Shape
     * const shape = await prisma.shape.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShapeFindFirstArgs>(args?: SelectSubset<T, ShapeFindFirstArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shape that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeFindFirstOrThrowArgs} args - Arguments to find a Shape
     * @example
     * // Get one Shape
     * const shape = await prisma.shape.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShapeFindFirstOrThrowArgs>(args?: SelectSubset<T, ShapeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shapes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shapes
     * const shapes = await prisma.shape.findMany()
     * 
     * // Get first 10 Shapes
     * const shapes = await prisma.shape.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shapeWithIdOnly = await prisma.shape.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShapeFindManyArgs>(args?: SelectSubset<T, ShapeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shape.
     * @param {ShapeCreateArgs} args - Arguments to create a Shape.
     * @example
     * // Create one Shape
     * const Shape = await prisma.shape.create({
     *   data: {
     *     // ... data to create a Shape
     *   }
     * })
     * 
     */
    create<T extends ShapeCreateArgs>(args: SelectSubset<T, ShapeCreateArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shapes.
     * @param {ShapeCreateManyArgs} args - Arguments to create many Shapes.
     * @example
     * // Create many Shapes
     * const shape = await prisma.shape.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShapeCreateManyArgs>(args?: SelectSubset<T, ShapeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shapes and returns the data saved in the database.
     * @param {ShapeCreateManyAndReturnArgs} args - Arguments to create many Shapes.
     * @example
     * // Create many Shapes
     * const shape = await prisma.shape.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shapes and only return the `id`
     * const shapeWithIdOnly = await prisma.shape.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShapeCreateManyAndReturnArgs>(args?: SelectSubset<T, ShapeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shape.
     * @param {ShapeDeleteArgs} args - Arguments to delete one Shape.
     * @example
     * // Delete one Shape
     * const Shape = await prisma.shape.delete({
     *   where: {
     *     // ... filter to delete one Shape
     *   }
     * })
     * 
     */
    delete<T extends ShapeDeleteArgs>(args: SelectSubset<T, ShapeDeleteArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shape.
     * @param {ShapeUpdateArgs} args - Arguments to update one Shape.
     * @example
     * // Update one Shape
     * const shape = await prisma.shape.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShapeUpdateArgs>(args: SelectSubset<T, ShapeUpdateArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shapes.
     * @param {ShapeDeleteManyArgs} args - Arguments to filter Shapes to delete.
     * @example
     * // Delete a few Shapes
     * const { count } = await prisma.shape.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShapeDeleteManyArgs>(args?: SelectSubset<T, ShapeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shapes
     * const shape = await prisma.shape.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShapeUpdateManyArgs>(args: SelectSubset<T, ShapeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shapes and returns the data updated in the database.
     * @param {ShapeUpdateManyAndReturnArgs} args - Arguments to update many Shapes.
     * @example
     * // Update many Shapes
     * const shape = await prisma.shape.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shapes and only return the `id`
     * const shapeWithIdOnly = await prisma.shape.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShapeUpdateManyAndReturnArgs>(args: SelectSubset<T, ShapeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shape.
     * @param {ShapeUpsertArgs} args - Arguments to update or create a Shape.
     * @example
     * // Update or create a Shape
     * const shape = await prisma.shape.upsert({
     *   create: {
     *     // ... data to create a Shape
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shape we want to update
     *   }
     * })
     */
    upsert<T extends ShapeUpsertArgs>(args: SelectSubset<T, ShapeUpsertArgs<ExtArgs>>): Prisma__ShapeClient<$Result.GetResult<Prisma.$ShapePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeCountArgs} args - Arguments to filter Shapes to count.
     * @example
     * // Count the number of Shapes
     * const count = await prisma.shape.count({
     *   where: {
     *     // ... the filter for the Shapes we want to count
     *   }
     * })
    **/
    count<T extends ShapeCountArgs>(
      args?: Subset<T, ShapeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShapeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShapeAggregateArgs>(args: Subset<T, ShapeAggregateArgs>): Prisma.PrismaPromise<GetShapeAggregateType<T>>

    /**
     * Group by Shape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShapeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShapeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShapeGroupByArgs['orderBy'] }
        : { orderBy?: ShapeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShapeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShapeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shape model
   */
  readonly fields: ShapeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shape.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShapeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shape model
   */
  interface ShapeFieldRefs {
    readonly id: FieldRef<"Shape", 'String'>
    readonly shape_id: FieldRef<"Shape", 'String'>
    readonly shape_pt_sequence: FieldRef<"Shape", 'Int'>
    readonly shape_pt_lat: FieldRef<"Shape", 'Float'>
    readonly shape_pt_lon: FieldRef<"Shape", 'Float'>
    readonly shape_dist_traveled: FieldRef<"Shape", 'Float'>
    readonly project_id: FieldRef<"Shape", 'String'>
    readonly created_by: FieldRef<"Shape", 'String'>
    readonly created_at: FieldRef<"Shape", 'DateTime'>
    readonly updated_at: FieldRef<"Shape", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shape findUnique
   */
  export type ShapeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * Filter, which Shape to fetch.
     */
    where: ShapeWhereUniqueInput
  }

  /**
   * Shape findUniqueOrThrow
   */
  export type ShapeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * Filter, which Shape to fetch.
     */
    where: ShapeWhereUniqueInput
  }

  /**
   * Shape findFirst
   */
  export type ShapeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * Filter, which Shape to fetch.
     */
    where?: ShapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shapes to fetch.
     */
    orderBy?: ShapeOrderByWithRelationInput | ShapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shapes.
     */
    cursor?: ShapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shapes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shapes.
     */
    distinct?: ShapeScalarFieldEnum | ShapeScalarFieldEnum[]
  }

  /**
   * Shape findFirstOrThrow
   */
  export type ShapeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * Filter, which Shape to fetch.
     */
    where?: ShapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shapes to fetch.
     */
    orderBy?: ShapeOrderByWithRelationInput | ShapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shapes.
     */
    cursor?: ShapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shapes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shapes.
     */
    distinct?: ShapeScalarFieldEnum | ShapeScalarFieldEnum[]
  }

  /**
   * Shape findMany
   */
  export type ShapeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * Filter, which Shapes to fetch.
     */
    where?: ShapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shapes to fetch.
     */
    orderBy?: ShapeOrderByWithRelationInput | ShapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shapes.
     */
    cursor?: ShapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shapes.
     */
    skip?: number
    distinct?: ShapeScalarFieldEnum | ShapeScalarFieldEnum[]
  }

  /**
   * Shape create
   */
  export type ShapeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * The data needed to create a Shape.
     */
    data: XOR<ShapeCreateInput, ShapeUncheckedCreateInput>
  }

  /**
   * Shape createMany
   */
  export type ShapeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shapes.
     */
    data: ShapeCreateManyInput | ShapeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shape createManyAndReturn
   */
  export type ShapeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * The data used to create many Shapes.
     */
    data: ShapeCreateManyInput | ShapeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shape update
   */
  export type ShapeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * The data needed to update a Shape.
     */
    data: XOR<ShapeUpdateInput, ShapeUncheckedUpdateInput>
    /**
     * Choose, which Shape to update.
     */
    where: ShapeWhereUniqueInput
  }

  /**
   * Shape updateMany
   */
  export type ShapeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shapes.
     */
    data: XOR<ShapeUpdateManyMutationInput, ShapeUncheckedUpdateManyInput>
    /**
     * Filter which Shapes to update
     */
    where?: ShapeWhereInput
    /**
     * Limit how many Shapes to update.
     */
    limit?: number
  }

  /**
   * Shape updateManyAndReturn
   */
  export type ShapeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * The data used to update Shapes.
     */
    data: XOR<ShapeUpdateManyMutationInput, ShapeUncheckedUpdateManyInput>
    /**
     * Filter which Shapes to update
     */
    where?: ShapeWhereInput
    /**
     * Limit how many Shapes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shape upsert
   */
  export type ShapeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * The filter to search for the Shape to update in case it exists.
     */
    where: ShapeWhereUniqueInput
    /**
     * In case the Shape found by the `where` argument doesn't exist, create a new Shape with this data.
     */
    create: XOR<ShapeCreateInput, ShapeUncheckedCreateInput>
    /**
     * In case the Shape was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShapeUpdateInput, ShapeUncheckedUpdateInput>
  }

  /**
   * Shape delete
   */
  export type ShapeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
    /**
     * Filter which Shape to delete.
     */
    where: ShapeWhereUniqueInput
  }

  /**
   * Shape deleteMany
   */
  export type ShapeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shapes to delete
     */
    where?: ShapeWhereInput
    /**
     * Limit how many Shapes to delete.
     */
    limit?: number
  }

  /**
   * Shape without action
   */
  export type ShapeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shape
     */
    select?: ShapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shape
     */
    omit?: ShapeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShapeInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    transfer_type: number | null
    min_transfer_time: number | null
  }

  export type TransferSumAggregateOutputType = {
    transfer_type: number | null
    min_transfer_time: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    from_stop_id: string | null
    to_stop_id: string | null
    transfer_type: number | null
    min_transfer_time: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    from_stop_id: string | null
    to_stop_id: string | null
    transfer_type: number | null
    min_transfer_time: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    from_stop_id: number
    to_stop_id: number
    transfer_type: number
    min_transfer_time: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    transfer_type?: true
    min_transfer_time?: true
  }

  export type TransferSumAggregateInputType = {
    transfer_type?: true
    min_transfer_time?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    from_stop_id?: true
    to_stop_id?: true
    transfer_type?: true
    min_transfer_time?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    from_stop_id?: true
    to_stop_id?: true
    transfer_type?: true
    min_transfer_time?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    from_stop_id?: true
    to_stop_id?: true
    transfer_type?: true
    min_transfer_time?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    from_stop_id: string
    to_stop_id: string
    transfer_type: number
    min_transfer_time: number | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    transfer_type?: boolean
    min_transfer_time?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    transfer_type?: boolean
    min_transfer_time?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    transfer_type?: boolean
    min_transfer_time?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    transfer_type?: boolean
    min_transfer_time?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "from_stop_id" | "to_stop_id" | "transfer_type" | "min_transfer_time" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      fromStop: Prisma.$StopPayload<ExtArgs>
      toStop: Prisma.$StopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      from_stop_id: string
      to_stop_id: string
      transfer_type: number
      min_transfer_time: number | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromStop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toStop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly from_stop_id: FieldRef<"Transfer", 'String'>
    readonly to_stop_id: FieldRef<"Transfer", 'String'>
    readonly transfer_type: FieldRef<"Transfer", 'Int'>
    readonly min_transfer_time: FieldRef<"Transfer", 'Int'>
    readonly project_id: FieldRef<"Transfer", 'String'>
    readonly created_by: FieldRef<"Transfer", 'String'>
    readonly created_at: FieldRef<"Transfer", 'DateTime'>
    readonly updated_at: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model Frequency
   */

  export type AggregateFrequency = {
    _count: FrequencyCountAggregateOutputType | null
    _avg: FrequencyAvgAggregateOutputType | null
    _sum: FrequencySumAggregateOutputType | null
    _min: FrequencyMinAggregateOutputType | null
    _max: FrequencyMaxAggregateOutputType | null
  }

  export type FrequencyAvgAggregateOutputType = {
    headway_secs: number | null
    exact_times: number | null
  }

  export type FrequencySumAggregateOutputType = {
    headway_secs: number | null
    exact_times: number | null
  }

  export type FrequencyMinAggregateOutputType = {
    id: string | null
    trip_id: string | null
    start_time: string | null
    end_time: string | null
    headway_secs: number | null
    exact_times: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FrequencyMaxAggregateOutputType = {
    id: string | null
    trip_id: string | null
    start_time: string | null
    end_time: string | null
    headway_secs: number | null
    exact_times: number | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FrequencyCountAggregateOutputType = {
    id: number
    trip_id: number
    start_time: number
    end_time: number
    headway_secs: number
    exact_times: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FrequencyAvgAggregateInputType = {
    headway_secs?: true
    exact_times?: true
  }

  export type FrequencySumAggregateInputType = {
    headway_secs?: true
    exact_times?: true
  }

  export type FrequencyMinAggregateInputType = {
    id?: true
    trip_id?: true
    start_time?: true
    end_time?: true
    headway_secs?: true
    exact_times?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FrequencyMaxAggregateInputType = {
    id?: true
    trip_id?: true
    start_time?: true
    end_time?: true
    headway_secs?: true
    exact_times?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FrequencyCountAggregateInputType = {
    id?: true
    trip_id?: true
    start_time?: true
    end_time?: true
    headway_secs?: true
    exact_times?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FrequencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Frequency to aggregate.
     */
    where?: FrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frequencies to fetch.
     */
    orderBy?: FrequencyOrderByWithRelationInput | FrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frequencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Frequencies
    **/
    _count?: true | FrequencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FrequencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FrequencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FrequencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FrequencyMaxAggregateInputType
  }

  export type GetFrequencyAggregateType<T extends FrequencyAggregateArgs> = {
        [P in keyof T & keyof AggregateFrequency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFrequency[P]>
      : GetScalarType<T[P], AggregateFrequency[P]>
  }




  export type FrequencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FrequencyWhereInput
    orderBy?: FrequencyOrderByWithAggregationInput | FrequencyOrderByWithAggregationInput[]
    by: FrequencyScalarFieldEnum[] | FrequencyScalarFieldEnum
    having?: FrequencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FrequencyCountAggregateInputType | true
    _avg?: FrequencyAvgAggregateInputType
    _sum?: FrequencySumAggregateInputType
    _min?: FrequencyMinAggregateInputType
    _max?: FrequencyMaxAggregateInputType
  }

  export type FrequencyGroupByOutputType = {
    id: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times: number | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: FrequencyCountAggregateOutputType | null
    _avg: FrequencyAvgAggregateOutputType | null
    _sum: FrequencySumAggregateOutputType | null
    _min: FrequencyMinAggregateOutputType | null
    _max: FrequencyMaxAggregateOutputType | null
  }

  type GetFrequencyGroupByPayload<T extends FrequencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FrequencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FrequencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FrequencyGroupByOutputType[P]>
            : GetScalarType<T[P], FrequencyGroupByOutputType[P]>
        }
      >
    >


  export type FrequencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    start_time?: boolean
    end_time?: boolean
    headway_secs?: boolean
    exact_times?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frequency"]>

  export type FrequencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    start_time?: boolean
    end_time?: boolean
    headway_secs?: boolean
    exact_times?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frequency"]>

  export type FrequencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trip_id?: boolean
    start_time?: boolean
    end_time?: boolean
    headway_secs?: boolean
    exact_times?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frequency"]>

  export type FrequencySelectScalar = {
    id?: boolean
    trip_id?: boolean
    start_time?: boolean
    end_time?: boolean
    headway_secs?: boolean
    exact_times?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FrequencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trip_id" | "start_time" | "end_time" | "headway_secs" | "exact_times" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["frequency"]>
  export type FrequencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type FrequencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type FrequencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }

  export type $FrequencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Frequency"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trip_id: string
      start_time: string
      end_time: string
      headway_secs: number
      exact_times: number | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["frequency"]>
    composites: {}
  }

  type FrequencyGetPayload<S extends boolean | null | undefined | FrequencyDefaultArgs> = $Result.GetResult<Prisma.$FrequencyPayload, S>

  type FrequencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FrequencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FrequencyCountAggregateInputType | true
    }

  export interface FrequencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Frequency'], meta: { name: 'Frequency' } }
    /**
     * Find zero or one Frequency that matches the filter.
     * @param {FrequencyFindUniqueArgs} args - Arguments to find a Frequency
     * @example
     * // Get one Frequency
     * const frequency = await prisma.frequency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FrequencyFindUniqueArgs>(args: SelectSubset<T, FrequencyFindUniqueArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Frequency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FrequencyFindUniqueOrThrowArgs} args - Arguments to find a Frequency
     * @example
     * // Get one Frequency
     * const frequency = await prisma.frequency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FrequencyFindUniqueOrThrowArgs>(args: SelectSubset<T, FrequencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Frequency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyFindFirstArgs} args - Arguments to find a Frequency
     * @example
     * // Get one Frequency
     * const frequency = await prisma.frequency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FrequencyFindFirstArgs>(args?: SelectSubset<T, FrequencyFindFirstArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Frequency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyFindFirstOrThrowArgs} args - Arguments to find a Frequency
     * @example
     * // Get one Frequency
     * const frequency = await prisma.frequency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FrequencyFindFirstOrThrowArgs>(args?: SelectSubset<T, FrequencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Frequencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Frequencies
     * const frequencies = await prisma.frequency.findMany()
     * 
     * // Get first 10 Frequencies
     * const frequencies = await prisma.frequency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const frequencyWithIdOnly = await prisma.frequency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FrequencyFindManyArgs>(args?: SelectSubset<T, FrequencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Frequency.
     * @param {FrequencyCreateArgs} args - Arguments to create a Frequency.
     * @example
     * // Create one Frequency
     * const Frequency = await prisma.frequency.create({
     *   data: {
     *     // ... data to create a Frequency
     *   }
     * })
     * 
     */
    create<T extends FrequencyCreateArgs>(args: SelectSubset<T, FrequencyCreateArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Frequencies.
     * @param {FrequencyCreateManyArgs} args - Arguments to create many Frequencies.
     * @example
     * // Create many Frequencies
     * const frequency = await prisma.frequency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FrequencyCreateManyArgs>(args?: SelectSubset<T, FrequencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Frequencies and returns the data saved in the database.
     * @param {FrequencyCreateManyAndReturnArgs} args - Arguments to create many Frequencies.
     * @example
     * // Create many Frequencies
     * const frequency = await prisma.frequency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Frequencies and only return the `id`
     * const frequencyWithIdOnly = await prisma.frequency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FrequencyCreateManyAndReturnArgs>(args?: SelectSubset<T, FrequencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Frequency.
     * @param {FrequencyDeleteArgs} args - Arguments to delete one Frequency.
     * @example
     * // Delete one Frequency
     * const Frequency = await prisma.frequency.delete({
     *   where: {
     *     // ... filter to delete one Frequency
     *   }
     * })
     * 
     */
    delete<T extends FrequencyDeleteArgs>(args: SelectSubset<T, FrequencyDeleteArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Frequency.
     * @param {FrequencyUpdateArgs} args - Arguments to update one Frequency.
     * @example
     * // Update one Frequency
     * const frequency = await prisma.frequency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FrequencyUpdateArgs>(args: SelectSubset<T, FrequencyUpdateArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Frequencies.
     * @param {FrequencyDeleteManyArgs} args - Arguments to filter Frequencies to delete.
     * @example
     * // Delete a few Frequencies
     * const { count } = await prisma.frequency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FrequencyDeleteManyArgs>(args?: SelectSubset<T, FrequencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frequencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Frequencies
     * const frequency = await prisma.frequency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FrequencyUpdateManyArgs>(args: SelectSubset<T, FrequencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frequencies and returns the data updated in the database.
     * @param {FrequencyUpdateManyAndReturnArgs} args - Arguments to update many Frequencies.
     * @example
     * // Update many Frequencies
     * const frequency = await prisma.frequency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Frequencies and only return the `id`
     * const frequencyWithIdOnly = await prisma.frequency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FrequencyUpdateManyAndReturnArgs>(args: SelectSubset<T, FrequencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Frequency.
     * @param {FrequencyUpsertArgs} args - Arguments to update or create a Frequency.
     * @example
     * // Update or create a Frequency
     * const frequency = await prisma.frequency.upsert({
     *   create: {
     *     // ... data to create a Frequency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Frequency we want to update
     *   }
     * })
     */
    upsert<T extends FrequencyUpsertArgs>(args: SelectSubset<T, FrequencyUpsertArgs<ExtArgs>>): Prisma__FrequencyClient<$Result.GetResult<Prisma.$FrequencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Frequencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyCountArgs} args - Arguments to filter Frequencies to count.
     * @example
     * // Count the number of Frequencies
     * const count = await prisma.frequency.count({
     *   where: {
     *     // ... the filter for the Frequencies we want to count
     *   }
     * })
    **/
    count<T extends FrequencyCountArgs>(
      args?: Subset<T, FrequencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FrequencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Frequency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FrequencyAggregateArgs>(args: Subset<T, FrequencyAggregateArgs>): Prisma.PrismaPromise<GetFrequencyAggregateType<T>>

    /**
     * Group by Frequency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrequencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FrequencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FrequencyGroupByArgs['orderBy'] }
        : { orderBy?: FrequencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FrequencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFrequencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Frequency model
   */
  readonly fields: FrequencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Frequency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FrequencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Frequency model
   */
  interface FrequencyFieldRefs {
    readonly id: FieldRef<"Frequency", 'String'>
    readonly trip_id: FieldRef<"Frequency", 'String'>
    readonly start_time: FieldRef<"Frequency", 'String'>
    readonly end_time: FieldRef<"Frequency", 'String'>
    readonly headway_secs: FieldRef<"Frequency", 'Int'>
    readonly exact_times: FieldRef<"Frequency", 'Int'>
    readonly project_id: FieldRef<"Frequency", 'String'>
    readonly created_by: FieldRef<"Frequency", 'String'>
    readonly created_at: FieldRef<"Frequency", 'DateTime'>
    readonly updated_at: FieldRef<"Frequency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Frequency findUnique
   */
  export type FrequencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * Filter, which Frequency to fetch.
     */
    where: FrequencyWhereUniqueInput
  }

  /**
   * Frequency findUniqueOrThrow
   */
  export type FrequencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * Filter, which Frequency to fetch.
     */
    where: FrequencyWhereUniqueInput
  }

  /**
   * Frequency findFirst
   */
  export type FrequencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * Filter, which Frequency to fetch.
     */
    where?: FrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frequencies to fetch.
     */
    orderBy?: FrequencyOrderByWithRelationInput | FrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Frequencies.
     */
    cursor?: FrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frequencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Frequencies.
     */
    distinct?: FrequencyScalarFieldEnum | FrequencyScalarFieldEnum[]
  }

  /**
   * Frequency findFirstOrThrow
   */
  export type FrequencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * Filter, which Frequency to fetch.
     */
    where?: FrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frequencies to fetch.
     */
    orderBy?: FrequencyOrderByWithRelationInput | FrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Frequencies.
     */
    cursor?: FrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frequencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Frequencies.
     */
    distinct?: FrequencyScalarFieldEnum | FrequencyScalarFieldEnum[]
  }

  /**
   * Frequency findMany
   */
  export type FrequencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * Filter, which Frequencies to fetch.
     */
    where?: FrequencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frequencies to fetch.
     */
    orderBy?: FrequencyOrderByWithRelationInput | FrequencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Frequencies.
     */
    cursor?: FrequencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frequencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frequencies.
     */
    skip?: number
    distinct?: FrequencyScalarFieldEnum | FrequencyScalarFieldEnum[]
  }

  /**
   * Frequency create
   */
  export type FrequencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Frequency.
     */
    data: XOR<FrequencyCreateInput, FrequencyUncheckedCreateInput>
  }

  /**
   * Frequency createMany
   */
  export type FrequencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Frequencies.
     */
    data: FrequencyCreateManyInput | FrequencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Frequency createManyAndReturn
   */
  export type FrequencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * The data used to create many Frequencies.
     */
    data: FrequencyCreateManyInput | FrequencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Frequency update
   */
  export type FrequencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Frequency.
     */
    data: XOR<FrequencyUpdateInput, FrequencyUncheckedUpdateInput>
    /**
     * Choose, which Frequency to update.
     */
    where: FrequencyWhereUniqueInput
  }

  /**
   * Frequency updateMany
   */
  export type FrequencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Frequencies.
     */
    data: XOR<FrequencyUpdateManyMutationInput, FrequencyUncheckedUpdateManyInput>
    /**
     * Filter which Frequencies to update
     */
    where?: FrequencyWhereInput
    /**
     * Limit how many Frequencies to update.
     */
    limit?: number
  }

  /**
   * Frequency updateManyAndReturn
   */
  export type FrequencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * The data used to update Frequencies.
     */
    data: XOR<FrequencyUpdateManyMutationInput, FrequencyUncheckedUpdateManyInput>
    /**
     * Filter which Frequencies to update
     */
    where?: FrequencyWhereInput
    /**
     * Limit how many Frequencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Frequency upsert
   */
  export type FrequencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Frequency to update in case it exists.
     */
    where: FrequencyWhereUniqueInput
    /**
     * In case the Frequency found by the `where` argument doesn't exist, create a new Frequency with this data.
     */
    create: XOR<FrequencyCreateInput, FrequencyUncheckedCreateInput>
    /**
     * In case the Frequency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FrequencyUpdateInput, FrequencyUncheckedUpdateInput>
  }

  /**
   * Frequency delete
   */
  export type FrequencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
    /**
     * Filter which Frequency to delete.
     */
    where: FrequencyWhereUniqueInput
  }

  /**
   * Frequency deleteMany
   */
  export type FrequencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Frequencies to delete
     */
    where?: FrequencyWhereInput
    /**
     * Limit how many Frequencies to delete.
     */
    limit?: number
  }

  /**
   * Frequency without action
   */
  export type FrequencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frequency
     */
    select?: FrequencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frequency
     */
    omit?: FrequencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrequencyInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelAvgAggregateOutputType = {
    level_index: number | null
  }

  export type LevelSumAggregateOutputType = {
    level_index: number | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    level_id: string | null
    level_index: number | null
    level_name: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    level_id: string | null
    level_index: number | null
    level_name: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    level_id: number
    level_index: number
    level_name: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LevelAvgAggregateInputType = {
    level_index?: true
  }

  export type LevelSumAggregateInputType = {
    level_index?: true
  }

  export type LevelMinAggregateInputType = {
    id?: true
    level_id?: true
    level_index?: true
    level_name?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    level_id?: true
    level_index?: true
    level_name?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    level_id?: true
    level_index?: true
    level_name?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _avg?: LevelAvgAggregateInputType
    _sum?: LevelSumAggregateInputType
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    level_id: string
    level_index: number
    level_name: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_id?: boolean
    level_index?: boolean
    level_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    stops?: boolean | Level$stopsArgs<ExtArgs>
    pathways?: boolean | Level$pathwaysArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_id?: boolean
    level_index?: boolean
    level_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level_id?: boolean
    level_index?: boolean
    level_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectScalar = {
    id?: boolean
    level_id?: boolean
    level_index?: boolean
    level_name?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level_id" | "level_index" | "level_name" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    stops?: boolean | Level$stopsArgs<ExtArgs>
    pathways?: boolean | Level$pathwaysArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type LevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      stops: Prisma.$StopPayload<ExtArgs>[]
      pathways: Prisma.$PathwayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level_id: string
      level_index: number
      level_name: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {LevelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LevelUpdateManyAndReturnArgs>(args: SelectSubset<T, LevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stops<T extends Level$stopsArgs<ExtArgs> = {}>(args?: Subset<T, Level$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pathways<T extends Level$pathwaysArgs<ExtArgs> = {}>(args?: Subset<T, Level$pathwaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly level_id: FieldRef<"Level", 'String'>
    readonly level_index: FieldRef<"Level", 'Float'>
    readonly level_name: FieldRef<"Level", 'String'>
    readonly project_id: FieldRef<"Level", 'String'>
    readonly created_by: FieldRef<"Level", 'String'>
    readonly created_at: FieldRef<"Level", 'DateTime'>
    readonly updated_at: FieldRef<"Level", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level updateManyAndReturn
   */
  export type LevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level.stops
   */
  export type Level$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    cursor?: StopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Level.pathways
   */
  export type Level$pathwaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    cursor?: PathwayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model Pathway
   */

  export type AggregatePathway = {
    _count: PathwayCountAggregateOutputType | null
    _avg: PathwayAvgAggregateOutputType | null
    _sum: PathwaySumAggregateOutputType | null
    _min: PathwayMinAggregateOutputType | null
    _max: PathwayMaxAggregateOutputType | null
  }

  export type PathwayAvgAggregateOutputType = {
    pathway_mode: number | null
    is_bidirectional: number | null
    length: number | null
    traversal_time: number | null
    stair_count: number | null
    max_slope: number | null
    min_width: number | null
  }

  export type PathwaySumAggregateOutputType = {
    pathway_mode: number | null
    is_bidirectional: number | null
    length: number | null
    traversal_time: number | null
    stair_count: number | null
    max_slope: number | null
    min_width: number | null
  }

  export type PathwayMinAggregateOutputType = {
    id: string | null
    pathway_id: string | null
    from_stop_id: string | null
    to_stop_id: string | null
    pathway_mode: number | null
    is_bidirectional: number | null
    length: number | null
    traversal_time: number | null
    stair_count: number | null
    max_slope: number | null
    min_width: number | null
    signposted_as: string | null
    reversed_signposted_as: string | null
    level_id: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PathwayMaxAggregateOutputType = {
    id: string | null
    pathway_id: string | null
    from_stop_id: string | null
    to_stop_id: string | null
    pathway_mode: number | null
    is_bidirectional: number | null
    length: number | null
    traversal_time: number | null
    stair_count: number | null
    max_slope: number | null
    min_width: number | null
    signposted_as: string | null
    reversed_signposted_as: string | null
    level_id: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PathwayCountAggregateOutputType = {
    id: number
    pathway_id: number
    from_stop_id: number
    to_stop_id: number
    pathway_mode: number
    is_bidirectional: number
    length: number
    traversal_time: number
    stair_count: number
    max_slope: number
    min_width: number
    signposted_as: number
    reversed_signposted_as: number
    level_id: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PathwayAvgAggregateInputType = {
    pathway_mode?: true
    is_bidirectional?: true
    length?: true
    traversal_time?: true
    stair_count?: true
    max_slope?: true
    min_width?: true
  }

  export type PathwaySumAggregateInputType = {
    pathway_mode?: true
    is_bidirectional?: true
    length?: true
    traversal_time?: true
    stair_count?: true
    max_slope?: true
    min_width?: true
  }

  export type PathwayMinAggregateInputType = {
    id?: true
    pathway_id?: true
    from_stop_id?: true
    to_stop_id?: true
    pathway_mode?: true
    is_bidirectional?: true
    length?: true
    traversal_time?: true
    stair_count?: true
    max_slope?: true
    min_width?: true
    signposted_as?: true
    reversed_signposted_as?: true
    level_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PathwayMaxAggregateInputType = {
    id?: true
    pathway_id?: true
    from_stop_id?: true
    to_stop_id?: true
    pathway_mode?: true
    is_bidirectional?: true
    length?: true
    traversal_time?: true
    stair_count?: true
    max_slope?: true
    min_width?: true
    signposted_as?: true
    reversed_signposted_as?: true
    level_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PathwayCountAggregateInputType = {
    id?: true
    pathway_id?: true
    from_stop_id?: true
    to_stop_id?: true
    pathway_mode?: true
    is_bidirectional?: true
    length?: true
    traversal_time?: true
    stair_count?: true
    max_slope?: true
    min_width?: true
    signposted_as?: true
    reversed_signposted_as?: true
    level_id?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PathwayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pathway to aggregate.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pathways
    **/
    _count?: true | PathwayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathwayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathwaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathwayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathwayMaxAggregateInputType
  }

  export type GetPathwayAggregateType<T extends PathwayAggregateArgs> = {
        [P in keyof T & keyof AggregatePathway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePathway[P]>
      : GetScalarType<T[P], AggregatePathway[P]>
  }




  export type PathwayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathwayWhereInput
    orderBy?: PathwayOrderByWithAggregationInput | PathwayOrderByWithAggregationInput[]
    by: PathwayScalarFieldEnum[] | PathwayScalarFieldEnum
    having?: PathwayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathwayCountAggregateInputType | true
    _avg?: PathwayAvgAggregateInputType
    _sum?: PathwaySumAggregateInputType
    _min?: PathwayMinAggregateInputType
    _max?: PathwayMaxAggregateInputType
  }

  export type PathwayGroupByOutputType = {
    id: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length: number | null
    traversal_time: number | null
    stair_count: number | null
    max_slope: number | null
    min_width: number | null
    signposted_as: string | null
    reversed_signposted_as: string | null
    level_id: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: PathwayCountAggregateOutputType | null
    _avg: PathwayAvgAggregateOutputType | null
    _sum: PathwaySumAggregateOutputType | null
    _min: PathwayMinAggregateOutputType | null
    _max: PathwayMaxAggregateOutputType | null
  }

  type GetPathwayGroupByPayload<T extends PathwayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathwayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathwayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathwayGroupByOutputType[P]>
            : GetScalarType<T[P], PathwayGroupByOutputType[P]>
        }
      >
    >


  export type PathwaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathway_id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    pathway_mode?: boolean
    is_bidirectional?: boolean
    length?: boolean
    traversal_time?: boolean
    stair_count?: boolean
    max_slope?: boolean
    min_width?: boolean
    signposted_as?: boolean
    reversed_signposted_as?: boolean
    level_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
    level?: boolean | Pathway$levelArgs<ExtArgs>
  }, ExtArgs["result"]["pathway"]>

  export type PathwaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathway_id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    pathway_mode?: boolean
    is_bidirectional?: boolean
    length?: boolean
    traversal_time?: boolean
    stair_count?: boolean
    max_slope?: boolean
    min_width?: boolean
    signposted_as?: boolean
    reversed_signposted_as?: boolean
    level_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
    level?: boolean | Pathway$levelArgs<ExtArgs>
  }, ExtArgs["result"]["pathway"]>

  export type PathwaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pathway_id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    pathway_mode?: boolean
    is_bidirectional?: boolean
    length?: boolean
    traversal_time?: boolean
    stair_count?: boolean
    max_slope?: boolean
    min_width?: boolean
    signposted_as?: boolean
    reversed_signposted_as?: boolean
    level_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
    level?: boolean | Pathway$levelArgs<ExtArgs>
  }, ExtArgs["result"]["pathway"]>

  export type PathwaySelectScalar = {
    id?: boolean
    pathway_id?: boolean
    from_stop_id?: boolean
    to_stop_id?: boolean
    pathway_mode?: boolean
    is_bidirectional?: boolean
    length?: boolean
    traversal_time?: boolean
    stair_count?: boolean
    max_slope?: boolean
    min_width?: boolean
    signposted_as?: boolean
    reversed_signposted_as?: boolean
    level_id?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PathwayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pathway_id" | "from_stop_id" | "to_stop_id" | "pathway_mode" | "is_bidirectional" | "length" | "traversal_time" | "stair_count" | "max_slope" | "min_width" | "signposted_as" | "reversed_signposted_as" | "level_id" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["pathway"]>
  export type PathwayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
    level?: boolean | Pathway$levelArgs<ExtArgs>
  }
  export type PathwayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
    level?: boolean | Pathway$levelArgs<ExtArgs>
  }
  export type PathwayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
    fromStop?: boolean | StopDefaultArgs<ExtArgs>
    toStop?: boolean | StopDefaultArgs<ExtArgs>
    level?: boolean | Pathway$levelArgs<ExtArgs>
  }

  export type $PathwayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pathway"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
      fromStop: Prisma.$StopPayload<ExtArgs>
      toStop: Prisma.$StopPayload<ExtArgs>
      level: Prisma.$LevelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pathway_id: string
      from_stop_id: string
      to_stop_id: string
      pathway_mode: number
      is_bidirectional: number
      length: number | null
      traversal_time: number | null
      stair_count: number | null
      max_slope: number | null
      min_width: number | null
      signposted_as: string | null
      reversed_signposted_as: string | null
      level_id: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["pathway"]>
    composites: {}
  }

  type PathwayGetPayload<S extends boolean | null | undefined | PathwayDefaultArgs> = $Result.GetResult<Prisma.$PathwayPayload, S>

  type PathwayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PathwayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PathwayCountAggregateInputType | true
    }

  export interface PathwayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pathway'], meta: { name: 'Pathway' } }
    /**
     * Find zero or one Pathway that matches the filter.
     * @param {PathwayFindUniqueArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathwayFindUniqueArgs>(args: SelectSubset<T, PathwayFindUniqueArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pathway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PathwayFindUniqueOrThrowArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathwayFindUniqueOrThrowArgs>(args: SelectSubset<T, PathwayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pathway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayFindFirstArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathwayFindFirstArgs>(args?: SelectSubset<T, PathwayFindFirstArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pathway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayFindFirstOrThrowArgs} args - Arguments to find a Pathway
     * @example
     * // Get one Pathway
     * const pathway = await prisma.pathway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathwayFindFirstOrThrowArgs>(args?: SelectSubset<T, PathwayFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pathways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pathways
     * const pathways = await prisma.pathway.findMany()
     * 
     * // Get first 10 Pathways
     * const pathways = await prisma.pathway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pathwayWithIdOnly = await prisma.pathway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PathwayFindManyArgs>(args?: SelectSubset<T, PathwayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pathway.
     * @param {PathwayCreateArgs} args - Arguments to create a Pathway.
     * @example
     * // Create one Pathway
     * const Pathway = await prisma.pathway.create({
     *   data: {
     *     // ... data to create a Pathway
     *   }
     * })
     * 
     */
    create<T extends PathwayCreateArgs>(args: SelectSubset<T, PathwayCreateArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pathways.
     * @param {PathwayCreateManyArgs} args - Arguments to create many Pathways.
     * @example
     * // Create many Pathways
     * const pathway = await prisma.pathway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathwayCreateManyArgs>(args?: SelectSubset<T, PathwayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pathways and returns the data saved in the database.
     * @param {PathwayCreateManyAndReturnArgs} args - Arguments to create many Pathways.
     * @example
     * // Create many Pathways
     * const pathway = await prisma.pathway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pathways and only return the `id`
     * const pathwayWithIdOnly = await prisma.pathway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathwayCreateManyAndReturnArgs>(args?: SelectSubset<T, PathwayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pathway.
     * @param {PathwayDeleteArgs} args - Arguments to delete one Pathway.
     * @example
     * // Delete one Pathway
     * const Pathway = await prisma.pathway.delete({
     *   where: {
     *     // ... filter to delete one Pathway
     *   }
     * })
     * 
     */
    delete<T extends PathwayDeleteArgs>(args: SelectSubset<T, PathwayDeleteArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pathway.
     * @param {PathwayUpdateArgs} args - Arguments to update one Pathway.
     * @example
     * // Update one Pathway
     * const pathway = await prisma.pathway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathwayUpdateArgs>(args: SelectSubset<T, PathwayUpdateArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pathways.
     * @param {PathwayDeleteManyArgs} args - Arguments to filter Pathways to delete.
     * @example
     * // Delete a few Pathways
     * const { count } = await prisma.pathway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathwayDeleteManyArgs>(args?: SelectSubset<T, PathwayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pathways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pathways
     * const pathway = await prisma.pathway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathwayUpdateManyArgs>(args: SelectSubset<T, PathwayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pathways and returns the data updated in the database.
     * @param {PathwayUpdateManyAndReturnArgs} args - Arguments to update many Pathways.
     * @example
     * // Update many Pathways
     * const pathway = await prisma.pathway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pathways and only return the `id`
     * const pathwayWithIdOnly = await prisma.pathway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PathwayUpdateManyAndReturnArgs>(args: SelectSubset<T, PathwayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pathway.
     * @param {PathwayUpsertArgs} args - Arguments to update or create a Pathway.
     * @example
     * // Update or create a Pathway
     * const pathway = await prisma.pathway.upsert({
     *   create: {
     *     // ... data to create a Pathway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pathway we want to update
     *   }
     * })
     */
    upsert<T extends PathwayUpsertArgs>(args: SelectSubset<T, PathwayUpsertArgs<ExtArgs>>): Prisma__PathwayClient<$Result.GetResult<Prisma.$PathwayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pathways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayCountArgs} args - Arguments to filter Pathways to count.
     * @example
     * // Count the number of Pathways
     * const count = await prisma.pathway.count({
     *   where: {
     *     // ... the filter for the Pathways we want to count
     *   }
     * })
    **/
    count<T extends PathwayCountArgs>(
      args?: Subset<T, PathwayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathwayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pathway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathwayAggregateArgs>(args: Subset<T, PathwayAggregateArgs>): Prisma.PrismaPromise<GetPathwayAggregateType<T>>

    /**
     * Group by Pathway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathwayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathwayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathwayGroupByArgs['orderBy'] }
        : { orderBy?: PathwayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathwayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathwayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pathway model
   */
  readonly fields: PathwayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pathway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathwayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromStop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toStop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    level<T extends Pathway$levelArgs<ExtArgs> = {}>(args?: Subset<T, Pathway$levelArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pathway model
   */
  interface PathwayFieldRefs {
    readonly id: FieldRef<"Pathway", 'String'>
    readonly pathway_id: FieldRef<"Pathway", 'String'>
    readonly from_stop_id: FieldRef<"Pathway", 'String'>
    readonly to_stop_id: FieldRef<"Pathway", 'String'>
    readonly pathway_mode: FieldRef<"Pathway", 'Int'>
    readonly is_bidirectional: FieldRef<"Pathway", 'Int'>
    readonly length: FieldRef<"Pathway", 'Float'>
    readonly traversal_time: FieldRef<"Pathway", 'Int'>
    readonly stair_count: FieldRef<"Pathway", 'Int'>
    readonly max_slope: FieldRef<"Pathway", 'Float'>
    readonly min_width: FieldRef<"Pathway", 'Float'>
    readonly signposted_as: FieldRef<"Pathway", 'String'>
    readonly reversed_signposted_as: FieldRef<"Pathway", 'String'>
    readonly level_id: FieldRef<"Pathway", 'String'>
    readonly project_id: FieldRef<"Pathway", 'String'>
    readonly created_by: FieldRef<"Pathway", 'String'>
    readonly created_at: FieldRef<"Pathway", 'DateTime'>
    readonly updated_at: FieldRef<"Pathway", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pathway findUnique
   */
  export type PathwayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway findUniqueOrThrow
   */
  export type PathwayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway findFirst
   */
  export type PathwayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pathways.
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pathways.
     */
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Pathway findFirstOrThrow
   */
  export type PathwayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathway to fetch.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pathways.
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pathways.
     */
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Pathway findMany
   */
  export type PathwayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter, which Pathways to fetch.
     */
    where?: PathwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pathways to fetch.
     */
    orderBy?: PathwayOrderByWithRelationInput | PathwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pathways.
     */
    cursor?: PathwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pathways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pathways.
     */
    skip?: number
    distinct?: PathwayScalarFieldEnum | PathwayScalarFieldEnum[]
  }

  /**
   * Pathway create
   */
  export type PathwayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * The data needed to create a Pathway.
     */
    data: XOR<PathwayCreateInput, PathwayUncheckedCreateInput>
  }

  /**
   * Pathway createMany
   */
  export type PathwayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pathways.
     */
    data: PathwayCreateManyInput | PathwayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pathway createManyAndReturn
   */
  export type PathwayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * The data used to create many Pathways.
     */
    data: PathwayCreateManyInput | PathwayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pathway update
   */
  export type PathwayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * The data needed to update a Pathway.
     */
    data: XOR<PathwayUpdateInput, PathwayUncheckedUpdateInput>
    /**
     * Choose, which Pathway to update.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway updateMany
   */
  export type PathwayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pathways.
     */
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyInput>
    /**
     * Filter which Pathways to update
     */
    where?: PathwayWhereInput
    /**
     * Limit how many Pathways to update.
     */
    limit?: number
  }

  /**
   * Pathway updateManyAndReturn
   */
  export type PathwayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * The data used to update Pathways.
     */
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyInput>
    /**
     * Filter which Pathways to update
     */
    where?: PathwayWhereInput
    /**
     * Limit how many Pathways to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pathway upsert
   */
  export type PathwayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * The filter to search for the Pathway to update in case it exists.
     */
    where: PathwayWhereUniqueInput
    /**
     * In case the Pathway found by the `where` argument doesn't exist, create a new Pathway with this data.
     */
    create: XOR<PathwayCreateInput, PathwayUncheckedCreateInput>
    /**
     * In case the Pathway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathwayUpdateInput, PathwayUncheckedUpdateInput>
  }

  /**
   * Pathway delete
   */
  export type PathwayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
    /**
     * Filter which Pathway to delete.
     */
    where: PathwayWhereUniqueInput
  }

  /**
   * Pathway deleteMany
   */
  export type PathwayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pathways to delete
     */
    where?: PathwayWhereInput
    /**
     * Limit how many Pathways to delete.
     */
    limit?: number
  }

  /**
   * Pathway.level
   */
  export type Pathway$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
  }

  /**
   * Pathway without action
   */
  export type PathwayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pathway
     */
    select?: PathwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pathway
     */
    omit?: PathwayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathwayInclude<ExtArgs> | null
  }


  /**
   * Model FeedInfo
   */

  export type AggregateFeedInfo = {
    _count: FeedInfoCountAggregateOutputType | null
    _min: FeedInfoMinAggregateOutputType | null
    _max: FeedInfoMaxAggregateOutputType | null
  }

  export type FeedInfoMinAggregateOutputType = {
    id: string | null
    feed_publisher_name: string | null
    feed_publisher_url: string | null
    feed_lang: string | null
    default_lang: string | null
    feed_start_date: string | null
    feed_end_date: string | null
    feed_version: string | null
    feed_contact_email: string | null
    feed_contact_url: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FeedInfoMaxAggregateOutputType = {
    id: string | null
    feed_publisher_name: string | null
    feed_publisher_url: string | null
    feed_lang: string | null
    default_lang: string | null
    feed_start_date: string | null
    feed_end_date: string | null
    feed_version: string | null
    feed_contact_email: string | null
    feed_contact_url: string | null
    project_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FeedInfoCountAggregateOutputType = {
    id: number
    feed_publisher_name: number
    feed_publisher_url: number
    feed_lang: number
    default_lang: number
    feed_start_date: number
    feed_end_date: number
    feed_version: number
    feed_contact_email: number
    feed_contact_url: number
    project_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FeedInfoMinAggregateInputType = {
    id?: true
    feed_publisher_name?: true
    feed_publisher_url?: true
    feed_lang?: true
    default_lang?: true
    feed_start_date?: true
    feed_end_date?: true
    feed_version?: true
    feed_contact_email?: true
    feed_contact_url?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FeedInfoMaxAggregateInputType = {
    id?: true
    feed_publisher_name?: true
    feed_publisher_url?: true
    feed_lang?: true
    default_lang?: true
    feed_start_date?: true
    feed_end_date?: true
    feed_version?: true
    feed_contact_email?: true
    feed_contact_url?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FeedInfoCountAggregateInputType = {
    id?: true
    feed_publisher_name?: true
    feed_publisher_url?: true
    feed_lang?: true
    default_lang?: true
    feed_start_date?: true
    feed_end_date?: true
    feed_version?: true
    feed_contact_email?: true
    feed_contact_url?: true
    project_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FeedInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedInfo to aggregate.
     */
    where?: FeedInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedInfos to fetch.
     */
    orderBy?: FeedInfoOrderByWithRelationInput | FeedInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedInfos
    **/
    _count?: true | FeedInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedInfoMaxAggregateInputType
  }

  export type GetFeedInfoAggregateType<T extends FeedInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedInfo[P]>
      : GetScalarType<T[P], AggregateFeedInfo[P]>
  }




  export type FeedInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedInfoWhereInput
    orderBy?: FeedInfoOrderByWithAggregationInput | FeedInfoOrderByWithAggregationInput[]
    by: FeedInfoScalarFieldEnum[] | FeedInfoScalarFieldEnum
    having?: FeedInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedInfoCountAggregateInputType | true
    _min?: FeedInfoMinAggregateInputType
    _max?: FeedInfoMaxAggregateInputType
  }

  export type FeedInfoGroupByOutputType = {
    id: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang: string | null
    feed_start_date: string | null
    feed_end_date: string | null
    feed_version: string | null
    feed_contact_email: string | null
    feed_contact_url: string | null
    project_id: string
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: FeedInfoCountAggregateOutputType | null
    _min: FeedInfoMinAggregateOutputType | null
    _max: FeedInfoMaxAggregateOutputType | null
  }

  type GetFeedInfoGroupByPayload<T extends FeedInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedInfoGroupByOutputType[P]>
            : GetScalarType<T[P], FeedInfoGroupByOutputType[P]>
        }
      >
    >


  export type FeedInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feed_publisher_name?: boolean
    feed_publisher_url?: boolean
    feed_lang?: boolean
    default_lang?: boolean
    feed_start_date?: boolean
    feed_end_date?: boolean
    feed_version?: boolean
    feed_contact_email?: boolean
    feed_contact_url?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedInfo"]>

  export type FeedInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feed_publisher_name?: boolean
    feed_publisher_url?: boolean
    feed_lang?: boolean
    default_lang?: boolean
    feed_start_date?: boolean
    feed_end_date?: boolean
    feed_version?: boolean
    feed_contact_email?: boolean
    feed_contact_url?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedInfo"]>

  export type FeedInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feed_publisher_name?: boolean
    feed_publisher_url?: boolean
    feed_lang?: boolean
    default_lang?: boolean
    feed_start_date?: boolean
    feed_end_date?: boolean
    feed_version?: boolean
    feed_contact_email?: boolean
    feed_contact_url?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedInfo"]>

  export type FeedInfoSelectScalar = {
    id?: boolean
    feed_publisher_name?: boolean
    feed_publisher_url?: boolean
    feed_lang?: boolean
    default_lang?: boolean
    feed_start_date?: boolean
    feed_end_date?: boolean
    feed_version?: boolean
    feed_contact_email?: boolean
    feed_contact_url?: boolean
    project_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FeedInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feed_publisher_name" | "feed_publisher_url" | "feed_lang" | "default_lang" | "feed_start_date" | "feed_end_date" | "feed_version" | "feed_contact_email" | "feed_contact_url" | "project_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["feedInfo"]>
  export type FeedInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type FeedInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }
  export type FeedInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | UserProjectDefaultArgs<ExtArgs>
  }

  export type $FeedInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedInfo"
    objects: {
      project: Prisma.$UserProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feed_publisher_name: string
      feed_publisher_url: string
      feed_lang: string
      default_lang: string | null
      feed_start_date: string | null
      feed_end_date: string | null
      feed_version: string | null
      feed_contact_email: string | null
      feed_contact_url: string | null
      project_id: string
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["feedInfo"]>
    composites: {}
  }

  type FeedInfoGetPayload<S extends boolean | null | undefined | FeedInfoDefaultArgs> = $Result.GetResult<Prisma.$FeedInfoPayload, S>

  type FeedInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedInfoCountAggregateInputType | true
    }

  export interface FeedInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedInfo'], meta: { name: 'FeedInfo' } }
    /**
     * Find zero or one FeedInfo that matches the filter.
     * @param {FeedInfoFindUniqueArgs} args - Arguments to find a FeedInfo
     * @example
     * // Get one FeedInfo
     * const feedInfo = await prisma.feedInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedInfoFindUniqueArgs>(args: SelectSubset<T, FeedInfoFindUniqueArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedInfoFindUniqueOrThrowArgs} args - Arguments to find a FeedInfo
     * @example
     * // Get one FeedInfo
     * const feedInfo = await prisma.feedInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoFindFirstArgs} args - Arguments to find a FeedInfo
     * @example
     * // Get one FeedInfo
     * const feedInfo = await prisma.feedInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedInfoFindFirstArgs>(args?: SelectSubset<T, FeedInfoFindFirstArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoFindFirstOrThrowArgs} args - Arguments to find a FeedInfo
     * @example
     * // Get one FeedInfo
     * const feedInfo = await prisma.feedInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedInfos
     * const feedInfos = await prisma.feedInfo.findMany()
     * 
     * // Get first 10 FeedInfos
     * const feedInfos = await prisma.feedInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedInfoWithIdOnly = await prisma.feedInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedInfoFindManyArgs>(args?: SelectSubset<T, FeedInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedInfo.
     * @param {FeedInfoCreateArgs} args - Arguments to create a FeedInfo.
     * @example
     * // Create one FeedInfo
     * const FeedInfo = await prisma.feedInfo.create({
     *   data: {
     *     // ... data to create a FeedInfo
     *   }
     * })
     * 
     */
    create<T extends FeedInfoCreateArgs>(args: SelectSubset<T, FeedInfoCreateArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedInfos.
     * @param {FeedInfoCreateManyArgs} args - Arguments to create many FeedInfos.
     * @example
     * // Create many FeedInfos
     * const feedInfo = await prisma.feedInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedInfoCreateManyArgs>(args?: SelectSubset<T, FeedInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedInfos and returns the data saved in the database.
     * @param {FeedInfoCreateManyAndReturnArgs} args - Arguments to create many FeedInfos.
     * @example
     * // Create many FeedInfos
     * const feedInfo = await prisma.feedInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedInfos and only return the `id`
     * const feedInfoWithIdOnly = await prisma.feedInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeedInfo.
     * @param {FeedInfoDeleteArgs} args - Arguments to delete one FeedInfo.
     * @example
     * // Delete one FeedInfo
     * const FeedInfo = await prisma.feedInfo.delete({
     *   where: {
     *     // ... filter to delete one FeedInfo
     *   }
     * })
     * 
     */
    delete<T extends FeedInfoDeleteArgs>(args: SelectSubset<T, FeedInfoDeleteArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedInfo.
     * @param {FeedInfoUpdateArgs} args - Arguments to update one FeedInfo.
     * @example
     * // Update one FeedInfo
     * const feedInfo = await prisma.feedInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedInfoUpdateArgs>(args: SelectSubset<T, FeedInfoUpdateArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedInfos.
     * @param {FeedInfoDeleteManyArgs} args - Arguments to filter FeedInfos to delete.
     * @example
     * // Delete a few FeedInfos
     * const { count } = await prisma.feedInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedInfoDeleteManyArgs>(args?: SelectSubset<T, FeedInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedInfos
     * const feedInfo = await prisma.feedInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedInfoUpdateManyArgs>(args: SelectSubset<T, FeedInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedInfos and returns the data updated in the database.
     * @param {FeedInfoUpdateManyAndReturnArgs} args - Arguments to update many FeedInfos.
     * @example
     * // Update many FeedInfos
     * const feedInfo = await prisma.feedInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedInfos and only return the `id`
     * const feedInfoWithIdOnly = await prisma.feedInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeedInfo.
     * @param {FeedInfoUpsertArgs} args - Arguments to update or create a FeedInfo.
     * @example
     * // Update or create a FeedInfo
     * const feedInfo = await prisma.feedInfo.upsert({
     *   create: {
     *     // ... data to create a FeedInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedInfo we want to update
     *   }
     * })
     */
    upsert<T extends FeedInfoUpsertArgs>(args: SelectSubset<T, FeedInfoUpsertArgs<ExtArgs>>): Prisma__FeedInfoClient<$Result.GetResult<Prisma.$FeedInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeedInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoCountArgs} args - Arguments to filter FeedInfos to count.
     * @example
     * // Count the number of FeedInfos
     * const count = await prisma.feedInfo.count({
     *   where: {
     *     // ... the filter for the FeedInfos we want to count
     *   }
     * })
    **/
    count<T extends FeedInfoCountArgs>(
      args?: Subset<T, FeedInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedInfoAggregateArgs>(args: Subset<T, FeedInfoAggregateArgs>): Prisma.PrismaPromise<GetFeedInfoAggregateType<T>>

    /**
     * Group by FeedInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedInfoGroupByArgs['orderBy'] }
        : { orderBy?: FeedInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedInfo model
   */
  readonly fields: FeedInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends UserProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProjectDefaultArgs<ExtArgs>>): Prisma__UserProjectClient<$Result.GetResult<Prisma.$UserProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedInfo model
   */
  interface FeedInfoFieldRefs {
    readonly id: FieldRef<"FeedInfo", 'String'>
    readonly feed_publisher_name: FieldRef<"FeedInfo", 'String'>
    readonly feed_publisher_url: FieldRef<"FeedInfo", 'String'>
    readonly feed_lang: FieldRef<"FeedInfo", 'String'>
    readonly default_lang: FieldRef<"FeedInfo", 'String'>
    readonly feed_start_date: FieldRef<"FeedInfo", 'String'>
    readonly feed_end_date: FieldRef<"FeedInfo", 'String'>
    readonly feed_version: FieldRef<"FeedInfo", 'String'>
    readonly feed_contact_email: FieldRef<"FeedInfo", 'String'>
    readonly feed_contact_url: FieldRef<"FeedInfo", 'String'>
    readonly project_id: FieldRef<"FeedInfo", 'String'>
    readonly created_by: FieldRef<"FeedInfo", 'String'>
    readonly created_at: FieldRef<"FeedInfo", 'DateTime'>
    readonly updated_at: FieldRef<"FeedInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedInfo findUnique
   */
  export type FeedInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * Filter, which FeedInfo to fetch.
     */
    where: FeedInfoWhereUniqueInput
  }

  /**
   * FeedInfo findUniqueOrThrow
   */
  export type FeedInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * Filter, which FeedInfo to fetch.
     */
    where: FeedInfoWhereUniqueInput
  }

  /**
   * FeedInfo findFirst
   */
  export type FeedInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * Filter, which FeedInfo to fetch.
     */
    where?: FeedInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedInfos to fetch.
     */
    orderBy?: FeedInfoOrderByWithRelationInput | FeedInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedInfos.
     */
    cursor?: FeedInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedInfos.
     */
    distinct?: FeedInfoScalarFieldEnum | FeedInfoScalarFieldEnum[]
  }

  /**
   * FeedInfo findFirstOrThrow
   */
  export type FeedInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * Filter, which FeedInfo to fetch.
     */
    where?: FeedInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedInfos to fetch.
     */
    orderBy?: FeedInfoOrderByWithRelationInput | FeedInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedInfos.
     */
    cursor?: FeedInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedInfos.
     */
    distinct?: FeedInfoScalarFieldEnum | FeedInfoScalarFieldEnum[]
  }

  /**
   * FeedInfo findMany
   */
  export type FeedInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * Filter, which FeedInfos to fetch.
     */
    where?: FeedInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedInfos to fetch.
     */
    orderBy?: FeedInfoOrderByWithRelationInput | FeedInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedInfos.
     */
    cursor?: FeedInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedInfos.
     */
    skip?: number
    distinct?: FeedInfoScalarFieldEnum | FeedInfoScalarFieldEnum[]
  }

  /**
   * FeedInfo create
   */
  export type FeedInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedInfo.
     */
    data: XOR<FeedInfoCreateInput, FeedInfoUncheckedCreateInput>
  }

  /**
   * FeedInfo createMany
   */
  export type FeedInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedInfos.
     */
    data: FeedInfoCreateManyInput | FeedInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedInfo createManyAndReturn
   */
  export type FeedInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * The data used to create many FeedInfos.
     */
    data: FeedInfoCreateManyInput | FeedInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedInfo update
   */
  export type FeedInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedInfo.
     */
    data: XOR<FeedInfoUpdateInput, FeedInfoUncheckedUpdateInput>
    /**
     * Choose, which FeedInfo to update.
     */
    where: FeedInfoWhereUniqueInput
  }

  /**
   * FeedInfo updateMany
   */
  export type FeedInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedInfos.
     */
    data: XOR<FeedInfoUpdateManyMutationInput, FeedInfoUncheckedUpdateManyInput>
    /**
     * Filter which FeedInfos to update
     */
    where?: FeedInfoWhereInput
    /**
     * Limit how many FeedInfos to update.
     */
    limit?: number
  }

  /**
   * FeedInfo updateManyAndReturn
   */
  export type FeedInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * The data used to update FeedInfos.
     */
    data: XOR<FeedInfoUpdateManyMutationInput, FeedInfoUncheckedUpdateManyInput>
    /**
     * Filter which FeedInfos to update
     */
    where?: FeedInfoWhereInput
    /**
     * Limit how many FeedInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedInfo upsert
   */
  export type FeedInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedInfo to update in case it exists.
     */
    where: FeedInfoWhereUniqueInput
    /**
     * In case the FeedInfo found by the `where` argument doesn't exist, create a new FeedInfo with this data.
     */
    create: XOR<FeedInfoCreateInput, FeedInfoUncheckedCreateInput>
    /**
     * In case the FeedInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedInfoUpdateInput, FeedInfoUncheckedUpdateInput>
  }

  /**
   * FeedInfo delete
   */
  export type FeedInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
    /**
     * Filter which FeedInfo to delete.
     */
    where: FeedInfoWhereUniqueInput
  }

  /**
   * FeedInfo deleteMany
   */
  export type FeedInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedInfos to delete
     */
    where?: FeedInfoWhereInput
    /**
     * Limit how many FeedInfos to delete.
     */
    limit?: number
  }

  /**
   * FeedInfo without action
   */
  export type FeedInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedInfo
     */
    select?: FeedInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedInfo
     */
    omit?: FeedInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedInfoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password_hash: 'password_hash',
    avatar_url: 'avatar_url',
    first_name: 'first_name',
    last_name: 'last_name',
    is_active: 'is_active',
    is_verified: 'is_verified',
    last_login: 'last_login',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    theme: 'theme',
    language: 'language',
    timezone: 'timezone',
    map_default_lat: 'map_default_lat',
    map_default_lon: 'map_default_lon',
    map_default_zoom: 'map_default_zoom',
    table_page_size: 'table_page_size',
    notifications: 'notifications',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const UserProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    owner_id: 'owner_id',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserProjectScalarFieldEnum = (typeof UserProjectScalarFieldEnum)[keyof typeof UserProjectScalarFieldEnum]


  export const ProjectShareScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    user_id: 'user_id',
    role: 'role',
    shared_by: 'shared_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProjectShareScalarFieldEnum = (typeof ProjectShareScalarFieldEnum)[keyof typeof ProjectShareScalarFieldEnum]


  export const ProjectInviteScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    email: 'email',
    user_id: 'user_id',
    role: 'role',
    token: 'token',
    invited_by: 'invited_by',
    expires_at: 'expires_at',
    accepted_at: 'accepted_at',
    created_at: 'created_at'
  };

  export type ProjectInviteScalarFieldEnum = (typeof ProjectInviteScalarFieldEnum)[keyof typeof ProjectInviteScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token',
    expires_at: 'expires_at',
    used_at: 'used_at',
    created_at: 'created_at'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    session_token: 'session_token',
    expires_at: 'expires_at',
    user_agent: 'user_agent',
    ip_address: 'ip_address',
    created_at: 'created_at',
    last_active: 'last_active'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    agency_id: 'agency_id',
    agency_name: 'agency_name',
    agency_url: 'agency_url',
    agency_timezone: 'agency_timezone',
    agency_lang: 'agency_lang',
    agency_phone: 'agency_phone',
    agency_fare_url: 'agency_fare_url',
    agency_email: 'agency_email',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const StopScalarFieldEnum: {
    id: 'id',
    stop_id: 'stop_id',
    stop_code: 'stop_code',
    stop_name: 'stop_name',
    stop_desc: 'stop_desc',
    stop_lat: 'stop_lat',
    stop_lon: 'stop_lon',
    zone_id: 'zone_id',
    stop_url: 'stop_url',
    location_type: 'location_type',
    wheelchair_boarding: 'wheelchair_boarding',
    parent_station: 'parent_station',
    platform_code: 'platform_code',
    level_id: 'level_id',
    tts_stop_name: 'tts_stop_name',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StopScalarFieldEnum = (typeof StopScalarFieldEnum)[keyof typeof StopScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    id: 'id',
    route_id: 'route_id',
    agency_id: 'agency_id',
    route_short_name: 'route_short_name',
    route_long_name: 'route_long_name',
    route_desc: 'route_desc',
    route_type: 'route_type',
    route_url: 'route_url',
    route_color: 'route_color',
    route_text_color: 'route_text_color',
    route_sort_order: 'route_sort_order',
    continuous_pickup: 'continuous_pickup',
    continuous_drop_off: 'continuous_drop_off',
    network_id: 'network_id',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    trip_id: 'trip_id',
    route_id: 'route_id',
    service_id: 'service_id',
    trip_headsign: 'trip_headsign',
    trip_short_name: 'trip_short_name',
    direction_id: 'direction_id',
    block_id: 'block_id',
    shape_id: 'shape_id',
    wheelchair_accessible: 'wheelchair_accessible',
    bikes_allowed: 'bikes_allowed',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const StopTimeScalarFieldEnum: {
    id: 'id',
    trip_id: 'trip_id',
    stop_id: 'stop_id',
    arrival_time: 'arrival_time',
    departure_time: 'departure_time',
    stop_sequence: 'stop_sequence',
    stop_headsign: 'stop_headsign',
    pickup_type: 'pickup_type',
    drop_off_type: 'drop_off_type',
    continuous_pickup: 'continuous_pickup',
    continuous_drop_off: 'continuous_drop_off',
    shape_dist_traveled: 'shape_dist_traveled',
    timepoint: 'timepoint',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StopTimeScalarFieldEnum = (typeof StopTimeScalarFieldEnum)[keyof typeof StopTimeScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    monday: 'monday',
    tuesday: 'tuesday',
    wednesday: 'wednesday',
    thursday: 'thursday',
    friday: 'friday',
    saturday: 'saturday',
    sunday: 'sunday',
    start_date: 'start_date',
    end_date: 'end_date',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const CalendarDateScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    date: 'date',
    exception_type: 'exception_type',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CalendarDateScalarFieldEnum = (typeof CalendarDateScalarFieldEnum)[keyof typeof CalendarDateScalarFieldEnum]


  export const FareAttributeScalarFieldEnum: {
    id: 'id',
    fare_id: 'fare_id',
    price: 'price',
    currency_type: 'currency_type',
    payment_method: 'payment_method',
    transfers: 'transfers',
    agency_id: 'agency_id',
    transfer_duration: 'transfer_duration',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FareAttributeScalarFieldEnum = (typeof FareAttributeScalarFieldEnum)[keyof typeof FareAttributeScalarFieldEnum]


  export const FareRuleScalarFieldEnum: {
    id: 'id',
    fare_id: 'fare_id',
    route_id: 'route_id',
    origin_id: 'origin_id',
    destination_id: 'destination_id',
    contains_id: 'contains_id',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FareRuleScalarFieldEnum = (typeof FareRuleScalarFieldEnum)[keyof typeof FareRuleScalarFieldEnum]


  export const ShapeScalarFieldEnum: {
    id: 'id',
    shape_id: 'shape_id',
    shape_pt_sequence: 'shape_pt_sequence',
    shape_pt_lat: 'shape_pt_lat',
    shape_pt_lon: 'shape_pt_lon',
    shape_dist_traveled: 'shape_dist_traveled',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ShapeScalarFieldEnum = (typeof ShapeScalarFieldEnum)[keyof typeof ShapeScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    from_stop_id: 'from_stop_id',
    to_stop_id: 'to_stop_id',
    transfer_type: 'transfer_type',
    min_transfer_time: 'min_transfer_time',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const FrequencyScalarFieldEnum: {
    id: 'id',
    trip_id: 'trip_id',
    start_time: 'start_time',
    end_time: 'end_time',
    headway_secs: 'headway_secs',
    exact_times: 'exact_times',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FrequencyScalarFieldEnum = (typeof FrequencyScalarFieldEnum)[keyof typeof FrequencyScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    level_id: 'level_id',
    level_index: 'level_index',
    level_name: 'level_name',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const PathwayScalarFieldEnum: {
    id: 'id',
    pathway_id: 'pathway_id',
    from_stop_id: 'from_stop_id',
    to_stop_id: 'to_stop_id',
    pathway_mode: 'pathway_mode',
    is_bidirectional: 'is_bidirectional',
    length: 'length',
    traversal_time: 'traversal_time',
    stair_count: 'stair_count',
    max_slope: 'max_slope',
    min_width: 'min_width',
    signposted_as: 'signposted_as',
    reversed_signposted_as: 'reversed_signposted_as',
    level_id: 'level_id',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PathwayScalarFieldEnum = (typeof PathwayScalarFieldEnum)[keyof typeof PathwayScalarFieldEnum]


  export const FeedInfoScalarFieldEnum: {
    id: 'id',
    feed_publisher_name: 'feed_publisher_name',
    feed_publisher_url: 'feed_publisher_url',
    feed_lang: 'feed_lang',
    default_lang: 'default_lang',
    feed_start_date: 'feed_start_date',
    feed_end_date: 'feed_end_date',
    feed_version: 'feed_version',
    feed_contact_email: 'feed_contact_email',
    feed_contact_url: 'feed_contact_url',
    project_id: 'project_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FeedInfoScalarFieldEnum = (typeof FeedInfoScalarFieldEnum)[keyof typeof FeedInfoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProjectRole'
   */
  export type EnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole'>
    


  /**
   * Reference to a field of type 'ProjectRole[]'
   */
  export type ListEnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    first_name?: StringNullableFilter<"User"> | string | null
    last_name?: StringNullableFilter<"User"> | string | null
    is_active?: BoolFilter<"User"> | boolean
    is_verified?: BoolFilter<"User"> | boolean
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    ownedProjects?: UserProjectListRelationFilter
    sharedProjects?: ProjectShareListRelationFilter
    invitedProjects?: ProjectInviteListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    last_login?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    preferences?: UserPreferencesOrderByWithRelationInput
    ownedProjects?: UserProjectOrderByRelationAggregateInput
    sharedProjects?: ProjectShareOrderByRelationAggregateInput
    invitedProjects?: ProjectInviteOrderByRelationAggregateInput
    passwordResets?: PasswordResetOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    first_name?: StringNullableFilter<"User"> | string | null
    last_name?: StringNullableFilter<"User"> | string | null
    is_active?: BoolFilter<"User"> | boolean
    is_verified?: BoolFilter<"User"> | boolean
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    ownedProjects?: UserProjectListRelationFilter
    sharedProjects?: ProjectShareListRelationFilter
    invitedProjects?: ProjectInviteListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    last_login?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    avatar_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    first_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
    is_verified?: BoolWithAggregatesFilter<"User"> | boolean
    last_login?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    user_id?: StringFilter<"UserPreferences"> | string
    theme?: StringFilter<"UserPreferences"> | string
    language?: StringFilter<"UserPreferences"> | string
    timezone?: StringFilter<"UserPreferences"> | string
    map_default_lat?: FloatFilter<"UserPreferences"> | number
    map_default_lon?: FloatFilter<"UserPreferences"> | number
    map_default_zoom?: IntFilter<"UserPreferences"> | number
    table_page_size?: IntFilter<"UserPreferences"> | number
    notifications?: BoolFilter<"UserPreferences"> | boolean
    created_at?: DateTimeFilter<"UserPreferences"> | Date | string
    updated_at?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    theme?: StringFilter<"UserPreferences"> | string
    language?: StringFilter<"UserPreferences"> | string
    timezone?: StringFilter<"UserPreferences"> | string
    map_default_lat?: FloatFilter<"UserPreferences"> | number
    map_default_lon?: FloatFilter<"UserPreferences"> | number
    map_default_zoom?: IntFilter<"UserPreferences"> | number
    table_page_size?: IntFilter<"UserPreferences"> | number
    notifications?: BoolFilter<"UserPreferences"> | boolean
    created_at?: DateTimeFilter<"UserPreferences"> | Date | string
    updated_at?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    user_id?: StringWithAggregatesFilter<"UserPreferences"> | string
    theme?: StringWithAggregatesFilter<"UserPreferences"> | string
    language?: StringWithAggregatesFilter<"UserPreferences"> | string
    timezone?: StringWithAggregatesFilter<"UserPreferences"> | string
    map_default_lat?: FloatWithAggregatesFilter<"UserPreferences"> | number
    map_default_lon?: FloatWithAggregatesFilter<"UserPreferences"> | number
    map_default_zoom?: IntWithAggregatesFilter<"UserPreferences"> | number
    table_page_size?: IntWithAggregatesFilter<"UserPreferences"> | number
    notifications?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type UserProjectWhereInput = {
    AND?: UserProjectWhereInput | UserProjectWhereInput[]
    OR?: UserProjectWhereInput[]
    NOT?: UserProjectWhereInput | UserProjectWhereInput[]
    id?: StringFilter<"UserProject"> | string
    name?: StringFilter<"UserProject"> | string
    description?: StringNullableFilter<"UserProject"> | string | null
    owner_id?: StringFilter<"UserProject"> | string
    is_active?: BoolFilter<"UserProject"> | boolean
    created_at?: DateTimeFilter<"UserProject"> | Date | string
    updated_at?: DateTimeFilter<"UserProject"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    shares?: ProjectShareListRelationFilter
    invites?: ProjectInviteListRelationFilter
    agencies?: AgencyListRelationFilter
    stops?: StopListRelationFilter
    routes?: RouteListRelationFilter
    trips?: TripListRelationFilter
    stopTimes?: StopTimeListRelationFilter
    calendars?: CalendarListRelationFilter
    calendarDates?: CalendarDateListRelationFilter
    fareAttributes?: FareAttributeListRelationFilter
    fareRules?: FareRuleListRelationFilter
    shapes?: ShapeListRelationFilter
    transfers?: TransferListRelationFilter
    frequencies?: FrequencyListRelationFilter
    levels?: LevelListRelationFilter
    pathways?: PathwayListRelationFilter
    feedInfo?: FeedInfoListRelationFilter
  }

  export type UserProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    owner_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    owner?: UserOrderByWithRelationInput
    shares?: ProjectShareOrderByRelationAggregateInput
    invites?: ProjectInviteOrderByRelationAggregateInput
    agencies?: AgencyOrderByRelationAggregateInput
    stops?: StopOrderByRelationAggregateInput
    routes?: RouteOrderByRelationAggregateInput
    trips?: TripOrderByRelationAggregateInput
    stopTimes?: StopTimeOrderByRelationAggregateInput
    calendars?: CalendarOrderByRelationAggregateInput
    calendarDates?: CalendarDateOrderByRelationAggregateInput
    fareAttributes?: FareAttributeOrderByRelationAggregateInput
    fareRules?: FareRuleOrderByRelationAggregateInput
    shapes?: ShapeOrderByRelationAggregateInput
    transfers?: TransferOrderByRelationAggregateInput
    frequencies?: FrequencyOrderByRelationAggregateInput
    levels?: LevelOrderByRelationAggregateInput
    pathways?: PathwayOrderByRelationAggregateInput
    feedInfo?: FeedInfoOrderByRelationAggregateInput
  }

  export type UserProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserProjectWhereInput | UserProjectWhereInput[]
    OR?: UserProjectWhereInput[]
    NOT?: UserProjectWhereInput | UserProjectWhereInput[]
    name?: StringFilter<"UserProject"> | string
    description?: StringNullableFilter<"UserProject"> | string | null
    owner_id?: StringFilter<"UserProject"> | string
    is_active?: BoolFilter<"UserProject"> | boolean
    created_at?: DateTimeFilter<"UserProject"> | Date | string
    updated_at?: DateTimeFilter<"UserProject"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    shares?: ProjectShareListRelationFilter
    invites?: ProjectInviteListRelationFilter
    agencies?: AgencyListRelationFilter
    stops?: StopListRelationFilter
    routes?: RouteListRelationFilter
    trips?: TripListRelationFilter
    stopTimes?: StopTimeListRelationFilter
    calendars?: CalendarListRelationFilter
    calendarDates?: CalendarDateListRelationFilter
    fareAttributes?: FareAttributeListRelationFilter
    fareRules?: FareRuleListRelationFilter
    shapes?: ShapeListRelationFilter
    transfers?: TransferListRelationFilter
    frequencies?: FrequencyListRelationFilter
    levels?: LevelListRelationFilter
    pathways?: PathwayListRelationFilter
    feedInfo?: FeedInfoListRelationFilter
  }, "id">

  export type UserProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    owner_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserProjectCountOrderByAggregateInput
    _max?: UserProjectMaxOrderByAggregateInput
    _min?: UserProjectMinOrderByAggregateInput
  }

  export type UserProjectScalarWhereWithAggregatesInput = {
    AND?: UserProjectScalarWhereWithAggregatesInput | UserProjectScalarWhereWithAggregatesInput[]
    OR?: UserProjectScalarWhereWithAggregatesInput[]
    NOT?: UserProjectScalarWhereWithAggregatesInput | UserProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProject"> | string
    name?: StringWithAggregatesFilter<"UserProject"> | string
    description?: StringNullableWithAggregatesFilter<"UserProject"> | string | null
    owner_id?: StringWithAggregatesFilter<"UserProject"> | string
    is_active?: BoolWithAggregatesFilter<"UserProject"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"UserProject"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UserProject"> | Date | string
  }

  export type ProjectShareWhereInput = {
    AND?: ProjectShareWhereInput | ProjectShareWhereInput[]
    OR?: ProjectShareWhereInput[]
    NOT?: ProjectShareWhereInput | ProjectShareWhereInput[]
    id?: StringFilter<"ProjectShare"> | string
    project_id?: StringFilter<"ProjectShare"> | string
    user_id?: StringFilter<"ProjectShare"> | string
    role?: EnumProjectRoleFilter<"ProjectShare"> | $Enums.ProjectRole
    shared_by?: StringFilter<"ProjectShare"> | string
    created_at?: DateTimeFilter<"ProjectShare"> | Date | string
    updated_at?: DateTimeFilter<"ProjectShare"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectShareOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    shared_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    project_id_user_id?: ProjectShareProject_idUser_idCompoundUniqueInput
    AND?: ProjectShareWhereInput | ProjectShareWhereInput[]
    OR?: ProjectShareWhereInput[]
    NOT?: ProjectShareWhereInput | ProjectShareWhereInput[]
    project_id?: StringFilter<"ProjectShare"> | string
    user_id?: StringFilter<"ProjectShare"> | string
    role?: EnumProjectRoleFilter<"ProjectShare"> | $Enums.ProjectRole
    shared_by?: StringFilter<"ProjectShare"> | string
    created_at?: DateTimeFilter<"ProjectShare"> | Date | string
    updated_at?: DateTimeFilter<"ProjectShare"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "project_id_user_id">

  export type ProjectShareOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    shared_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProjectShareCountOrderByAggregateInput
    _max?: ProjectShareMaxOrderByAggregateInput
    _min?: ProjectShareMinOrderByAggregateInput
  }

  export type ProjectShareScalarWhereWithAggregatesInput = {
    AND?: ProjectShareScalarWhereWithAggregatesInput | ProjectShareScalarWhereWithAggregatesInput[]
    OR?: ProjectShareScalarWhereWithAggregatesInput[]
    NOT?: ProjectShareScalarWhereWithAggregatesInput | ProjectShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectShare"> | string
    project_id?: StringWithAggregatesFilter<"ProjectShare"> | string
    user_id?: StringWithAggregatesFilter<"ProjectShare"> | string
    role?: EnumProjectRoleWithAggregatesFilter<"ProjectShare"> | $Enums.ProjectRole
    shared_by?: StringWithAggregatesFilter<"ProjectShare"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProjectShare"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProjectShare"> | Date | string
  }

  export type ProjectInviteWhereInput = {
    AND?: ProjectInviteWhereInput | ProjectInviteWhereInput[]
    OR?: ProjectInviteWhereInput[]
    NOT?: ProjectInviteWhereInput | ProjectInviteWhereInput[]
    id?: StringFilter<"ProjectInvite"> | string
    project_id?: StringFilter<"ProjectInvite"> | string
    email?: StringFilter<"ProjectInvite"> | string
    user_id?: StringNullableFilter<"ProjectInvite"> | string | null
    role?: EnumProjectRoleFilter<"ProjectInvite"> | $Enums.ProjectRole
    token?: StringFilter<"ProjectInvite"> | string
    invited_by?: StringFilter<"ProjectInvite"> | string
    expires_at?: DateTimeFilter<"ProjectInvite"> | Date | string
    accepted_at?: DateTimeNullableFilter<"ProjectInvite"> | Date | string | null
    created_at?: DateTimeFilter<"ProjectInvite"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProjectInviteOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    email?: SortOrder
    user_id?: SortOrderInput | SortOrder
    role?: SortOrder
    token?: SortOrder
    invited_by?: SortOrder
    expires_at?: SortOrder
    accepted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: ProjectInviteWhereInput | ProjectInviteWhereInput[]
    OR?: ProjectInviteWhereInput[]
    NOT?: ProjectInviteWhereInput | ProjectInviteWhereInput[]
    project_id?: StringFilter<"ProjectInvite"> | string
    email?: StringFilter<"ProjectInvite"> | string
    user_id?: StringNullableFilter<"ProjectInvite"> | string | null
    role?: EnumProjectRoleFilter<"ProjectInvite"> | $Enums.ProjectRole
    invited_by?: StringFilter<"ProjectInvite"> | string
    expires_at?: DateTimeFilter<"ProjectInvite"> | Date | string
    accepted_at?: DateTimeNullableFilter<"ProjectInvite"> | Date | string | null
    created_at?: DateTimeFilter<"ProjectInvite"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "token">

  export type ProjectInviteOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    email?: SortOrder
    user_id?: SortOrderInput | SortOrder
    role?: SortOrder
    token?: SortOrder
    invited_by?: SortOrder
    expires_at?: SortOrder
    accepted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ProjectInviteCountOrderByAggregateInput
    _max?: ProjectInviteMaxOrderByAggregateInput
    _min?: ProjectInviteMinOrderByAggregateInput
  }

  export type ProjectInviteScalarWhereWithAggregatesInput = {
    AND?: ProjectInviteScalarWhereWithAggregatesInput | ProjectInviteScalarWhereWithAggregatesInput[]
    OR?: ProjectInviteScalarWhereWithAggregatesInput[]
    NOT?: ProjectInviteScalarWhereWithAggregatesInput | ProjectInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectInvite"> | string
    project_id?: StringWithAggregatesFilter<"ProjectInvite"> | string
    email?: StringWithAggregatesFilter<"ProjectInvite"> | string
    user_id?: StringNullableWithAggregatesFilter<"ProjectInvite"> | string | null
    role?: EnumProjectRoleWithAggregatesFilter<"ProjectInvite"> | $Enums.ProjectRole
    token?: StringWithAggregatesFilter<"ProjectInvite"> | string
    invited_by?: StringWithAggregatesFilter<"ProjectInvite"> | string
    expires_at?: DateTimeWithAggregatesFilter<"ProjectInvite"> | Date | string
    accepted_at?: DateTimeNullableWithAggregatesFilter<"ProjectInvite"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ProjectInvite"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    user_id?: StringFilter<"PasswordReset"> | string
    token?: StringFilter<"PasswordReset"> | string
    expires_at?: DateTimeFilter<"PasswordReset"> | Date | string
    used_at?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    created_at?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    user_id?: StringFilter<"PasswordReset"> | string
    expires_at?: DateTimeFilter<"PasswordReset"> | Date | string
    used_at?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    created_at?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordReset"> | string
    user_id?: StringWithAggregatesFilter<"PasswordReset"> | string
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    expires_at?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    used_at?: DateTimeNullableWithAggregatesFilter<"PasswordReset"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    user_id?: StringFilter<"UserSession"> | string
    session_token?: StringFilter<"UserSession"> | string
    expires_at?: DateTimeFilter<"UserSession"> | Date | string
    user_agent?: StringNullableFilter<"UserSession"> | string | null
    ip_address?: StringNullableFilter<"UserSession"> | string | null
    created_at?: DateTimeFilter<"UserSession"> | Date | string
    last_active?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    expires_at?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_active?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    session_token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    user_id?: StringFilter<"UserSession"> | string
    expires_at?: DateTimeFilter<"UserSession"> | Date | string
    user_agent?: StringNullableFilter<"UserSession"> | string | null
    ip_address?: StringNullableFilter<"UserSession"> | string | null
    created_at?: DateTimeFilter<"UserSession"> | Date | string
    last_active?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "session_token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    expires_at?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_active?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    user_id?: StringWithAggregatesFilter<"UserSession"> | string
    session_token?: StringWithAggregatesFilter<"UserSession"> | string
    expires_at?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    user_agent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    last_active?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    agency_id?: StringFilter<"Agency"> | string
    agency_name?: StringFilter<"Agency"> | string
    agency_url?: StringFilter<"Agency"> | string
    agency_timezone?: StringFilter<"Agency"> | string
    agency_lang?: StringNullableFilter<"Agency"> | string | null
    agency_phone?: StringNullableFilter<"Agency"> | string | null
    agency_fare_url?: StringNullableFilter<"Agency"> | string | null
    agency_email?: StringNullableFilter<"Agency"> | string | null
    project_id?: StringFilter<"Agency"> | string
    created_by?: StringNullableFilter<"Agency"> | string | null
    created_at?: DateTimeFilter<"Agency"> | Date | string
    updated_at?: DateTimeFilter<"Agency"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    routes?: RouteListRelationFilter
    fareAttributes?: FareAttributeListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    agency_url?: SortOrder
    agency_timezone?: SortOrder
    agency_lang?: SortOrderInput | SortOrder
    agency_phone?: SortOrderInput | SortOrder
    agency_fare_url?: SortOrderInput | SortOrder
    agency_email?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    routes?: RouteOrderByRelationAggregateInput
    fareAttributes?: FareAttributeOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agency_id?: string
    agency_id_project_id?: AgencyAgency_idProject_idCompoundUniqueInput
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    agency_name?: StringFilter<"Agency"> | string
    agency_url?: StringFilter<"Agency"> | string
    agency_timezone?: StringFilter<"Agency"> | string
    agency_lang?: StringNullableFilter<"Agency"> | string | null
    agency_phone?: StringNullableFilter<"Agency"> | string | null
    agency_fare_url?: StringNullableFilter<"Agency"> | string | null
    agency_email?: StringNullableFilter<"Agency"> | string | null
    project_id?: StringFilter<"Agency"> | string
    created_by?: StringNullableFilter<"Agency"> | string | null
    created_at?: DateTimeFilter<"Agency"> | Date | string
    updated_at?: DateTimeFilter<"Agency"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    routes?: RouteListRelationFilter
    fareAttributes?: FareAttributeListRelationFilter
  }, "id" | "agency_id" | "agency_id_project_id">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    agency_url?: SortOrder
    agency_timezone?: SortOrder
    agency_lang?: SortOrderInput | SortOrder
    agency_phone?: SortOrderInput | SortOrder
    agency_fare_url?: SortOrderInput | SortOrder
    agency_email?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    agency_id?: StringWithAggregatesFilter<"Agency"> | string
    agency_name?: StringWithAggregatesFilter<"Agency"> | string
    agency_url?: StringWithAggregatesFilter<"Agency"> | string
    agency_timezone?: StringWithAggregatesFilter<"Agency"> | string
    agency_lang?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    agency_phone?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    agency_fare_url?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    agency_email?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    project_id?: StringWithAggregatesFilter<"Agency"> | string
    created_by?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type StopWhereInput = {
    AND?: StopWhereInput | StopWhereInput[]
    OR?: StopWhereInput[]
    NOT?: StopWhereInput | StopWhereInput[]
    id?: StringFilter<"Stop"> | string
    stop_id?: StringFilter<"Stop"> | string
    stop_code?: StringNullableFilter<"Stop"> | string | null
    stop_name?: StringFilter<"Stop"> | string
    stop_desc?: StringNullableFilter<"Stop"> | string | null
    stop_lat?: FloatFilter<"Stop"> | number
    stop_lon?: FloatFilter<"Stop"> | number
    zone_id?: StringNullableFilter<"Stop"> | string | null
    stop_url?: StringNullableFilter<"Stop"> | string | null
    location_type?: IntNullableFilter<"Stop"> | number | null
    wheelchair_boarding?: IntNullableFilter<"Stop"> | number | null
    parent_station?: StringNullableFilter<"Stop"> | string | null
    platform_code?: StringNullableFilter<"Stop"> | string | null
    level_id?: StringNullableFilter<"Stop"> | string | null
    tts_stop_name?: StringNullableFilter<"Stop"> | string | null
    project_id?: StringFilter<"Stop"> | string
    created_by?: StringNullableFilter<"Stop"> | string | null
    created_at?: DateTimeFilter<"Stop"> | Date | string
    updated_at?: DateTimeFilter<"Stop"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    stopTimes?: StopTimeListRelationFilter
    transfers?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    pathways?: PathwayListRelationFilter
    pathwaysTo?: PathwayListRelationFilter
    parentStop?: XOR<StopNullableScalarRelationFilter, StopWhereInput> | null
    childStops?: StopListRelationFilter
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
  }

  export type StopOrderByWithRelationInput = {
    id?: SortOrder
    stop_id?: SortOrder
    stop_code?: SortOrderInput | SortOrder
    stop_name?: SortOrder
    stop_desc?: SortOrderInput | SortOrder
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    zone_id?: SortOrderInput | SortOrder
    stop_url?: SortOrderInput | SortOrder
    location_type?: SortOrderInput | SortOrder
    wheelchair_boarding?: SortOrderInput | SortOrder
    parent_station?: SortOrderInput | SortOrder
    platform_code?: SortOrderInput | SortOrder
    level_id?: SortOrderInput | SortOrder
    tts_stop_name?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    stopTimes?: StopTimeOrderByRelationAggregateInput
    transfers?: TransferOrderByRelationAggregateInput
    transfersTo?: TransferOrderByRelationAggregateInput
    pathways?: PathwayOrderByRelationAggregateInput
    pathwaysTo?: PathwayOrderByRelationAggregateInput
    parentStop?: StopOrderByWithRelationInput
    childStops?: StopOrderByRelationAggregateInput
    level?: LevelOrderByWithRelationInput
  }

  export type StopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stop_id?: string
    stop_id_project_id?: StopStop_idProject_idCompoundUniqueInput
    AND?: StopWhereInput | StopWhereInput[]
    OR?: StopWhereInput[]
    NOT?: StopWhereInput | StopWhereInput[]
    stop_code?: StringNullableFilter<"Stop"> | string | null
    stop_name?: StringFilter<"Stop"> | string
    stop_desc?: StringNullableFilter<"Stop"> | string | null
    stop_lat?: FloatFilter<"Stop"> | number
    stop_lon?: FloatFilter<"Stop"> | number
    zone_id?: StringNullableFilter<"Stop"> | string | null
    stop_url?: StringNullableFilter<"Stop"> | string | null
    location_type?: IntNullableFilter<"Stop"> | number | null
    wheelchair_boarding?: IntNullableFilter<"Stop"> | number | null
    parent_station?: StringNullableFilter<"Stop"> | string | null
    platform_code?: StringNullableFilter<"Stop"> | string | null
    level_id?: StringNullableFilter<"Stop"> | string | null
    tts_stop_name?: StringNullableFilter<"Stop"> | string | null
    project_id?: StringFilter<"Stop"> | string
    created_by?: StringNullableFilter<"Stop"> | string | null
    created_at?: DateTimeFilter<"Stop"> | Date | string
    updated_at?: DateTimeFilter<"Stop"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    stopTimes?: StopTimeListRelationFilter
    transfers?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    pathways?: PathwayListRelationFilter
    pathwaysTo?: PathwayListRelationFilter
    parentStop?: XOR<StopNullableScalarRelationFilter, StopWhereInput> | null
    childStops?: StopListRelationFilter
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
  }, "id" | "stop_id" | "stop_id_project_id">

  export type StopOrderByWithAggregationInput = {
    id?: SortOrder
    stop_id?: SortOrder
    stop_code?: SortOrderInput | SortOrder
    stop_name?: SortOrder
    stop_desc?: SortOrderInput | SortOrder
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    zone_id?: SortOrderInput | SortOrder
    stop_url?: SortOrderInput | SortOrder
    location_type?: SortOrderInput | SortOrder
    wheelchair_boarding?: SortOrderInput | SortOrder
    parent_station?: SortOrderInput | SortOrder
    platform_code?: SortOrderInput | SortOrder
    level_id?: SortOrderInput | SortOrder
    tts_stop_name?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StopCountOrderByAggregateInput
    _avg?: StopAvgOrderByAggregateInput
    _max?: StopMaxOrderByAggregateInput
    _min?: StopMinOrderByAggregateInput
    _sum?: StopSumOrderByAggregateInput
  }

  export type StopScalarWhereWithAggregatesInput = {
    AND?: StopScalarWhereWithAggregatesInput | StopScalarWhereWithAggregatesInput[]
    OR?: StopScalarWhereWithAggregatesInput[]
    NOT?: StopScalarWhereWithAggregatesInput | StopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stop"> | string
    stop_id?: StringWithAggregatesFilter<"Stop"> | string
    stop_code?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    stop_name?: StringWithAggregatesFilter<"Stop"> | string
    stop_desc?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    stop_lat?: FloatWithAggregatesFilter<"Stop"> | number
    stop_lon?: FloatWithAggregatesFilter<"Stop"> | number
    zone_id?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    stop_url?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    location_type?: IntNullableWithAggregatesFilter<"Stop"> | number | null
    wheelchair_boarding?: IntNullableWithAggregatesFilter<"Stop"> | number | null
    parent_station?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    platform_code?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    level_id?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    tts_stop_name?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    project_id?: StringWithAggregatesFilter<"Stop"> | string
    created_by?: StringNullableWithAggregatesFilter<"Stop"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Stop"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Stop"> | Date | string
  }

  export type RouteWhereInput = {
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    id?: StringFilter<"Route"> | string
    route_id?: StringFilter<"Route"> | string
    agency_id?: StringNullableFilter<"Route"> | string | null
    route_short_name?: StringNullableFilter<"Route"> | string | null
    route_long_name?: StringNullableFilter<"Route"> | string | null
    route_desc?: StringNullableFilter<"Route"> | string | null
    route_type?: IntFilter<"Route"> | number
    route_url?: StringNullableFilter<"Route"> | string | null
    route_color?: StringNullableFilter<"Route"> | string | null
    route_text_color?: StringNullableFilter<"Route"> | string | null
    route_sort_order?: IntNullableFilter<"Route"> | number | null
    continuous_pickup?: IntNullableFilter<"Route"> | number | null
    continuous_drop_off?: IntNullableFilter<"Route"> | number | null
    network_id?: StringNullableFilter<"Route"> | string | null
    project_id?: StringFilter<"Route"> | string
    created_by?: StringNullableFilter<"Route"> | string | null
    created_at?: DateTimeFilter<"Route"> | Date | string
    updated_at?: DateTimeFilter<"Route"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    trips?: TripListRelationFilter
    fareRules?: FareRuleListRelationFilter
  }

  export type RouteOrderByWithRelationInput = {
    id?: SortOrder
    route_id?: SortOrder
    agency_id?: SortOrderInput | SortOrder
    route_short_name?: SortOrderInput | SortOrder
    route_long_name?: SortOrderInput | SortOrder
    route_desc?: SortOrderInput | SortOrder
    route_type?: SortOrder
    route_url?: SortOrderInput | SortOrder
    route_color?: SortOrderInput | SortOrder
    route_text_color?: SortOrderInput | SortOrder
    route_sort_order?: SortOrderInput | SortOrder
    continuous_pickup?: SortOrderInput | SortOrder
    continuous_drop_off?: SortOrderInput | SortOrder
    network_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    trips?: TripOrderByRelationAggregateInput
    fareRules?: FareRuleOrderByRelationAggregateInput
  }

  export type RouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    route_id?: string
    route_id_project_id?: RouteRoute_idProject_idCompoundUniqueInput
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    agency_id?: StringNullableFilter<"Route"> | string | null
    route_short_name?: StringNullableFilter<"Route"> | string | null
    route_long_name?: StringNullableFilter<"Route"> | string | null
    route_desc?: StringNullableFilter<"Route"> | string | null
    route_type?: IntFilter<"Route"> | number
    route_url?: StringNullableFilter<"Route"> | string | null
    route_color?: StringNullableFilter<"Route"> | string | null
    route_text_color?: StringNullableFilter<"Route"> | string | null
    route_sort_order?: IntNullableFilter<"Route"> | number | null
    continuous_pickup?: IntNullableFilter<"Route"> | number | null
    continuous_drop_off?: IntNullableFilter<"Route"> | number | null
    network_id?: StringNullableFilter<"Route"> | string | null
    project_id?: StringFilter<"Route"> | string
    created_by?: StringNullableFilter<"Route"> | string | null
    created_at?: DateTimeFilter<"Route"> | Date | string
    updated_at?: DateTimeFilter<"Route"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    trips?: TripListRelationFilter
    fareRules?: FareRuleListRelationFilter
  }, "id" | "route_id" | "route_id_project_id">

  export type RouteOrderByWithAggregationInput = {
    id?: SortOrder
    route_id?: SortOrder
    agency_id?: SortOrderInput | SortOrder
    route_short_name?: SortOrderInput | SortOrder
    route_long_name?: SortOrderInput | SortOrder
    route_desc?: SortOrderInput | SortOrder
    route_type?: SortOrder
    route_url?: SortOrderInput | SortOrder
    route_color?: SortOrderInput | SortOrder
    route_text_color?: SortOrderInput | SortOrder
    route_sort_order?: SortOrderInput | SortOrder
    continuous_pickup?: SortOrderInput | SortOrder
    continuous_drop_off?: SortOrderInput | SortOrder
    network_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RouteCountOrderByAggregateInput
    _avg?: RouteAvgOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
    _sum?: RouteSumOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    OR?: RouteScalarWhereWithAggregatesInput[]
    NOT?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Route"> | string
    route_id?: StringWithAggregatesFilter<"Route"> | string
    agency_id?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_short_name?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_long_name?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_desc?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_type?: IntWithAggregatesFilter<"Route"> | number
    route_url?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_color?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_text_color?: StringNullableWithAggregatesFilter<"Route"> | string | null
    route_sort_order?: IntNullableWithAggregatesFilter<"Route"> | number | null
    continuous_pickup?: IntNullableWithAggregatesFilter<"Route"> | number | null
    continuous_drop_off?: IntNullableWithAggregatesFilter<"Route"> | number | null
    network_id?: StringNullableWithAggregatesFilter<"Route"> | string | null
    project_id?: StringWithAggregatesFilter<"Route"> | string
    created_by?: StringNullableWithAggregatesFilter<"Route"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Route"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Route"> | Date | string
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    trip_id?: StringFilter<"Trip"> | string
    route_id?: StringFilter<"Trip"> | string
    service_id?: StringFilter<"Trip"> | string
    trip_headsign?: StringNullableFilter<"Trip"> | string | null
    trip_short_name?: StringNullableFilter<"Trip"> | string | null
    direction_id?: IntNullableFilter<"Trip"> | number | null
    block_id?: StringNullableFilter<"Trip"> | string | null
    shape_id?: StringNullableFilter<"Trip"> | string | null
    wheelchair_accessible?: IntNullableFilter<"Trip"> | number | null
    bikes_allowed?: IntNullableFilter<"Trip"> | number | null
    project_id?: StringFilter<"Trip"> | string
    created_by?: StringNullableFilter<"Trip"> | string | null
    created_at?: DateTimeFilter<"Trip"> | Date | string
    updated_at?: DateTimeFilter<"Trip"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    calendar?: XOR<CalendarNullableScalarRelationFilter, CalendarWhereInput> | null
    stopTimes?: StopTimeListRelationFilter
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    trip_id?: SortOrder
    route_id?: SortOrder
    service_id?: SortOrder
    trip_headsign?: SortOrderInput | SortOrder
    trip_short_name?: SortOrderInput | SortOrder
    direction_id?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    shape_id?: SortOrderInput | SortOrder
    wheelchair_accessible?: SortOrderInput | SortOrder
    bikes_allowed?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
    calendar?: CalendarOrderByWithRelationInput
    stopTimes?: StopTimeOrderByRelationAggregateInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trip_id?: string
    trip_id_project_id?: TripTrip_idProject_idCompoundUniqueInput
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    route_id?: StringFilter<"Trip"> | string
    service_id?: StringFilter<"Trip"> | string
    trip_headsign?: StringNullableFilter<"Trip"> | string | null
    trip_short_name?: StringNullableFilter<"Trip"> | string | null
    direction_id?: IntNullableFilter<"Trip"> | number | null
    block_id?: StringNullableFilter<"Trip"> | string | null
    shape_id?: StringNullableFilter<"Trip"> | string | null
    wheelchair_accessible?: IntNullableFilter<"Trip"> | number | null
    bikes_allowed?: IntNullableFilter<"Trip"> | number | null
    project_id?: StringFilter<"Trip"> | string
    created_by?: StringNullableFilter<"Trip"> | string | null
    created_at?: DateTimeFilter<"Trip"> | Date | string
    updated_at?: DateTimeFilter<"Trip"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    calendar?: XOR<CalendarNullableScalarRelationFilter, CalendarWhereInput> | null
    stopTimes?: StopTimeListRelationFilter
  }, "id" | "trip_id" | "trip_id_project_id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    trip_id?: SortOrder
    route_id?: SortOrder
    service_id?: SortOrder
    trip_headsign?: SortOrderInput | SortOrder
    trip_short_name?: SortOrderInput | SortOrder
    direction_id?: SortOrderInput | SortOrder
    block_id?: SortOrderInput | SortOrder
    shape_id?: SortOrderInput | SortOrder
    wheelchair_accessible?: SortOrderInput | SortOrder
    bikes_allowed?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TripCountOrderByAggregateInput
    _avg?: TripAvgOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
    _sum?: TripSumOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    trip_id?: StringWithAggregatesFilter<"Trip"> | string
    route_id?: StringWithAggregatesFilter<"Trip"> | string
    service_id?: StringWithAggregatesFilter<"Trip"> | string
    trip_headsign?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    trip_short_name?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    direction_id?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    block_id?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    shape_id?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    wheelchair_accessible?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    bikes_allowed?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    project_id?: StringWithAggregatesFilter<"Trip"> | string
    created_by?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
  }

  export type StopTimeWhereInput = {
    AND?: StopTimeWhereInput | StopTimeWhereInput[]
    OR?: StopTimeWhereInput[]
    NOT?: StopTimeWhereInput | StopTimeWhereInput[]
    id?: StringFilter<"StopTime"> | string
    trip_id?: StringFilter<"StopTime"> | string
    stop_id?: StringFilter<"StopTime"> | string
    arrival_time?: StringNullableFilter<"StopTime"> | string | null
    departure_time?: StringNullableFilter<"StopTime"> | string | null
    stop_sequence?: IntFilter<"StopTime"> | number
    stop_headsign?: StringNullableFilter<"StopTime"> | string | null
    pickup_type?: IntNullableFilter<"StopTime"> | number | null
    drop_off_type?: IntNullableFilter<"StopTime"> | number | null
    continuous_pickup?: IntNullableFilter<"StopTime"> | number | null
    continuous_drop_off?: IntNullableFilter<"StopTime"> | number | null
    shape_dist_traveled?: FloatNullableFilter<"StopTime"> | number | null
    timepoint?: IntNullableFilter<"StopTime"> | number | null
    project_id?: StringFilter<"StopTime"> | string
    created_by?: StringNullableFilter<"StopTime"> | string | null
    created_at?: DateTimeFilter<"StopTime"> | Date | string
    updated_at?: DateTimeFilter<"StopTime"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
    stop?: XOR<StopScalarRelationFilter, StopWhereInput>
  }

  export type StopTimeOrderByWithRelationInput = {
    id?: SortOrder
    trip_id?: SortOrder
    stop_id?: SortOrder
    arrival_time?: SortOrderInput | SortOrder
    departure_time?: SortOrderInput | SortOrder
    stop_sequence?: SortOrder
    stop_headsign?: SortOrderInput | SortOrder
    pickup_type?: SortOrderInput | SortOrder
    drop_off_type?: SortOrderInput | SortOrder
    continuous_pickup?: SortOrderInput | SortOrder
    continuous_drop_off?: SortOrderInput | SortOrder
    shape_dist_traveled?: SortOrderInput | SortOrder
    timepoint?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    trip?: TripOrderByWithRelationInput
    stop?: StopOrderByWithRelationInput
  }

  export type StopTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trip_id_stop_sequence_project_id?: StopTimeTrip_idStop_sequenceProject_idCompoundUniqueInput
    AND?: StopTimeWhereInput | StopTimeWhereInput[]
    OR?: StopTimeWhereInput[]
    NOT?: StopTimeWhereInput | StopTimeWhereInput[]
    trip_id?: StringFilter<"StopTime"> | string
    stop_id?: StringFilter<"StopTime"> | string
    arrival_time?: StringNullableFilter<"StopTime"> | string | null
    departure_time?: StringNullableFilter<"StopTime"> | string | null
    stop_sequence?: IntFilter<"StopTime"> | number
    stop_headsign?: StringNullableFilter<"StopTime"> | string | null
    pickup_type?: IntNullableFilter<"StopTime"> | number | null
    drop_off_type?: IntNullableFilter<"StopTime"> | number | null
    continuous_pickup?: IntNullableFilter<"StopTime"> | number | null
    continuous_drop_off?: IntNullableFilter<"StopTime"> | number | null
    shape_dist_traveled?: FloatNullableFilter<"StopTime"> | number | null
    timepoint?: IntNullableFilter<"StopTime"> | number | null
    project_id?: StringFilter<"StopTime"> | string
    created_by?: StringNullableFilter<"StopTime"> | string | null
    created_at?: DateTimeFilter<"StopTime"> | Date | string
    updated_at?: DateTimeFilter<"StopTime"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
    stop?: XOR<StopScalarRelationFilter, StopWhereInput>
  }, "id" | "trip_id_stop_sequence_project_id">

  export type StopTimeOrderByWithAggregationInput = {
    id?: SortOrder
    trip_id?: SortOrder
    stop_id?: SortOrder
    arrival_time?: SortOrderInput | SortOrder
    departure_time?: SortOrderInput | SortOrder
    stop_sequence?: SortOrder
    stop_headsign?: SortOrderInput | SortOrder
    pickup_type?: SortOrderInput | SortOrder
    drop_off_type?: SortOrderInput | SortOrder
    continuous_pickup?: SortOrderInput | SortOrder
    continuous_drop_off?: SortOrderInput | SortOrder
    shape_dist_traveled?: SortOrderInput | SortOrder
    timepoint?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StopTimeCountOrderByAggregateInput
    _avg?: StopTimeAvgOrderByAggregateInput
    _max?: StopTimeMaxOrderByAggregateInput
    _min?: StopTimeMinOrderByAggregateInput
    _sum?: StopTimeSumOrderByAggregateInput
  }

  export type StopTimeScalarWhereWithAggregatesInput = {
    AND?: StopTimeScalarWhereWithAggregatesInput | StopTimeScalarWhereWithAggregatesInput[]
    OR?: StopTimeScalarWhereWithAggregatesInput[]
    NOT?: StopTimeScalarWhereWithAggregatesInput | StopTimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StopTime"> | string
    trip_id?: StringWithAggregatesFilter<"StopTime"> | string
    stop_id?: StringWithAggregatesFilter<"StopTime"> | string
    arrival_time?: StringNullableWithAggregatesFilter<"StopTime"> | string | null
    departure_time?: StringNullableWithAggregatesFilter<"StopTime"> | string | null
    stop_sequence?: IntWithAggregatesFilter<"StopTime"> | number
    stop_headsign?: StringNullableWithAggregatesFilter<"StopTime"> | string | null
    pickup_type?: IntNullableWithAggregatesFilter<"StopTime"> | number | null
    drop_off_type?: IntNullableWithAggregatesFilter<"StopTime"> | number | null
    continuous_pickup?: IntNullableWithAggregatesFilter<"StopTime"> | number | null
    continuous_drop_off?: IntNullableWithAggregatesFilter<"StopTime"> | number | null
    shape_dist_traveled?: FloatNullableWithAggregatesFilter<"StopTime"> | number | null
    timepoint?: IntNullableWithAggregatesFilter<"StopTime"> | number | null
    project_id?: StringWithAggregatesFilter<"StopTime"> | string
    created_by?: StringNullableWithAggregatesFilter<"StopTime"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"StopTime"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"StopTime"> | Date | string
  }

  export type CalendarWhereInput = {
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    service_id?: StringFilter<"Calendar"> | string
    monday?: IntFilter<"Calendar"> | number
    tuesday?: IntFilter<"Calendar"> | number
    wednesday?: IntFilter<"Calendar"> | number
    thursday?: IntFilter<"Calendar"> | number
    friday?: IntFilter<"Calendar"> | number
    saturday?: IntFilter<"Calendar"> | number
    sunday?: IntFilter<"Calendar"> | number
    start_date?: StringFilter<"Calendar"> | string
    end_date?: StringFilter<"Calendar"> | string
    project_id?: StringFilter<"Calendar"> | string
    created_by?: StringNullableFilter<"Calendar"> | string | null
    created_at?: DateTimeFilter<"Calendar"> | Date | string
    updated_at?: DateTimeFilter<"Calendar"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    trips?: TripListRelationFilter
    exceptions?: CalendarDateListRelationFilter
  }

  export type CalendarOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    trips?: TripOrderByRelationAggregateInput
    exceptions?: CalendarDateOrderByRelationAggregateInput
  }

  export type CalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_id?: string
    service_id_project_id?: CalendarService_idProject_idCompoundUniqueInput
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    monday?: IntFilter<"Calendar"> | number
    tuesday?: IntFilter<"Calendar"> | number
    wednesday?: IntFilter<"Calendar"> | number
    thursday?: IntFilter<"Calendar"> | number
    friday?: IntFilter<"Calendar"> | number
    saturday?: IntFilter<"Calendar"> | number
    sunday?: IntFilter<"Calendar"> | number
    start_date?: StringFilter<"Calendar"> | string
    end_date?: StringFilter<"Calendar"> | string
    project_id?: StringFilter<"Calendar"> | string
    created_by?: StringNullableFilter<"Calendar"> | string | null
    created_at?: DateTimeFilter<"Calendar"> | Date | string
    updated_at?: DateTimeFilter<"Calendar"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    trips?: TripListRelationFilter
    exceptions?: CalendarDateListRelationFilter
  }, "id" | "service_id" | "service_id_project_id">

  export type CalendarOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CalendarCountOrderByAggregateInput
    _avg?: CalendarAvgOrderByAggregateInput
    _max?: CalendarMaxOrderByAggregateInput
    _min?: CalendarMinOrderByAggregateInput
    _sum?: CalendarSumOrderByAggregateInput
  }

  export type CalendarScalarWhereWithAggregatesInput = {
    AND?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    OR?: CalendarScalarWhereWithAggregatesInput[]
    NOT?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Calendar"> | string
    service_id?: StringWithAggregatesFilter<"Calendar"> | string
    monday?: IntWithAggregatesFilter<"Calendar"> | number
    tuesday?: IntWithAggregatesFilter<"Calendar"> | number
    wednesday?: IntWithAggregatesFilter<"Calendar"> | number
    thursday?: IntWithAggregatesFilter<"Calendar"> | number
    friday?: IntWithAggregatesFilter<"Calendar"> | number
    saturday?: IntWithAggregatesFilter<"Calendar"> | number
    sunday?: IntWithAggregatesFilter<"Calendar"> | number
    start_date?: StringWithAggregatesFilter<"Calendar"> | string
    end_date?: StringWithAggregatesFilter<"Calendar"> | string
    project_id?: StringWithAggregatesFilter<"Calendar"> | string
    created_by?: StringNullableWithAggregatesFilter<"Calendar"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
  }

  export type CalendarDateWhereInput = {
    AND?: CalendarDateWhereInput | CalendarDateWhereInput[]
    OR?: CalendarDateWhereInput[]
    NOT?: CalendarDateWhereInput | CalendarDateWhereInput[]
    id?: StringFilter<"CalendarDate"> | string
    service_id?: StringFilter<"CalendarDate"> | string
    date?: StringFilter<"CalendarDate"> | string
    exception_type?: IntFilter<"CalendarDate"> | number
    project_id?: StringFilter<"CalendarDate"> | string
    created_by?: StringNullableFilter<"CalendarDate"> | string | null
    created_at?: DateTimeFilter<"CalendarDate"> | Date | string
    updated_at?: DateTimeFilter<"CalendarDate"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    calendar?: XOR<CalendarScalarRelationFilter, CalendarWhereInput>
  }

  export type CalendarDateOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    date?: SortOrder
    exception_type?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    calendar?: CalendarOrderByWithRelationInput
  }

  export type CalendarDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_id_date_project_id?: CalendarDateService_idDateProject_idCompoundUniqueInput
    AND?: CalendarDateWhereInput | CalendarDateWhereInput[]
    OR?: CalendarDateWhereInput[]
    NOT?: CalendarDateWhereInput | CalendarDateWhereInput[]
    service_id?: StringFilter<"CalendarDate"> | string
    date?: StringFilter<"CalendarDate"> | string
    exception_type?: IntFilter<"CalendarDate"> | number
    project_id?: StringFilter<"CalendarDate"> | string
    created_by?: StringNullableFilter<"CalendarDate"> | string | null
    created_at?: DateTimeFilter<"CalendarDate"> | Date | string
    updated_at?: DateTimeFilter<"CalendarDate"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    calendar?: XOR<CalendarScalarRelationFilter, CalendarWhereInput>
  }, "id" | "service_id_date_project_id">

  export type CalendarDateOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    date?: SortOrder
    exception_type?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CalendarDateCountOrderByAggregateInput
    _avg?: CalendarDateAvgOrderByAggregateInput
    _max?: CalendarDateMaxOrderByAggregateInput
    _min?: CalendarDateMinOrderByAggregateInput
    _sum?: CalendarDateSumOrderByAggregateInput
  }

  export type CalendarDateScalarWhereWithAggregatesInput = {
    AND?: CalendarDateScalarWhereWithAggregatesInput | CalendarDateScalarWhereWithAggregatesInput[]
    OR?: CalendarDateScalarWhereWithAggregatesInput[]
    NOT?: CalendarDateScalarWhereWithAggregatesInput | CalendarDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarDate"> | string
    service_id?: StringWithAggregatesFilter<"CalendarDate"> | string
    date?: StringWithAggregatesFilter<"CalendarDate"> | string
    exception_type?: IntWithAggregatesFilter<"CalendarDate"> | number
    project_id?: StringWithAggregatesFilter<"CalendarDate"> | string
    created_by?: StringNullableWithAggregatesFilter<"CalendarDate"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CalendarDate"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CalendarDate"> | Date | string
  }

  export type FareAttributeWhereInput = {
    AND?: FareAttributeWhereInput | FareAttributeWhereInput[]
    OR?: FareAttributeWhereInput[]
    NOT?: FareAttributeWhereInput | FareAttributeWhereInput[]
    id?: StringFilter<"FareAttribute"> | string
    fare_id?: StringFilter<"FareAttribute"> | string
    price?: FloatFilter<"FareAttribute"> | number
    currency_type?: StringFilter<"FareAttribute"> | string
    payment_method?: IntFilter<"FareAttribute"> | number
    transfers?: IntNullableFilter<"FareAttribute"> | number | null
    agency_id?: StringNullableFilter<"FareAttribute"> | string | null
    transfer_duration?: IntNullableFilter<"FareAttribute"> | number | null
    project_id?: StringFilter<"FareAttribute"> | string
    created_by?: StringNullableFilter<"FareAttribute"> | string | null
    created_at?: DateTimeFilter<"FareAttribute"> | Date | string
    updated_at?: DateTimeFilter<"FareAttribute"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    fareRules?: FareRuleListRelationFilter
  }

  export type FareAttributeOrderByWithRelationInput = {
    id?: SortOrder
    fare_id?: SortOrder
    price?: SortOrder
    currency_type?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrderInput | SortOrder
    agency_id?: SortOrderInput | SortOrder
    transfer_duration?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    agency?: AgencyOrderByWithRelationInput
    fareRules?: FareRuleOrderByRelationAggregateInput
  }

  export type FareAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fare_id?: string
    fare_id_project_id?: FareAttributeFare_idProject_idCompoundUniqueInput
    AND?: FareAttributeWhereInput | FareAttributeWhereInput[]
    OR?: FareAttributeWhereInput[]
    NOT?: FareAttributeWhereInput | FareAttributeWhereInput[]
    price?: FloatFilter<"FareAttribute"> | number
    currency_type?: StringFilter<"FareAttribute"> | string
    payment_method?: IntFilter<"FareAttribute"> | number
    transfers?: IntNullableFilter<"FareAttribute"> | number | null
    agency_id?: StringNullableFilter<"FareAttribute"> | string | null
    transfer_duration?: IntNullableFilter<"FareAttribute"> | number | null
    project_id?: StringFilter<"FareAttribute"> | string
    created_by?: StringNullableFilter<"FareAttribute"> | string | null
    created_at?: DateTimeFilter<"FareAttribute"> | Date | string
    updated_at?: DateTimeFilter<"FareAttribute"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    fareRules?: FareRuleListRelationFilter
  }, "id" | "fare_id" | "fare_id_project_id">

  export type FareAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    fare_id?: SortOrder
    price?: SortOrder
    currency_type?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrderInput | SortOrder
    agency_id?: SortOrderInput | SortOrder
    transfer_duration?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FareAttributeCountOrderByAggregateInput
    _avg?: FareAttributeAvgOrderByAggregateInput
    _max?: FareAttributeMaxOrderByAggregateInput
    _min?: FareAttributeMinOrderByAggregateInput
    _sum?: FareAttributeSumOrderByAggregateInput
  }

  export type FareAttributeScalarWhereWithAggregatesInput = {
    AND?: FareAttributeScalarWhereWithAggregatesInput | FareAttributeScalarWhereWithAggregatesInput[]
    OR?: FareAttributeScalarWhereWithAggregatesInput[]
    NOT?: FareAttributeScalarWhereWithAggregatesInput | FareAttributeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FareAttribute"> | string
    fare_id?: StringWithAggregatesFilter<"FareAttribute"> | string
    price?: FloatWithAggregatesFilter<"FareAttribute"> | number
    currency_type?: StringWithAggregatesFilter<"FareAttribute"> | string
    payment_method?: IntWithAggregatesFilter<"FareAttribute"> | number
    transfers?: IntNullableWithAggregatesFilter<"FareAttribute"> | number | null
    agency_id?: StringNullableWithAggregatesFilter<"FareAttribute"> | string | null
    transfer_duration?: IntNullableWithAggregatesFilter<"FareAttribute"> | number | null
    project_id?: StringWithAggregatesFilter<"FareAttribute"> | string
    created_by?: StringNullableWithAggregatesFilter<"FareAttribute"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"FareAttribute"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FareAttribute"> | Date | string
  }

  export type FareRuleWhereInput = {
    AND?: FareRuleWhereInput | FareRuleWhereInput[]
    OR?: FareRuleWhereInput[]
    NOT?: FareRuleWhereInput | FareRuleWhereInput[]
    id?: StringFilter<"FareRule"> | string
    fare_id?: StringFilter<"FareRule"> | string
    route_id?: StringNullableFilter<"FareRule"> | string | null
    origin_id?: StringNullableFilter<"FareRule"> | string | null
    destination_id?: StringNullableFilter<"FareRule"> | string | null
    contains_id?: StringNullableFilter<"FareRule"> | string | null
    project_id?: StringFilter<"FareRule"> | string
    created_by?: StringNullableFilter<"FareRule"> | string | null
    created_at?: DateTimeFilter<"FareRule"> | Date | string
    updated_at?: DateTimeFilter<"FareRule"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    fare_attribute?: XOR<FareAttributeScalarRelationFilter, FareAttributeWhereInput>
    route?: XOR<RouteNullableScalarRelationFilter, RouteWhereInput> | null
  }

  export type FareRuleOrderByWithRelationInput = {
    id?: SortOrder
    fare_id?: SortOrder
    route_id?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    destination_id?: SortOrderInput | SortOrder
    contains_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    fare_attribute?: FareAttributeOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
  }

  export type FareRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FareRuleWhereInput | FareRuleWhereInput[]
    OR?: FareRuleWhereInput[]
    NOT?: FareRuleWhereInput | FareRuleWhereInput[]
    fare_id?: StringFilter<"FareRule"> | string
    route_id?: StringNullableFilter<"FareRule"> | string | null
    origin_id?: StringNullableFilter<"FareRule"> | string | null
    destination_id?: StringNullableFilter<"FareRule"> | string | null
    contains_id?: StringNullableFilter<"FareRule"> | string | null
    project_id?: StringFilter<"FareRule"> | string
    created_by?: StringNullableFilter<"FareRule"> | string | null
    created_at?: DateTimeFilter<"FareRule"> | Date | string
    updated_at?: DateTimeFilter<"FareRule"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    fare_attribute?: XOR<FareAttributeScalarRelationFilter, FareAttributeWhereInput>
    route?: XOR<RouteNullableScalarRelationFilter, RouteWhereInput> | null
  }, "id">

  export type FareRuleOrderByWithAggregationInput = {
    id?: SortOrder
    fare_id?: SortOrder
    route_id?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    destination_id?: SortOrderInput | SortOrder
    contains_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FareRuleCountOrderByAggregateInput
    _max?: FareRuleMaxOrderByAggregateInput
    _min?: FareRuleMinOrderByAggregateInput
  }

  export type FareRuleScalarWhereWithAggregatesInput = {
    AND?: FareRuleScalarWhereWithAggregatesInput | FareRuleScalarWhereWithAggregatesInput[]
    OR?: FareRuleScalarWhereWithAggregatesInput[]
    NOT?: FareRuleScalarWhereWithAggregatesInput | FareRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FareRule"> | string
    fare_id?: StringWithAggregatesFilter<"FareRule"> | string
    route_id?: StringNullableWithAggregatesFilter<"FareRule"> | string | null
    origin_id?: StringNullableWithAggregatesFilter<"FareRule"> | string | null
    destination_id?: StringNullableWithAggregatesFilter<"FareRule"> | string | null
    contains_id?: StringNullableWithAggregatesFilter<"FareRule"> | string | null
    project_id?: StringWithAggregatesFilter<"FareRule"> | string
    created_by?: StringNullableWithAggregatesFilter<"FareRule"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"FareRule"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FareRule"> | Date | string
  }

  export type ShapeWhereInput = {
    AND?: ShapeWhereInput | ShapeWhereInput[]
    OR?: ShapeWhereInput[]
    NOT?: ShapeWhereInput | ShapeWhereInput[]
    id?: StringFilter<"Shape"> | string
    shape_id?: StringFilter<"Shape"> | string
    shape_pt_sequence?: IntFilter<"Shape"> | number
    shape_pt_lat?: FloatFilter<"Shape"> | number
    shape_pt_lon?: FloatFilter<"Shape"> | number
    shape_dist_traveled?: FloatNullableFilter<"Shape"> | number | null
    project_id?: StringFilter<"Shape"> | string
    created_by?: StringNullableFilter<"Shape"> | string | null
    created_at?: DateTimeFilter<"Shape"> | Date | string
    updated_at?: DateTimeFilter<"Shape"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
  }

  export type ShapeOrderByWithRelationInput = {
    id?: SortOrder
    shape_id?: SortOrder
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
  }

  export type ShapeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shape_id_shape_pt_sequence_project_id?: ShapeShape_idShape_pt_sequenceProject_idCompoundUniqueInput
    AND?: ShapeWhereInput | ShapeWhereInput[]
    OR?: ShapeWhereInput[]
    NOT?: ShapeWhereInput | ShapeWhereInput[]
    shape_id?: StringFilter<"Shape"> | string
    shape_pt_sequence?: IntFilter<"Shape"> | number
    shape_pt_lat?: FloatFilter<"Shape"> | number
    shape_pt_lon?: FloatFilter<"Shape"> | number
    shape_dist_traveled?: FloatNullableFilter<"Shape"> | number | null
    project_id?: StringFilter<"Shape"> | string
    created_by?: StringNullableFilter<"Shape"> | string | null
    created_at?: DateTimeFilter<"Shape"> | Date | string
    updated_at?: DateTimeFilter<"Shape"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
  }, "id" | "shape_id_shape_pt_sequence_project_id">

  export type ShapeOrderByWithAggregationInput = {
    id?: SortOrder
    shape_id?: SortOrder
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ShapeCountOrderByAggregateInput
    _avg?: ShapeAvgOrderByAggregateInput
    _max?: ShapeMaxOrderByAggregateInput
    _min?: ShapeMinOrderByAggregateInput
    _sum?: ShapeSumOrderByAggregateInput
  }

  export type ShapeScalarWhereWithAggregatesInput = {
    AND?: ShapeScalarWhereWithAggregatesInput | ShapeScalarWhereWithAggregatesInput[]
    OR?: ShapeScalarWhereWithAggregatesInput[]
    NOT?: ShapeScalarWhereWithAggregatesInput | ShapeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shape"> | string
    shape_id?: StringWithAggregatesFilter<"Shape"> | string
    shape_pt_sequence?: IntWithAggregatesFilter<"Shape"> | number
    shape_pt_lat?: FloatWithAggregatesFilter<"Shape"> | number
    shape_pt_lon?: FloatWithAggregatesFilter<"Shape"> | number
    shape_dist_traveled?: FloatNullableWithAggregatesFilter<"Shape"> | number | null
    project_id?: StringWithAggregatesFilter<"Shape"> | string
    created_by?: StringNullableWithAggregatesFilter<"Shape"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Shape"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Shape"> | Date | string
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    from_stop_id?: StringFilter<"Transfer"> | string
    to_stop_id?: StringFilter<"Transfer"> | string
    transfer_type?: IntFilter<"Transfer"> | number
    min_transfer_time?: IntNullableFilter<"Transfer"> | number | null
    project_id?: StringFilter<"Transfer"> | string
    created_by?: StringNullableFilter<"Transfer"> | string | null
    created_at?: DateTimeFilter<"Transfer"> | Date | string
    updated_at?: DateTimeFilter<"Transfer"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    fromStop?: XOR<StopScalarRelationFilter, StopWhereInput>
    toStop?: XOR<StopScalarRelationFilter, StopWhereInput>
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    transfer_type?: SortOrder
    min_transfer_time?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    fromStop?: StopOrderByWithRelationInput
    toStop?: StopOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    from_stop_id_to_stop_id_project_id?: TransferFrom_stop_idTo_stop_idProject_idCompoundUniqueInput
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    from_stop_id?: StringFilter<"Transfer"> | string
    to_stop_id?: StringFilter<"Transfer"> | string
    transfer_type?: IntFilter<"Transfer"> | number
    min_transfer_time?: IntNullableFilter<"Transfer"> | number | null
    project_id?: StringFilter<"Transfer"> | string
    created_by?: StringNullableFilter<"Transfer"> | string | null
    created_at?: DateTimeFilter<"Transfer"> | Date | string
    updated_at?: DateTimeFilter<"Transfer"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    fromStop?: XOR<StopScalarRelationFilter, StopWhereInput>
    toStop?: XOR<StopScalarRelationFilter, StopWhereInput>
  }, "id" | "from_stop_id_to_stop_id_project_id">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    transfer_type?: SortOrder
    min_transfer_time?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    from_stop_id?: StringWithAggregatesFilter<"Transfer"> | string
    to_stop_id?: StringWithAggregatesFilter<"Transfer"> | string
    transfer_type?: IntWithAggregatesFilter<"Transfer"> | number
    min_transfer_time?: IntNullableWithAggregatesFilter<"Transfer"> | number | null
    project_id?: StringWithAggregatesFilter<"Transfer"> | string
    created_by?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type FrequencyWhereInput = {
    AND?: FrequencyWhereInput | FrequencyWhereInput[]
    OR?: FrequencyWhereInput[]
    NOT?: FrequencyWhereInput | FrequencyWhereInput[]
    id?: StringFilter<"Frequency"> | string
    trip_id?: StringFilter<"Frequency"> | string
    start_time?: StringFilter<"Frequency"> | string
    end_time?: StringFilter<"Frequency"> | string
    headway_secs?: IntFilter<"Frequency"> | number
    exact_times?: IntNullableFilter<"Frequency"> | number | null
    project_id?: StringFilter<"Frequency"> | string
    created_by?: StringNullableFilter<"Frequency"> | string | null
    created_at?: DateTimeFilter<"Frequency"> | Date | string
    updated_at?: DateTimeFilter<"Frequency"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
  }

  export type FrequencyOrderByWithRelationInput = {
    id?: SortOrder
    trip_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    headway_secs?: SortOrder
    exact_times?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
  }

  export type FrequencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trip_id?: string
    AND?: FrequencyWhereInput | FrequencyWhereInput[]
    OR?: FrequencyWhereInput[]
    NOT?: FrequencyWhereInput | FrequencyWhereInput[]
    start_time?: StringFilter<"Frequency"> | string
    end_time?: StringFilter<"Frequency"> | string
    headway_secs?: IntFilter<"Frequency"> | number
    exact_times?: IntNullableFilter<"Frequency"> | number | null
    project_id?: StringFilter<"Frequency"> | string
    created_by?: StringNullableFilter<"Frequency"> | string | null
    created_at?: DateTimeFilter<"Frequency"> | Date | string
    updated_at?: DateTimeFilter<"Frequency"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
  }, "id" | "trip_id">

  export type FrequencyOrderByWithAggregationInput = {
    id?: SortOrder
    trip_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    headway_secs?: SortOrder
    exact_times?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FrequencyCountOrderByAggregateInput
    _avg?: FrequencyAvgOrderByAggregateInput
    _max?: FrequencyMaxOrderByAggregateInput
    _min?: FrequencyMinOrderByAggregateInput
    _sum?: FrequencySumOrderByAggregateInput
  }

  export type FrequencyScalarWhereWithAggregatesInput = {
    AND?: FrequencyScalarWhereWithAggregatesInput | FrequencyScalarWhereWithAggregatesInput[]
    OR?: FrequencyScalarWhereWithAggregatesInput[]
    NOT?: FrequencyScalarWhereWithAggregatesInput | FrequencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Frequency"> | string
    trip_id?: StringWithAggregatesFilter<"Frequency"> | string
    start_time?: StringWithAggregatesFilter<"Frequency"> | string
    end_time?: StringWithAggregatesFilter<"Frequency"> | string
    headway_secs?: IntWithAggregatesFilter<"Frequency"> | number
    exact_times?: IntNullableWithAggregatesFilter<"Frequency"> | number | null
    project_id?: StringWithAggregatesFilter<"Frequency"> | string
    created_by?: StringNullableWithAggregatesFilter<"Frequency"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Frequency"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Frequency"> | Date | string
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    level_id?: StringFilter<"Level"> | string
    level_index?: FloatFilter<"Level"> | number
    level_name?: StringNullableFilter<"Level"> | string | null
    project_id?: StringFilter<"Level"> | string
    created_by?: StringNullableFilter<"Level"> | string | null
    created_at?: DateTimeFilter<"Level"> | Date | string
    updated_at?: DateTimeFilter<"Level"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    stops?: StopListRelationFilter
    pathways?: PathwayListRelationFilter
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    level_id?: SortOrder
    level_index?: SortOrder
    level_name?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    stops?: StopOrderByRelationAggregateInput
    pathways?: PathwayOrderByRelationAggregateInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    level_id?: string
    level_id_project_id?: LevelLevel_idProject_idCompoundUniqueInput
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    level_index?: FloatFilter<"Level"> | number
    level_name?: StringNullableFilter<"Level"> | string | null
    project_id?: StringFilter<"Level"> | string
    created_by?: StringNullableFilter<"Level"> | string | null
    created_at?: DateTimeFilter<"Level"> | Date | string
    updated_at?: DateTimeFilter<"Level"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    stops?: StopListRelationFilter
    pathways?: PathwayListRelationFilter
  }, "id" | "level_id" | "level_id_project_id">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    level_id?: SortOrder
    level_index?: SortOrder
    level_name?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _avg?: LevelAvgOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
    _sum?: LevelSumOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    level_id?: StringWithAggregatesFilter<"Level"> | string
    level_index?: FloatWithAggregatesFilter<"Level"> | number
    level_name?: StringNullableWithAggregatesFilter<"Level"> | string | null
    project_id?: StringWithAggregatesFilter<"Level"> | string
    created_by?: StringNullableWithAggregatesFilter<"Level"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Level"> | Date | string
  }

  export type PathwayWhereInput = {
    AND?: PathwayWhereInput | PathwayWhereInput[]
    OR?: PathwayWhereInput[]
    NOT?: PathwayWhereInput | PathwayWhereInput[]
    id?: StringFilter<"Pathway"> | string
    pathway_id?: StringFilter<"Pathway"> | string
    from_stop_id?: StringFilter<"Pathway"> | string
    to_stop_id?: StringFilter<"Pathway"> | string
    pathway_mode?: IntFilter<"Pathway"> | number
    is_bidirectional?: IntFilter<"Pathway"> | number
    length?: FloatNullableFilter<"Pathway"> | number | null
    traversal_time?: IntNullableFilter<"Pathway"> | number | null
    stair_count?: IntNullableFilter<"Pathway"> | number | null
    max_slope?: FloatNullableFilter<"Pathway"> | number | null
    min_width?: FloatNullableFilter<"Pathway"> | number | null
    signposted_as?: StringNullableFilter<"Pathway"> | string | null
    reversed_signposted_as?: StringNullableFilter<"Pathway"> | string | null
    level_id?: StringNullableFilter<"Pathway"> | string | null
    project_id?: StringFilter<"Pathway"> | string
    created_by?: StringNullableFilter<"Pathway"> | string | null
    created_at?: DateTimeFilter<"Pathway"> | Date | string
    updated_at?: DateTimeFilter<"Pathway"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    fromStop?: XOR<StopScalarRelationFilter, StopWhereInput>
    toStop?: XOR<StopScalarRelationFilter, StopWhereInput>
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
  }

  export type PathwayOrderByWithRelationInput = {
    id?: SortOrder
    pathway_id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrderInput | SortOrder
    traversal_time?: SortOrderInput | SortOrder
    stair_count?: SortOrderInput | SortOrder
    max_slope?: SortOrderInput | SortOrder
    min_width?: SortOrderInput | SortOrder
    signposted_as?: SortOrderInput | SortOrder
    reversed_signposted_as?: SortOrderInput | SortOrder
    level_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
    fromStop?: StopOrderByWithRelationInput
    toStop?: StopOrderByWithRelationInput
    level?: LevelOrderByWithRelationInput
  }

  export type PathwayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pathway_id_project_id?: PathwayPathway_idProject_idCompoundUniqueInput
    AND?: PathwayWhereInput | PathwayWhereInput[]
    OR?: PathwayWhereInput[]
    NOT?: PathwayWhereInput | PathwayWhereInput[]
    pathway_id?: StringFilter<"Pathway"> | string
    from_stop_id?: StringFilter<"Pathway"> | string
    to_stop_id?: StringFilter<"Pathway"> | string
    pathway_mode?: IntFilter<"Pathway"> | number
    is_bidirectional?: IntFilter<"Pathway"> | number
    length?: FloatNullableFilter<"Pathway"> | number | null
    traversal_time?: IntNullableFilter<"Pathway"> | number | null
    stair_count?: IntNullableFilter<"Pathway"> | number | null
    max_slope?: FloatNullableFilter<"Pathway"> | number | null
    min_width?: FloatNullableFilter<"Pathway"> | number | null
    signposted_as?: StringNullableFilter<"Pathway"> | string | null
    reversed_signposted_as?: StringNullableFilter<"Pathway"> | string | null
    level_id?: StringNullableFilter<"Pathway"> | string | null
    project_id?: StringFilter<"Pathway"> | string
    created_by?: StringNullableFilter<"Pathway"> | string | null
    created_at?: DateTimeFilter<"Pathway"> | Date | string
    updated_at?: DateTimeFilter<"Pathway"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
    fromStop?: XOR<StopScalarRelationFilter, StopWhereInput>
    toStop?: XOR<StopScalarRelationFilter, StopWhereInput>
    level?: XOR<LevelNullableScalarRelationFilter, LevelWhereInput> | null
  }, "id" | "pathway_id_project_id">

  export type PathwayOrderByWithAggregationInput = {
    id?: SortOrder
    pathway_id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrderInput | SortOrder
    traversal_time?: SortOrderInput | SortOrder
    stair_count?: SortOrderInput | SortOrder
    max_slope?: SortOrderInput | SortOrder
    min_width?: SortOrderInput | SortOrder
    signposted_as?: SortOrderInput | SortOrder
    reversed_signposted_as?: SortOrderInput | SortOrder
    level_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PathwayCountOrderByAggregateInput
    _avg?: PathwayAvgOrderByAggregateInput
    _max?: PathwayMaxOrderByAggregateInput
    _min?: PathwayMinOrderByAggregateInput
    _sum?: PathwaySumOrderByAggregateInput
  }

  export type PathwayScalarWhereWithAggregatesInput = {
    AND?: PathwayScalarWhereWithAggregatesInput | PathwayScalarWhereWithAggregatesInput[]
    OR?: PathwayScalarWhereWithAggregatesInput[]
    NOT?: PathwayScalarWhereWithAggregatesInput | PathwayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pathway"> | string
    pathway_id?: StringWithAggregatesFilter<"Pathway"> | string
    from_stop_id?: StringWithAggregatesFilter<"Pathway"> | string
    to_stop_id?: StringWithAggregatesFilter<"Pathway"> | string
    pathway_mode?: IntWithAggregatesFilter<"Pathway"> | number
    is_bidirectional?: IntWithAggregatesFilter<"Pathway"> | number
    length?: FloatNullableWithAggregatesFilter<"Pathway"> | number | null
    traversal_time?: IntNullableWithAggregatesFilter<"Pathway"> | number | null
    stair_count?: IntNullableWithAggregatesFilter<"Pathway"> | number | null
    max_slope?: FloatNullableWithAggregatesFilter<"Pathway"> | number | null
    min_width?: FloatNullableWithAggregatesFilter<"Pathway"> | number | null
    signposted_as?: StringNullableWithAggregatesFilter<"Pathway"> | string | null
    reversed_signposted_as?: StringNullableWithAggregatesFilter<"Pathway"> | string | null
    level_id?: StringNullableWithAggregatesFilter<"Pathway"> | string | null
    project_id?: StringWithAggregatesFilter<"Pathway"> | string
    created_by?: StringNullableWithAggregatesFilter<"Pathway"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Pathway"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Pathway"> | Date | string
  }

  export type FeedInfoWhereInput = {
    AND?: FeedInfoWhereInput | FeedInfoWhereInput[]
    OR?: FeedInfoWhereInput[]
    NOT?: FeedInfoWhereInput | FeedInfoWhereInput[]
    id?: StringFilter<"FeedInfo"> | string
    feed_publisher_name?: StringFilter<"FeedInfo"> | string
    feed_publisher_url?: StringFilter<"FeedInfo"> | string
    feed_lang?: StringFilter<"FeedInfo"> | string
    default_lang?: StringNullableFilter<"FeedInfo"> | string | null
    feed_start_date?: StringNullableFilter<"FeedInfo"> | string | null
    feed_end_date?: StringNullableFilter<"FeedInfo"> | string | null
    feed_version?: StringNullableFilter<"FeedInfo"> | string | null
    feed_contact_email?: StringNullableFilter<"FeedInfo"> | string | null
    feed_contact_url?: StringNullableFilter<"FeedInfo"> | string | null
    project_id?: StringFilter<"FeedInfo"> | string
    created_by?: StringNullableFilter<"FeedInfo"> | string | null
    created_at?: DateTimeFilter<"FeedInfo"> | Date | string
    updated_at?: DateTimeFilter<"FeedInfo"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
  }

  export type FeedInfoOrderByWithRelationInput = {
    id?: SortOrder
    feed_publisher_name?: SortOrder
    feed_publisher_url?: SortOrder
    feed_lang?: SortOrder
    default_lang?: SortOrderInput | SortOrder
    feed_start_date?: SortOrderInput | SortOrder
    feed_end_date?: SortOrderInput | SortOrder
    feed_version?: SortOrderInput | SortOrder
    feed_contact_email?: SortOrderInput | SortOrder
    feed_contact_url?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: UserProjectOrderByWithRelationInput
  }

  export type FeedInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedInfoWhereInput | FeedInfoWhereInput[]
    OR?: FeedInfoWhereInput[]
    NOT?: FeedInfoWhereInput | FeedInfoWhereInput[]
    feed_publisher_name?: StringFilter<"FeedInfo"> | string
    feed_publisher_url?: StringFilter<"FeedInfo"> | string
    feed_lang?: StringFilter<"FeedInfo"> | string
    default_lang?: StringNullableFilter<"FeedInfo"> | string | null
    feed_start_date?: StringNullableFilter<"FeedInfo"> | string | null
    feed_end_date?: StringNullableFilter<"FeedInfo"> | string | null
    feed_version?: StringNullableFilter<"FeedInfo"> | string | null
    feed_contact_email?: StringNullableFilter<"FeedInfo"> | string | null
    feed_contact_url?: StringNullableFilter<"FeedInfo"> | string | null
    project_id?: StringFilter<"FeedInfo"> | string
    created_by?: StringNullableFilter<"FeedInfo"> | string | null
    created_at?: DateTimeFilter<"FeedInfo"> | Date | string
    updated_at?: DateTimeFilter<"FeedInfo"> | Date | string
    project?: XOR<UserProjectScalarRelationFilter, UserProjectWhereInput>
  }, "id">

  export type FeedInfoOrderByWithAggregationInput = {
    id?: SortOrder
    feed_publisher_name?: SortOrder
    feed_publisher_url?: SortOrder
    feed_lang?: SortOrder
    default_lang?: SortOrderInput | SortOrder
    feed_start_date?: SortOrderInput | SortOrder
    feed_end_date?: SortOrderInput | SortOrder
    feed_version?: SortOrderInput | SortOrder
    feed_contact_email?: SortOrderInput | SortOrder
    feed_contact_url?: SortOrderInput | SortOrder
    project_id?: SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FeedInfoCountOrderByAggregateInput
    _max?: FeedInfoMaxOrderByAggregateInput
    _min?: FeedInfoMinOrderByAggregateInput
  }

  export type FeedInfoScalarWhereWithAggregatesInput = {
    AND?: FeedInfoScalarWhereWithAggregatesInput | FeedInfoScalarWhereWithAggregatesInput[]
    OR?: FeedInfoScalarWhereWithAggregatesInput[]
    NOT?: FeedInfoScalarWhereWithAggregatesInput | FeedInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedInfo"> | string
    feed_publisher_name?: StringWithAggregatesFilter<"FeedInfo"> | string
    feed_publisher_url?: StringWithAggregatesFilter<"FeedInfo"> | string
    feed_lang?: StringWithAggregatesFilter<"FeedInfo"> | string
    default_lang?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    feed_start_date?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    feed_end_date?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    feed_version?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    feed_contact_email?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    feed_contact_url?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    project_id?: StringWithAggregatesFilter<"FeedInfo"> | string
    created_by?: StringNullableWithAggregatesFilter<"FeedInfo"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"FeedInfo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FeedInfo"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectUncheckedCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareUncheckedCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUncheckedUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    id?: string
    theme?: string
    language?: string
    timezone?: string
    map_default_lat?: number
    map_default_lon?: number
    map_default_zoom?: number
    table_page_size?: number
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    user_id: string
    theme?: string
    language?: string
    timezone?: string
    map_default_lat?: number
    map_default_lon?: number
    map_default_zoom?: number
    table_page_size?: number
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    map_default_lat?: FloatFieldUpdateOperationsInput | number
    map_default_lon?: FloatFieldUpdateOperationsInput | number
    map_default_zoom?: IntFieldUpdateOperationsInput | number
    table_page_size?: IntFieldUpdateOperationsInput | number
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    map_default_lat?: FloatFieldUpdateOperationsInput | number
    map_default_lon?: FloatFieldUpdateOperationsInput | number
    map_default_zoom?: IntFieldUpdateOperationsInput | number
    table_page_size?: IntFieldUpdateOperationsInput | number
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    user_id: string
    theme?: string
    language?: string
    timezone?: string
    map_default_lat?: number
    map_default_lon?: number
    map_default_zoom?: number
    table_page_size?: number
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    map_default_lat?: FloatFieldUpdateOperationsInput | number
    map_default_lon?: FloatFieldUpdateOperationsInput | number
    map_default_zoom?: IntFieldUpdateOperationsInput | number
    table_page_size?: IntFieldUpdateOperationsInput | number
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    map_default_lat?: FloatFieldUpdateOperationsInput | number
    map_default_lon?: FloatFieldUpdateOperationsInput | number
    map_default_zoom?: IntFieldUpdateOperationsInput | number
    table_page_size?: IntFieldUpdateOperationsInput | number
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareCreateInput = {
    id?: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutSharesInput
    user: UserCreateNestedOneWithoutSharedProjectsInput
  }

  export type ProjectShareUncheckedCreateInput = {
    id?: string
    project_id: string
    user_id: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutSharesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedProjectsNestedInput
  }

  export type ProjectShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareCreateManyInput = {
    id?: string
    project_id: string
    user_id: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteCreateInput = {
    id?: string
    email: string
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
    project: UserProjectCreateNestedOneWithoutInvitesInput
    user?: UserCreateNestedOneWithoutInvitedProjectsInput
  }

  export type ProjectInviteUncheckedCreateInput = {
    id?: string
    project_id: string
    email: string
    user_id?: string | null
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
  }

  export type ProjectInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutInvitesNestedInput
    user?: UserUpdateOneWithoutInvitedProjectsNestedInput
  }

  export type ProjectInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteCreateManyInput = {
    id?: string
    project_id: string
    email: string
    user_id?: string | null
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
  }

  export type ProjectInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    id?: string
    token: string
    expires_at: Date | string
    used_at?: Date | string | null
    created_at?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: string
    user_id: string
    token: string
    expires_at: Date | string
    used_at?: Date | string | null
    created_at?: Date | string
  }

  export type PasswordResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: string
    user_id: string
    token: string
    expires_at: Date | string
    used_at?: Date | string | null
    created_at?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    session_token: string
    expires_at: Date | string
    user_agent?: string | null
    ip_address?: string | null
    created_at?: Date | string
    last_active?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    user_id: string
    session_token: string
    expires_at: Date | string
    user_agent?: string | null
    ip_address?: string | null
    created_at?: Date | string
    last_active?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    user_id: string
    session_token: string
    expires_at: Date | string
    user_agent?: string | null
    ip_address?: string | null
    created_at?: Date | string
    last_active?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyCreateInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutAgenciesInput
    routes?: RouteCreateNestedManyWithoutAgencyInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    routes?: RouteUncheckedCreateNestedManyWithoutAgencyInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutAgenciesNestedInput
    routes?: RouteUpdateManyWithoutAgencyNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    routes?: RouteUncheckedUpdateManyWithoutAgencyNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopCreateInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type StopCreateManyInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutRoutesInput
    agency?: AgencyCreateNestedOneWithoutRoutesInput
    trips?: TripCreateNestedManyWithoutRouteInput
    fareRules?: FareRuleCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateInput = {
    id?: string
    route_id: string
    agency_id?: string | null
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutRoutesNestedInput
    agency?: AgencyUpdateOneWithoutRoutesNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
    fareRules?: FareRuleUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCreateManyInput = {
    id?: string
    route_id: string
    agency_id?: string | null
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateInput = {
    id?: string
    trip_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTripsInput
    route: RouteCreateNestedOneWithoutTripsInput
    calendar?: CalendarCreateNestedOneWithoutTripsInput
    stopTimes?: StopTimeCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    trip_id: string
    route_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTripsNestedInput
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    calendar?: CalendarUpdateOneWithoutTripsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: string
    trip_id: string
    route_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeCreateInput = {
    id?: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopTimesInput
    trip: TripCreateNestedOneWithoutStopTimesInput
    stop: StopCreateNestedOneWithoutStopTimesInput
  }

  export type StopTimeUncheckedCreateInput = {
    id?: string
    trip_id: string
    stop_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopTimesNestedInput
    trip?: TripUpdateOneRequiredWithoutStopTimesNestedInput
    stop?: StopUpdateOneRequiredWithoutStopTimesNestedInput
  }

  export type StopTimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeCreateManyInput = {
    id?: string
    trip_id: string
    stop_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCreateInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutCalendarsInput
    trips?: TripCreateNestedManyWithoutCalendarInput
    exceptions?: CalendarDateCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutCalendarInput
    exceptions?: CalendarDateUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutCalendarsNestedInput
    trips?: TripUpdateManyWithoutCalendarNestedInput
    exceptions?: CalendarDateUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutCalendarNestedInput
    exceptions?: CalendarDateUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarCreateManyInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateCreateInput = {
    id?: string
    date: string
    exception_type: number
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutCalendarDatesInput
    calendar: CalendarCreateNestedOneWithoutExceptionsInput
  }

  export type CalendarDateUncheckedCreateInput = {
    id?: string
    service_id: string
    date: string
    exception_type: number
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutCalendarDatesNestedInput
    calendar?: CalendarUpdateOneRequiredWithoutExceptionsNestedInput
  }

  export type CalendarDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateCreateManyInput = {
    id?: string
    service_id: string
    date: string
    exception_type: number
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareAttributeCreateInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    transfer_duration?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFareAttributesInput
    agency?: AgencyCreateNestedOneWithoutFareAttributesInput
    fareRules?: FareRuleCreateNestedManyWithoutFare_attributeInput
  }

  export type FareAttributeUncheckedCreateInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    agency_id?: string | null
    transfer_duration?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutFare_attributeInput
  }

  export type FareAttributeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFareAttributesNestedInput
    agency?: AgencyUpdateOneWithoutFareAttributesNestedInput
    fareRules?: FareRuleUpdateManyWithoutFare_attributeNestedInput
  }

  export type FareAttributeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fareRules?: FareRuleUncheckedUpdateManyWithoutFare_attributeNestedInput
  }

  export type FareAttributeCreateManyInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    agency_id?: string | null
    transfer_duration?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareAttributeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareAttributeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleCreateInput = {
    id?: string
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFareRulesInput
    fare_attribute: FareAttributeCreateNestedOneWithoutFareRulesInput
    route?: RouteCreateNestedOneWithoutFareRulesInput
  }

  export type FareRuleUncheckedCreateInput = {
    id?: string
    fare_id: string
    route_id?: string | null
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFareRulesNestedInput
    fare_attribute?: FareAttributeUpdateOneRequiredWithoutFareRulesNestedInput
    route?: RouteUpdateOneWithoutFareRulesNestedInput
  }

  export type FareRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    route_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleCreateManyInput = {
    id?: string
    fare_id: string
    route_id?: string | null
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    route_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShapeCreateInput = {
    id?: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutShapesInput
  }

  export type ShapeUncheckedCreateInput = {
    id?: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShapeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutShapesNestedInput
  }

  export type ShapeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShapeCreateManyInput = {
    id?: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShapeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShapeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateInput = {
    id?: string
    transfer_type?: number
    min_transfer_time?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTransfersInput
    fromStop: StopCreateNestedOneWithoutTransfersInput
    toStop: StopCreateNestedOneWithoutTransfersToInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    from_stop_id: string
    to_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTransfersNestedInput
    fromStop?: StopUpdateOneRequiredWithoutTransfersNestedInput
    toStop?: StopUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateManyInput = {
    id?: string
    from_stop_id: string
    to_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FrequencyCreateInput = {
    id?: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFrequenciesInput
  }

  export type FrequencyUncheckedCreateInput = {
    id?: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FrequencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFrequenciesNestedInput
  }

  export type FrequencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FrequencyCreateManyInput = {
    id?: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FrequencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FrequencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelCreateInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutLevelsInput
    stops?: StopCreateNestedManyWithoutLevelInput
    pathways?: PathwayCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutLevelInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutLevelsNestedInput
    stops?: StopUpdateManyWithoutLevelNestedInput
    pathways?: PathwayUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutLevelNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelCreateManyInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayCreateInput = {
    id?: string
    pathway_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutPathwaysInput
    fromStop: StopCreateNestedOneWithoutPathwaysInput
    toStop: StopCreateNestedOneWithoutPathwaysToInput
    level?: LevelCreateNestedOneWithoutPathwaysInput
  }

  export type PathwayUncheckedCreateInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutPathwaysNestedInput
    fromStop?: StopUpdateOneRequiredWithoutPathwaysNestedInput
    toStop?: StopUpdateOneRequiredWithoutPathwaysToNestedInput
    level?: LevelUpdateOneWithoutPathwaysNestedInput
  }

  export type PathwayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayCreateManyInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedInfoCreateInput = {
    id?: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang?: string | null
    feed_start_date?: string | null
    feed_end_date?: string | null
    feed_version?: string | null
    feed_contact_email?: string | null
    feed_contact_url?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFeedInfoInput
  }

  export type FeedInfoUncheckedCreateInput = {
    id?: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang?: string | null
    feed_start_date?: string | null
    feed_end_date?: string | null
    feed_version?: string | null
    feed_contact_email?: string | null
    feed_contact_url?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FeedInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFeedInfoNestedInput
  }

  export type FeedInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedInfoCreateManyInput = {
    id?: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang?: string | null
    feed_start_date?: string | null
    feed_end_date?: string | null
    feed_version?: string | null
    feed_contact_email?: string | null
    feed_contact_url?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FeedInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type UserProjectListRelationFilter = {
    every?: UserProjectWhereInput
    some?: UserProjectWhereInput
    none?: UserProjectWhereInput
  }

  export type ProjectShareListRelationFilter = {
    every?: ProjectShareWhereInput
    some?: ProjectShareWhereInput
    none?: ProjectShareWhereInput
  }

  export type ProjectInviteListRelationFilter = {
    every?: ProjectInviteWhereInput
    some?: ProjectInviteWhereInput
    none?: ProjectInviteWhereInput
  }

  export type PasswordResetListRelationFilter = {
    every?: PasswordResetWhereInput
    some?: PasswordResetWhereInput
    none?: PasswordResetWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    avatar_url?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    avatar_url?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    avatar_url?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
    notifications?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    map_default_lat?: SortOrder
    map_default_lon?: SortOrder
    map_default_zoom?: SortOrder
    table_page_size?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AgencyListRelationFilter = {
    every?: AgencyWhereInput
    some?: AgencyWhereInput
    none?: AgencyWhereInput
  }

  export type StopListRelationFilter = {
    every?: StopWhereInput
    some?: StopWhereInput
    none?: StopWhereInput
  }

  export type RouteListRelationFilter = {
    every?: RouteWhereInput
    some?: RouteWhereInput
    none?: RouteWhereInput
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type StopTimeListRelationFilter = {
    every?: StopTimeWhereInput
    some?: StopTimeWhereInput
    none?: StopTimeWhereInput
  }

  export type CalendarListRelationFilter = {
    every?: CalendarWhereInput
    some?: CalendarWhereInput
    none?: CalendarWhereInput
  }

  export type CalendarDateListRelationFilter = {
    every?: CalendarDateWhereInput
    some?: CalendarDateWhereInput
    none?: CalendarDateWhereInput
  }

  export type FareAttributeListRelationFilter = {
    every?: FareAttributeWhereInput
    some?: FareAttributeWhereInput
    none?: FareAttributeWhereInput
  }

  export type FareRuleListRelationFilter = {
    every?: FareRuleWhereInput
    some?: FareRuleWhereInput
    none?: FareRuleWhereInput
  }

  export type ShapeListRelationFilter = {
    every?: ShapeWhereInput
    some?: ShapeWhereInput
    none?: ShapeWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type FrequencyListRelationFilter = {
    every?: FrequencyWhereInput
    some?: FrequencyWhereInput
    none?: FrequencyWhereInput
  }

  export type LevelListRelationFilter = {
    every?: LevelWhereInput
    some?: LevelWhereInput
    none?: LevelWhereInput
  }

  export type PathwayListRelationFilter = {
    every?: PathwayWhereInput
    some?: PathwayWhereInput
    none?: PathwayWhereInput
  }

  export type FeedInfoListRelationFilter = {
    every?: FeedInfoWhereInput
    some?: FeedInfoWhereInput
    none?: FeedInfoWhereInput
  }

  export type AgencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StopTimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FareAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FareRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShapeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FrequencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathwayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    owner_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    owner_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    owner_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type UserProjectScalarRelationFilter = {
    is?: UserProjectWhereInput
    isNot?: UserProjectWhereInput
  }

  export type ProjectShareProject_idUser_idCompoundUniqueInput = {
    project_id: string
    user_id: string
  }

  export type ProjectShareCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    shared_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectShareMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    shared_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectShareMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    shared_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProjectInviteCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invited_by?: SortOrder
    expires_at?: SortOrder
    accepted_at?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invited_by?: SortOrder
    expires_at?: SortOrder
    accepted_at?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectInviteMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    token?: SortOrder
    invited_by?: SortOrder
    expires_at?: SortOrder
    accepted_at?: SortOrder
    created_at?: SortOrder
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    created_at?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    created_at?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    used_at?: SortOrder
    created_at?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    expires_at?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    last_active?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    expires_at?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    last_active?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    session_token?: SortOrder
    expires_at?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    last_active?: SortOrder
  }

  export type AgencyAgency_idProject_idCompoundUniqueInput = {
    agency_id: string
    project_id: string
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    agency_url?: SortOrder
    agency_timezone?: SortOrder
    agency_lang?: SortOrder
    agency_phone?: SortOrder
    agency_fare_url?: SortOrder
    agency_email?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    agency_url?: SortOrder
    agency_timezone?: SortOrder
    agency_lang?: SortOrder
    agency_phone?: SortOrder
    agency_fare_url?: SortOrder
    agency_email?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    agency_url?: SortOrder
    agency_timezone?: SortOrder
    agency_lang?: SortOrder
    agency_phone?: SortOrder
    agency_fare_url?: SortOrder
    agency_email?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StopNullableScalarRelationFilter = {
    is?: StopWhereInput | null
    isNot?: StopWhereInput | null
  }

  export type LevelNullableScalarRelationFilter = {
    is?: LevelWhereInput | null
    isNot?: LevelWhereInput | null
  }

  export type StopStop_idProject_idCompoundUniqueInput = {
    stop_id: string
    project_id: string
  }

  export type StopCountOrderByAggregateInput = {
    id?: SortOrder
    stop_id?: SortOrder
    stop_code?: SortOrder
    stop_name?: SortOrder
    stop_desc?: SortOrder
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    zone_id?: SortOrder
    stop_url?: SortOrder
    location_type?: SortOrder
    wheelchair_boarding?: SortOrder
    parent_station?: SortOrder
    platform_code?: SortOrder
    level_id?: SortOrder
    tts_stop_name?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StopAvgOrderByAggregateInput = {
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    location_type?: SortOrder
    wheelchair_boarding?: SortOrder
  }

  export type StopMaxOrderByAggregateInput = {
    id?: SortOrder
    stop_id?: SortOrder
    stop_code?: SortOrder
    stop_name?: SortOrder
    stop_desc?: SortOrder
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    zone_id?: SortOrder
    stop_url?: SortOrder
    location_type?: SortOrder
    wheelchair_boarding?: SortOrder
    parent_station?: SortOrder
    platform_code?: SortOrder
    level_id?: SortOrder
    tts_stop_name?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StopMinOrderByAggregateInput = {
    id?: SortOrder
    stop_id?: SortOrder
    stop_code?: SortOrder
    stop_name?: SortOrder
    stop_desc?: SortOrder
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    zone_id?: SortOrder
    stop_url?: SortOrder
    location_type?: SortOrder
    wheelchair_boarding?: SortOrder
    parent_station?: SortOrder
    platform_code?: SortOrder
    level_id?: SortOrder
    tts_stop_name?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StopSumOrderByAggregateInput = {
    stop_lat?: SortOrder
    stop_lon?: SortOrder
    location_type?: SortOrder
    wheelchair_boarding?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type RouteRoute_idProject_idCompoundUniqueInput = {
    route_id: string
    project_id: string
  }

  export type RouteCountOrderByAggregateInput = {
    id?: SortOrder
    route_id?: SortOrder
    agency_id?: SortOrder
    route_short_name?: SortOrder
    route_long_name?: SortOrder
    route_desc?: SortOrder
    route_type?: SortOrder
    route_url?: SortOrder
    route_color?: SortOrder
    route_text_color?: SortOrder
    route_sort_order?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    network_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteAvgOrderByAggregateInput = {
    route_type?: SortOrder
    route_sort_order?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    id?: SortOrder
    route_id?: SortOrder
    agency_id?: SortOrder
    route_short_name?: SortOrder
    route_long_name?: SortOrder
    route_desc?: SortOrder
    route_type?: SortOrder
    route_url?: SortOrder
    route_color?: SortOrder
    route_text_color?: SortOrder
    route_sort_order?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    network_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    id?: SortOrder
    route_id?: SortOrder
    agency_id?: SortOrder
    route_short_name?: SortOrder
    route_long_name?: SortOrder
    route_desc?: SortOrder
    route_type?: SortOrder
    route_url?: SortOrder
    route_color?: SortOrder
    route_text_color?: SortOrder
    route_sort_order?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    network_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RouteSumOrderByAggregateInput = {
    route_type?: SortOrder
    route_sort_order?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
  }

  export type RouteScalarRelationFilter = {
    is?: RouteWhereInput
    isNot?: RouteWhereInput
  }

  export type CalendarNullableScalarRelationFilter = {
    is?: CalendarWhereInput | null
    isNot?: CalendarWhereInput | null
  }

  export type TripTrip_idProject_idCompoundUniqueInput = {
    trip_id: string
    project_id: string
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    route_id?: SortOrder
    service_id?: SortOrder
    trip_headsign?: SortOrder
    trip_short_name?: SortOrder
    direction_id?: SortOrder
    block_id?: SortOrder
    shape_id?: SortOrder
    wheelchair_accessible?: SortOrder
    bikes_allowed?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TripAvgOrderByAggregateInput = {
    direction_id?: SortOrder
    wheelchair_accessible?: SortOrder
    bikes_allowed?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    route_id?: SortOrder
    service_id?: SortOrder
    trip_headsign?: SortOrder
    trip_short_name?: SortOrder
    direction_id?: SortOrder
    block_id?: SortOrder
    shape_id?: SortOrder
    wheelchair_accessible?: SortOrder
    bikes_allowed?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    route_id?: SortOrder
    service_id?: SortOrder
    trip_headsign?: SortOrder
    trip_short_name?: SortOrder
    direction_id?: SortOrder
    block_id?: SortOrder
    shape_id?: SortOrder
    wheelchair_accessible?: SortOrder
    bikes_allowed?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TripSumOrderByAggregateInput = {
    direction_id?: SortOrder
    wheelchair_accessible?: SortOrder
    bikes_allowed?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TripScalarRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type StopScalarRelationFilter = {
    is?: StopWhereInput
    isNot?: StopWhereInput
  }

  export type StopTimeTrip_idStop_sequenceProject_idCompoundUniqueInput = {
    trip_id: string
    stop_sequence: number
    project_id: string
  }

  export type StopTimeCountOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    stop_id?: SortOrder
    arrival_time?: SortOrder
    departure_time?: SortOrder
    stop_sequence?: SortOrder
    stop_headsign?: SortOrder
    pickup_type?: SortOrder
    drop_off_type?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    shape_dist_traveled?: SortOrder
    timepoint?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StopTimeAvgOrderByAggregateInput = {
    stop_sequence?: SortOrder
    pickup_type?: SortOrder
    drop_off_type?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    shape_dist_traveled?: SortOrder
    timepoint?: SortOrder
  }

  export type StopTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    stop_id?: SortOrder
    arrival_time?: SortOrder
    departure_time?: SortOrder
    stop_sequence?: SortOrder
    stop_headsign?: SortOrder
    pickup_type?: SortOrder
    drop_off_type?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    shape_dist_traveled?: SortOrder
    timepoint?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StopTimeMinOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    stop_id?: SortOrder
    arrival_time?: SortOrder
    departure_time?: SortOrder
    stop_sequence?: SortOrder
    stop_headsign?: SortOrder
    pickup_type?: SortOrder
    drop_off_type?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    shape_dist_traveled?: SortOrder
    timepoint?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StopTimeSumOrderByAggregateInput = {
    stop_sequence?: SortOrder
    pickup_type?: SortOrder
    drop_off_type?: SortOrder
    continuous_pickup?: SortOrder
    continuous_drop_off?: SortOrder
    shape_dist_traveled?: SortOrder
    timepoint?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CalendarService_idProject_idCompoundUniqueInput = {
    service_id: string
    project_id: string
  }

  export type CalendarCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CalendarAvgOrderByAggregateInput = {
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
  }

  export type CalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CalendarMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CalendarSumOrderByAggregateInput = {
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
  }

  export type CalendarScalarRelationFilter = {
    is?: CalendarWhereInput
    isNot?: CalendarWhereInput
  }

  export type CalendarDateService_idDateProject_idCompoundUniqueInput = {
    service_id: string
    date: string
    project_id: string
  }

  export type CalendarDateCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    date?: SortOrder
    exception_type?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CalendarDateAvgOrderByAggregateInput = {
    exception_type?: SortOrder
  }

  export type CalendarDateMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    date?: SortOrder
    exception_type?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CalendarDateMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    date?: SortOrder
    exception_type?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CalendarDateSumOrderByAggregateInput = {
    exception_type?: SortOrder
  }

  export type FareAttributeFare_idProject_idCompoundUniqueInput = {
    fare_id: string
    project_id: string
  }

  export type FareAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    fare_id?: SortOrder
    price?: SortOrder
    currency_type?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrder
    agency_id?: SortOrder
    transfer_duration?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FareAttributeAvgOrderByAggregateInput = {
    price?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrder
    transfer_duration?: SortOrder
  }

  export type FareAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    fare_id?: SortOrder
    price?: SortOrder
    currency_type?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrder
    agency_id?: SortOrder
    transfer_duration?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FareAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    fare_id?: SortOrder
    price?: SortOrder
    currency_type?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrder
    agency_id?: SortOrder
    transfer_duration?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FareAttributeSumOrderByAggregateInput = {
    price?: SortOrder
    payment_method?: SortOrder
    transfers?: SortOrder
    transfer_duration?: SortOrder
  }

  export type FareAttributeScalarRelationFilter = {
    is?: FareAttributeWhereInput
    isNot?: FareAttributeWhereInput
  }

  export type RouteNullableScalarRelationFilter = {
    is?: RouteWhereInput | null
    isNot?: RouteWhereInput | null
  }

  export type FareRuleCountOrderByAggregateInput = {
    id?: SortOrder
    fare_id?: SortOrder
    route_id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    contains_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FareRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    fare_id?: SortOrder
    route_id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    contains_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FareRuleMinOrderByAggregateInput = {
    id?: SortOrder
    fare_id?: SortOrder
    route_id?: SortOrder
    origin_id?: SortOrder
    destination_id?: SortOrder
    contains_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShapeShape_idShape_pt_sequenceProject_idCompoundUniqueInput = {
    shape_id: string
    shape_pt_sequence: number
    project_id: string
  }

  export type ShapeCountOrderByAggregateInput = {
    id?: SortOrder
    shape_id?: SortOrder
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShapeAvgOrderByAggregateInput = {
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrder
  }

  export type ShapeMaxOrderByAggregateInput = {
    id?: SortOrder
    shape_id?: SortOrder
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShapeMinOrderByAggregateInput = {
    id?: SortOrder
    shape_id?: SortOrder
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ShapeSumOrderByAggregateInput = {
    shape_pt_sequence?: SortOrder
    shape_pt_lat?: SortOrder
    shape_pt_lon?: SortOrder
    shape_dist_traveled?: SortOrder
  }

  export type TransferFrom_stop_idTo_stop_idProject_idCompoundUniqueInput = {
    from_stop_id: string
    to_stop_id: string
    project_id: string
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    transfer_type?: SortOrder
    min_transfer_time?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    transfer_type?: SortOrder
    min_transfer_time?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    transfer_type?: SortOrder
    min_transfer_time?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    transfer_type?: SortOrder
    min_transfer_time?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    transfer_type?: SortOrder
    min_transfer_time?: SortOrder
  }

  export type FrequencyCountOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    headway_secs?: SortOrder
    exact_times?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FrequencyAvgOrderByAggregateInput = {
    headway_secs?: SortOrder
    exact_times?: SortOrder
  }

  export type FrequencyMaxOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    headway_secs?: SortOrder
    exact_times?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FrequencyMinOrderByAggregateInput = {
    id?: SortOrder
    trip_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    headway_secs?: SortOrder
    exact_times?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FrequencySumOrderByAggregateInput = {
    headway_secs?: SortOrder
    exact_times?: SortOrder
  }

  export type LevelLevel_idProject_idCompoundUniqueInput = {
    level_id: string
    project_id: string
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    level_id?: SortOrder
    level_index?: SortOrder
    level_name?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LevelAvgOrderByAggregateInput = {
    level_index?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    level_id?: SortOrder
    level_index?: SortOrder
    level_name?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    level_id?: SortOrder
    level_index?: SortOrder
    level_name?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LevelSumOrderByAggregateInput = {
    level_index?: SortOrder
  }

  export type PathwayPathway_idProject_idCompoundUniqueInput = {
    pathway_id: string
    project_id: string
  }

  export type PathwayCountOrderByAggregateInput = {
    id?: SortOrder
    pathway_id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrder
    traversal_time?: SortOrder
    stair_count?: SortOrder
    max_slope?: SortOrder
    min_width?: SortOrder
    signposted_as?: SortOrder
    reversed_signposted_as?: SortOrder
    level_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PathwayAvgOrderByAggregateInput = {
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrder
    traversal_time?: SortOrder
    stair_count?: SortOrder
    max_slope?: SortOrder
    min_width?: SortOrder
  }

  export type PathwayMaxOrderByAggregateInput = {
    id?: SortOrder
    pathway_id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrder
    traversal_time?: SortOrder
    stair_count?: SortOrder
    max_slope?: SortOrder
    min_width?: SortOrder
    signposted_as?: SortOrder
    reversed_signposted_as?: SortOrder
    level_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PathwayMinOrderByAggregateInput = {
    id?: SortOrder
    pathway_id?: SortOrder
    from_stop_id?: SortOrder
    to_stop_id?: SortOrder
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrder
    traversal_time?: SortOrder
    stair_count?: SortOrder
    max_slope?: SortOrder
    min_width?: SortOrder
    signposted_as?: SortOrder
    reversed_signposted_as?: SortOrder
    level_id?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PathwaySumOrderByAggregateInput = {
    pathway_mode?: SortOrder
    is_bidirectional?: SortOrder
    length?: SortOrder
    traversal_time?: SortOrder
    stair_count?: SortOrder
    max_slope?: SortOrder
    min_width?: SortOrder
  }

  export type FeedInfoCountOrderByAggregateInput = {
    id?: SortOrder
    feed_publisher_name?: SortOrder
    feed_publisher_url?: SortOrder
    feed_lang?: SortOrder
    default_lang?: SortOrder
    feed_start_date?: SortOrder
    feed_end_date?: SortOrder
    feed_version?: SortOrder
    feed_contact_email?: SortOrder
    feed_contact_url?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FeedInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    feed_publisher_name?: SortOrder
    feed_publisher_url?: SortOrder
    feed_lang?: SortOrder
    default_lang?: SortOrder
    feed_start_date?: SortOrder
    feed_end_date?: SortOrder
    feed_version?: SortOrder
    feed_contact_email?: SortOrder
    feed_contact_url?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FeedInfoMinOrderByAggregateInput = {
    id?: SortOrder
    feed_publisher_name?: SortOrder
    feed_publisher_url?: SortOrder
    feed_lang?: SortOrder
    default_lang?: SortOrder
    feed_start_date?: SortOrder
    feed_end_date?: SortOrder
    feed_version?: SortOrder
    feed_contact_email?: SortOrder
    feed_contact_url?: SortOrder
    project_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UserProjectCreateWithoutOwnerInput, UserProjectUncheckedCreateWithoutOwnerInput> | UserProjectCreateWithoutOwnerInput[] | UserProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserProjectCreateOrConnectWithoutOwnerInput | UserProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: UserProjectCreateManyOwnerInputEnvelope
    connect?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
  }

  export type ProjectShareCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectShareCreateWithoutUserInput, ProjectShareUncheckedCreateWithoutUserInput> | ProjectShareCreateWithoutUserInput[] | ProjectShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutUserInput | ProjectShareCreateOrConnectWithoutUserInput[]
    createMany?: ProjectShareCreateManyUserInputEnvelope
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
  }

  export type ProjectInviteCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectInviteCreateWithoutUserInput, ProjectInviteUncheckedCreateWithoutUserInput> | ProjectInviteCreateWithoutUserInput[] | ProjectInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutUserInput | ProjectInviteCreateOrConnectWithoutUserInput[]
    createMany?: ProjectInviteCreateManyUserInputEnvelope
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
  }

  export type PasswordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<UserProjectCreateWithoutOwnerInput, UserProjectUncheckedCreateWithoutOwnerInput> | UserProjectCreateWithoutOwnerInput[] | UserProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserProjectCreateOrConnectWithoutOwnerInput | UserProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: UserProjectCreateManyOwnerInputEnvelope
    connect?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
  }

  export type ProjectShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectShareCreateWithoutUserInput, ProjectShareUncheckedCreateWithoutUserInput> | ProjectShareCreateWithoutUserInput[] | ProjectShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutUserInput | ProjectShareCreateOrConnectWithoutUserInput[]
    createMany?: ProjectShareCreateManyUserInputEnvelope
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
  }

  export type ProjectInviteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectInviteCreateWithoutUserInput, ProjectInviteUncheckedCreateWithoutUserInput> | ProjectInviteCreateWithoutUserInput[] | ProjectInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutUserInput | ProjectInviteCreateOrConnectWithoutUserInput[]
    createMany?: ProjectInviteCreateManyUserInputEnvelope
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
  }

  export type PasswordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UserProjectCreateWithoutOwnerInput, UserProjectUncheckedCreateWithoutOwnerInput> | UserProjectCreateWithoutOwnerInput[] | UserProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserProjectCreateOrConnectWithoutOwnerInput | UserProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: UserProjectUpsertWithWhereUniqueWithoutOwnerInput | UserProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UserProjectCreateManyOwnerInputEnvelope
    set?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    disconnect?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    delete?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    connect?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    update?: UserProjectUpdateWithWhereUniqueWithoutOwnerInput | UserProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UserProjectUpdateManyWithWhereWithoutOwnerInput | UserProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UserProjectScalarWhereInput | UserProjectScalarWhereInput[]
  }

  export type ProjectShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectShareCreateWithoutUserInput, ProjectShareUncheckedCreateWithoutUserInput> | ProjectShareCreateWithoutUserInput[] | ProjectShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutUserInput | ProjectShareCreateOrConnectWithoutUserInput[]
    upsert?: ProjectShareUpsertWithWhereUniqueWithoutUserInput | ProjectShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectShareCreateManyUserInputEnvelope
    set?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    disconnect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    delete?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    update?: ProjectShareUpdateWithWhereUniqueWithoutUserInput | ProjectShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectShareUpdateManyWithWhereWithoutUserInput | ProjectShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectShareScalarWhereInput | ProjectShareScalarWhereInput[]
  }

  export type ProjectInviteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectInviteCreateWithoutUserInput, ProjectInviteUncheckedCreateWithoutUserInput> | ProjectInviteCreateWithoutUserInput[] | ProjectInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutUserInput | ProjectInviteCreateOrConnectWithoutUserInput[]
    upsert?: ProjectInviteUpsertWithWhereUniqueWithoutUserInput | ProjectInviteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectInviteCreateManyUserInputEnvelope
    set?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    disconnect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    delete?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    update?: ProjectInviteUpdateWithWhereUniqueWithoutUserInput | ProjectInviteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectInviteUpdateManyWithWhereWithoutUserInput | ProjectInviteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectInviteScalarWhereInput | ProjectInviteScalarWhereInput[]
  }

  export type PasswordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<UserProjectCreateWithoutOwnerInput, UserProjectUncheckedCreateWithoutOwnerInput> | UserProjectCreateWithoutOwnerInput[] | UserProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: UserProjectCreateOrConnectWithoutOwnerInput | UserProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: UserProjectUpsertWithWhereUniqueWithoutOwnerInput | UserProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: UserProjectCreateManyOwnerInputEnvelope
    set?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    disconnect?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    delete?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    connect?: UserProjectWhereUniqueInput | UserProjectWhereUniqueInput[]
    update?: UserProjectUpdateWithWhereUniqueWithoutOwnerInput | UserProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: UserProjectUpdateManyWithWhereWithoutOwnerInput | UserProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: UserProjectScalarWhereInput | UserProjectScalarWhereInput[]
  }

  export type ProjectShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectShareCreateWithoutUserInput, ProjectShareUncheckedCreateWithoutUserInput> | ProjectShareCreateWithoutUserInput[] | ProjectShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutUserInput | ProjectShareCreateOrConnectWithoutUserInput[]
    upsert?: ProjectShareUpsertWithWhereUniqueWithoutUserInput | ProjectShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectShareCreateManyUserInputEnvelope
    set?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    disconnect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    delete?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    update?: ProjectShareUpdateWithWhereUniqueWithoutUserInput | ProjectShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectShareUpdateManyWithWhereWithoutUserInput | ProjectShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectShareScalarWhereInput | ProjectShareScalarWhereInput[]
  }

  export type ProjectInviteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectInviteCreateWithoutUserInput, ProjectInviteUncheckedCreateWithoutUserInput> | ProjectInviteCreateWithoutUserInput[] | ProjectInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutUserInput | ProjectInviteCreateOrConnectWithoutUserInput[]
    upsert?: ProjectInviteUpsertWithWhereUniqueWithoutUserInput | ProjectInviteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectInviteCreateManyUserInputEnvelope
    set?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    disconnect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    delete?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    update?: ProjectInviteUpdateWithWhereUniqueWithoutUserInput | ProjectInviteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectInviteUpdateManyWithWhereWithoutUserInput | ProjectInviteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectInviteScalarWhereInput | ProjectInviteScalarWhereInput[]
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutOwnedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectShareCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectShareCreateWithoutProjectInput, ProjectShareUncheckedCreateWithoutProjectInput> | ProjectShareCreateWithoutProjectInput[] | ProjectShareUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutProjectInput | ProjectShareCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectShareCreateManyProjectInputEnvelope
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
  }

  export type ProjectInviteCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput> | ProjectInviteCreateWithoutProjectInput[] | ProjectInviteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutProjectInput | ProjectInviteCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
  }

  export type AgencyCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgencyCreateWithoutProjectInput, AgencyUncheckedCreateWithoutProjectInput> | AgencyCreateWithoutProjectInput[] | AgencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutProjectInput | AgencyCreateOrConnectWithoutProjectInput[]
    createMany?: AgencyCreateManyProjectInputEnvelope
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
  }

  export type StopCreateNestedManyWithoutProjectInput = {
    create?: XOR<StopCreateWithoutProjectInput, StopUncheckedCreateWithoutProjectInput> | StopCreateWithoutProjectInput[] | StopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopCreateOrConnectWithoutProjectInput | StopCreateOrConnectWithoutProjectInput[]
    createMany?: StopCreateManyProjectInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type RouteCreateNestedManyWithoutProjectInput = {
    create?: XOR<RouteCreateWithoutProjectInput, RouteUncheckedCreateWithoutProjectInput> | RouteCreateWithoutProjectInput[] | RouteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutProjectInput | RouteCreateOrConnectWithoutProjectInput[]
    createMany?: RouteCreateManyProjectInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutProjectInput = {
    create?: XOR<TripCreateWithoutProjectInput, TripUncheckedCreateWithoutProjectInput> | TripCreateWithoutProjectInput[] | TripUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TripCreateOrConnectWithoutProjectInput | TripCreateOrConnectWithoutProjectInput[]
    createMany?: TripCreateManyProjectInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type StopTimeCreateNestedManyWithoutProjectInput = {
    create?: XOR<StopTimeCreateWithoutProjectInput, StopTimeUncheckedCreateWithoutProjectInput> | StopTimeCreateWithoutProjectInput[] | StopTimeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutProjectInput | StopTimeCreateOrConnectWithoutProjectInput[]
    createMany?: StopTimeCreateManyProjectInputEnvelope
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
  }

  export type CalendarCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarCreateWithoutProjectInput, CalendarUncheckedCreateWithoutProjectInput> | CalendarCreateWithoutProjectInput[] | CalendarUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutProjectInput | CalendarCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarCreateManyProjectInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type CalendarDateCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarDateCreateWithoutProjectInput, CalendarDateUncheckedCreateWithoutProjectInput> | CalendarDateCreateWithoutProjectInput[] | CalendarDateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutProjectInput | CalendarDateCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarDateCreateManyProjectInputEnvelope
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
  }

  export type FareAttributeCreateNestedManyWithoutProjectInput = {
    create?: XOR<FareAttributeCreateWithoutProjectInput, FareAttributeUncheckedCreateWithoutProjectInput> | FareAttributeCreateWithoutProjectInput[] | FareAttributeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutProjectInput | FareAttributeCreateOrConnectWithoutProjectInput[]
    createMany?: FareAttributeCreateManyProjectInputEnvelope
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
  }

  export type FareRuleCreateNestedManyWithoutProjectInput = {
    create?: XOR<FareRuleCreateWithoutProjectInput, FareRuleUncheckedCreateWithoutProjectInput> | FareRuleCreateWithoutProjectInput[] | FareRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutProjectInput | FareRuleCreateOrConnectWithoutProjectInput[]
    createMany?: FareRuleCreateManyProjectInputEnvelope
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
  }

  export type ShapeCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShapeCreateWithoutProjectInput, ShapeUncheckedCreateWithoutProjectInput> | ShapeCreateWithoutProjectInput[] | ShapeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShapeCreateOrConnectWithoutProjectInput | ShapeCreateOrConnectWithoutProjectInput[]
    createMany?: ShapeCreateManyProjectInputEnvelope
    connect?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutProjectInput = {
    create?: XOR<TransferCreateWithoutProjectInput, TransferUncheckedCreateWithoutProjectInput> | TransferCreateWithoutProjectInput[] | TransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutProjectInput | TransferCreateOrConnectWithoutProjectInput[]
    createMany?: TransferCreateManyProjectInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type FrequencyCreateNestedManyWithoutProjectInput = {
    create?: XOR<FrequencyCreateWithoutProjectInput, FrequencyUncheckedCreateWithoutProjectInput> | FrequencyCreateWithoutProjectInput[] | FrequencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FrequencyCreateOrConnectWithoutProjectInput | FrequencyCreateOrConnectWithoutProjectInput[]
    createMany?: FrequencyCreateManyProjectInputEnvelope
    connect?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
  }

  export type LevelCreateNestedManyWithoutProjectInput = {
    create?: XOR<LevelCreateWithoutProjectInput, LevelUncheckedCreateWithoutProjectInput> | LevelCreateWithoutProjectInput[] | LevelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutProjectInput | LevelCreateOrConnectWithoutProjectInput[]
    createMany?: LevelCreateManyProjectInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutProjectInput = {
    create?: XOR<PathwayCreateWithoutProjectInput, PathwayUncheckedCreateWithoutProjectInput> | PathwayCreateWithoutProjectInput[] | PathwayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutProjectInput | PathwayCreateOrConnectWithoutProjectInput[]
    createMany?: PathwayCreateManyProjectInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type FeedInfoCreateNestedManyWithoutProjectInput = {
    create?: XOR<FeedInfoCreateWithoutProjectInput, FeedInfoUncheckedCreateWithoutProjectInput> | FeedInfoCreateWithoutProjectInput[] | FeedInfoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FeedInfoCreateOrConnectWithoutProjectInput | FeedInfoCreateOrConnectWithoutProjectInput[]
    createMany?: FeedInfoCreateManyProjectInputEnvelope
    connect?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
  }

  export type ProjectShareUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectShareCreateWithoutProjectInput, ProjectShareUncheckedCreateWithoutProjectInput> | ProjectShareCreateWithoutProjectInput[] | ProjectShareUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutProjectInput | ProjectShareCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectShareCreateManyProjectInputEnvelope
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
  }

  export type ProjectInviteUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput> | ProjectInviteCreateWithoutProjectInput[] | ProjectInviteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutProjectInput | ProjectInviteCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
  }

  export type AgencyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgencyCreateWithoutProjectInput, AgencyUncheckedCreateWithoutProjectInput> | AgencyCreateWithoutProjectInput[] | AgencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutProjectInput | AgencyCreateOrConnectWithoutProjectInput[]
    createMany?: AgencyCreateManyProjectInputEnvelope
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
  }

  export type StopUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<StopCreateWithoutProjectInput, StopUncheckedCreateWithoutProjectInput> | StopCreateWithoutProjectInput[] | StopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopCreateOrConnectWithoutProjectInput | StopCreateOrConnectWithoutProjectInput[]
    createMany?: StopCreateManyProjectInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type RouteUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RouteCreateWithoutProjectInput, RouteUncheckedCreateWithoutProjectInput> | RouteCreateWithoutProjectInput[] | RouteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutProjectInput | RouteCreateOrConnectWithoutProjectInput[]
    createMany?: RouteCreateManyProjectInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TripCreateWithoutProjectInput, TripUncheckedCreateWithoutProjectInput> | TripCreateWithoutProjectInput[] | TripUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TripCreateOrConnectWithoutProjectInput | TripCreateOrConnectWithoutProjectInput[]
    createMany?: TripCreateManyProjectInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type StopTimeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<StopTimeCreateWithoutProjectInput, StopTimeUncheckedCreateWithoutProjectInput> | StopTimeCreateWithoutProjectInput[] | StopTimeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutProjectInput | StopTimeCreateOrConnectWithoutProjectInput[]
    createMany?: StopTimeCreateManyProjectInputEnvelope
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
  }

  export type CalendarUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarCreateWithoutProjectInput, CalendarUncheckedCreateWithoutProjectInput> | CalendarCreateWithoutProjectInput[] | CalendarUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutProjectInput | CalendarCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarCreateManyProjectInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type CalendarDateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarDateCreateWithoutProjectInput, CalendarDateUncheckedCreateWithoutProjectInput> | CalendarDateCreateWithoutProjectInput[] | CalendarDateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutProjectInput | CalendarDateCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarDateCreateManyProjectInputEnvelope
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
  }

  export type FareAttributeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FareAttributeCreateWithoutProjectInput, FareAttributeUncheckedCreateWithoutProjectInput> | FareAttributeCreateWithoutProjectInput[] | FareAttributeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutProjectInput | FareAttributeCreateOrConnectWithoutProjectInput[]
    createMany?: FareAttributeCreateManyProjectInputEnvelope
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
  }

  export type FareRuleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FareRuleCreateWithoutProjectInput, FareRuleUncheckedCreateWithoutProjectInput> | FareRuleCreateWithoutProjectInput[] | FareRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutProjectInput | FareRuleCreateOrConnectWithoutProjectInput[]
    createMany?: FareRuleCreateManyProjectInputEnvelope
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
  }

  export type ShapeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ShapeCreateWithoutProjectInput, ShapeUncheckedCreateWithoutProjectInput> | ShapeCreateWithoutProjectInput[] | ShapeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShapeCreateOrConnectWithoutProjectInput | ShapeCreateOrConnectWithoutProjectInput[]
    createMany?: ShapeCreateManyProjectInputEnvelope
    connect?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TransferCreateWithoutProjectInput, TransferUncheckedCreateWithoutProjectInput> | TransferCreateWithoutProjectInput[] | TransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutProjectInput | TransferCreateOrConnectWithoutProjectInput[]
    createMany?: TransferCreateManyProjectInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type FrequencyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FrequencyCreateWithoutProjectInput, FrequencyUncheckedCreateWithoutProjectInput> | FrequencyCreateWithoutProjectInput[] | FrequencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FrequencyCreateOrConnectWithoutProjectInput | FrequencyCreateOrConnectWithoutProjectInput[]
    createMany?: FrequencyCreateManyProjectInputEnvelope
    connect?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
  }

  export type LevelUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LevelCreateWithoutProjectInput, LevelUncheckedCreateWithoutProjectInput> | LevelCreateWithoutProjectInput[] | LevelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutProjectInput | LevelCreateOrConnectWithoutProjectInput[]
    createMany?: LevelCreateManyProjectInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PathwayCreateWithoutProjectInput, PathwayUncheckedCreateWithoutProjectInput> | PathwayCreateWithoutProjectInput[] | PathwayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutProjectInput | PathwayCreateOrConnectWithoutProjectInput[]
    createMany?: PathwayCreateManyProjectInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type FeedInfoUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FeedInfoCreateWithoutProjectInput, FeedInfoUncheckedCreateWithoutProjectInput> | FeedInfoCreateWithoutProjectInput[] | FeedInfoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FeedInfoCreateOrConnectWithoutProjectInput | FeedInfoCreateOrConnectWithoutProjectInput[]
    createMany?: FeedInfoCreateManyProjectInputEnvelope
    connect?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    upsert?: UserUpsertWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedProjectsInput, UserUpdateWithoutOwnedProjectsInput>, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type ProjectShareUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectShareCreateWithoutProjectInput, ProjectShareUncheckedCreateWithoutProjectInput> | ProjectShareCreateWithoutProjectInput[] | ProjectShareUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutProjectInput | ProjectShareCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectShareUpsertWithWhereUniqueWithoutProjectInput | ProjectShareUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectShareCreateManyProjectInputEnvelope
    set?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    disconnect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    delete?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    update?: ProjectShareUpdateWithWhereUniqueWithoutProjectInput | ProjectShareUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectShareUpdateManyWithWhereWithoutProjectInput | ProjectShareUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectShareScalarWhereInput | ProjectShareScalarWhereInput[]
  }

  export type ProjectInviteUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput> | ProjectInviteCreateWithoutProjectInput[] | ProjectInviteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutProjectInput | ProjectInviteCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectInviteUpsertWithWhereUniqueWithoutProjectInput | ProjectInviteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    set?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    disconnect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    delete?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    update?: ProjectInviteUpdateWithWhereUniqueWithoutProjectInput | ProjectInviteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectInviteUpdateManyWithWhereWithoutProjectInput | ProjectInviteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectInviteScalarWhereInput | ProjectInviteScalarWhereInput[]
  }

  export type AgencyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgencyCreateWithoutProjectInput, AgencyUncheckedCreateWithoutProjectInput> | AgencyCreateWithoutProjectInput[] | AgencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutProjectInput | AgencyCreateOrConnectWithoutProjectInput[]
    upsert?: AgencyUpsertWithWhereUniqueWithoutProjectInput | AgencyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgencyCreateManyProjectInputEnvelope
    set?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    disconnect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    delete?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    update?: AgencyUpdateWithWhereUniqueWithoutProjectInput | AgencyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgencyUpdateManyWithWhereWithoutProjectInput | AgencyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
  }

  export type StopUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StopCreateWithoutProjectInput, StopUncheckedCreateWithoutProjectInput> | StopCreateWithoutProjectInput[] | StopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopCreateOrConnectWithoutProjectInput | StopCreateOrConnectWithoutProjectInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutProjectInput | StopUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StopCreateManyProjectInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutProjectInput | StopUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StopUpdateManyWithWhereWithoutProjectInput | StopUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type RouteUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RouteCreateWithoutProjectInput, RouteUncheckedCreateWithoutProjectInput> | RouteCreateWithoutProjectInput[] | RouteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutProjectInput | RouteCreateOrConnectWithoutProjectInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutProjectInput | RouteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RouteCreateManyProjectInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutProjectInput | RouteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutProjectInput | RouteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type TripUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TripCreateWithoutProjectInput, TripUncheckedCreateWithoutProjectInput> | TripCreateWithoutProjectInput[] | TripUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TripCreateOrConnectWithoutProjectInput | TripCreateOrConnectWithoutProjectInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutProjectInput | TripUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TripCreateManyProjectInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutProjectInput | TripUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TripUpdateManyWithWhereWithoutProjectInput | TripUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type StopTimeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StopTimeCreateWithoutProjectInput, StopTimeUncheckedCreateWithoutProjectInput> | StopTimeCreateWithoutProjectInput[] | StopTimeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutProjectInput | StopTimeCreateOrConnectWithoutProjectInput[]
    upsert?: StopTimeUpsertWithWhereUniqueWithoutProjectInput | StopTimeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StopTimeCreateManyProjectInputEnvelope
    set?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    disconnect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    delete?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    update?: StopTimeUpdateWithWhereUniqueWithoutProjectInput | StopTimeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StopTimeUpdateManyWithWhereWithoutProjectInput | StopTimeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
  }

  export type CalendarUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarCreateWithoutProjectInput, CalendarUncheckedCreateWithoutProjectInput> | CalendarCreateWithoutProjectInput[] | CalendarUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutProjectInput | CalendarCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutProjectInput | CalendarUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarCreateManyProjectInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutProjectInput | CalendarUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutProjectInput | CalendarUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CalendarDateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarDateCreateWithoutProjectInput, CalendarDateUncheckedCreateWithoutProjectInput> | CalendarDateCreateWithoutProjectInput[] | CalendarDateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutProjectInput | CalendarDateCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarDateUpsertWithWhereUniqueWithoutProjectInput | CalendarDateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarDateCreateManyProjectInputEnvelope
    set?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    disconnect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    delete?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    update?: CalendarDateUpdateWithWhereUniqueWithoutProjectInput | CalendarDateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarDateUpdateManyWithWhereWithoutProjectInput | CalendarDateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarDateScalarWhereInput | CalendarDateScalarWhereInput[]
  }

  export type FareAttributeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FareAttributeCreateWithoutProjectInput, FareAttributeUncheckedCreateWithoutProjectInput> | FareAttributeCreateWithoutProjectInput[] | FareAttributeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutProjectInput | FareAttributeCreateOrConnectWithoutProjectInput[]
    upsert?: FareAttributeUpsertWithWhereUniqueWithoutProjectInput | FareAttributeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FareAttributeCreateManyProjectInputEnvelope
    set?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    disconnect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    delete?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    update?: FareAttributeUpdateWithWhereUniqueWithoutProjectInput | FareAttributeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FareAttributeUpdateManyWithWhereWithoutProjectInput | FareAttributeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FareAttributeScalarWhereInput | FareAttributeScalarWhereInput[]
  }

  export type FareRuleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FareRuleCreateWithoutProjectInput, FareRuleUncheckedCreateWithoutProjectInput> | FareRuleCreateWithoutProjectInput[] | FareRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutProjectInput | FareRuleCreateOrConnectWithoutProjectInput[]
    upsert?: FareRuleUpsertWithWhereUniqueWithoutProjectInput | FareRuleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FareRuleCreateManyProjectInputEnvelope
    set?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    disconnect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    delete?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    update?: FareRuleUpdateWithWhereUniqueWithoutProjectInput | FareRuleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FareRuleUpdateManyWithWhereWithoutProjectInput | FareRuleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
  }

  export type ShapeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShapeCreateWithoutProjectInput, ShapeUncheckedCreateWithoutProjectInput> | ShapeCreateWithoutProjectInput[] | ShapeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShapeCreateOrConnectWithoutProjectInput | ShapeCreateOrConnectWithoutProjectInput[]
    upsert?: ShapeUpsertWithWhereUniqueWithoutProjectInput | ShapeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShapeCreateManyProjectInputEnvelope
    set?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    disconnect?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    delete?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    connect?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    update?: ShapeUpdateWithWhereUniqueWithoutProjectInput | ShapeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShapeUpdateManyWithWhereWithoutProjectInput | ShapeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShapeScalarWhereInput | ShapeScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TransferCreateWithoutProjectInput, TransferUncheckedCreateWithoutProjectInput> | TransferCreateWithoutProjectInput[] | TransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutProjectInput | TransferCreateOrConnectWithoutProjectInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutProjectInput | TransferUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TransferCreateManyProjectInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutProjectInput | TransferUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutProjectInput | TransferUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type FrequencyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FrequencyCreateWithoutProjectInput, FrequencyUncheckedCreateWithoutProjectInput> | FrequencyCreateWithoutProjectInput[] | FrequencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FrequencyCreateOrConnectWithoutProjectInput | FrequencyCreateOrConnectWithoutProjectInput[]
    upsert?: FrequencyUpsertWithWhereUniqueWithoutProjectInput | FrequencyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FrequencyCreateManyProjectInputEnvelope
    set?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    disconnect?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    delete?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    connect?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    update?: FrequencyUpdateWithWhereUniqueWithoutProjectInput | FrequencyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FrequencyUpdateManyWithWhereWithoutProjectInput | FrequencyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FrequencyScalarWhereInput | FrequencyScalarWhereInput[]
  }

  export type LevelUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LevelCreateWithoutProjectInput, LevelUncheckedCreateWithoutProjectInput> | LevelCreateWithoutProjectInput[] | LevelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutProjectInput | LevelCreateOrConnectWithoutProjectInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutProjectInput | LevelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LevelCreateManyProjectInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutProjectInput | LevelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutProjectInput | LevelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PathwayCreateWithoutProjectInput, PathwayUncheckedCreateWithoutProjectInput> | PathwayCreateWithoutProjectInput[] | PathwayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutProjectInput | PathwayCreateOrConnectWithoutProjectInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutProjectInput | PathwayUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PathwayCreateManyProjectInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutProjectInput | PathwayUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutProjectInput | PathwayUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type FeedInfoUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FeedInfoCreateWithoutProjectInput, FeedInfoUncheckedCreateWithoutProjectInput> | FeedInfoCreateWithoutProjectInput[] | FeedInfoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FeedInfoCreateOrConnectWithoutProjectInput | FeedInfoCreateOrConnectWithoutProjectInput[]
    upsert?: FeedInfoUpsertWithWhereUniqueWithoutProjectInput | FeedInfoUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FeedInfoCreateManyProjectInputEnvelope
    set?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    disconnect?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    delete?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    connect?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    update?: FeedInfoUpdateWithWhereUniqueWithoutProjectInput | FeedInfoUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FeedInfoUpdateManyWithWhereWithoutProjectInput | FeedInfoUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FeedInfoScalarWhereInput | FeedInfoScalarWhereInput[]
  }

  export type ProjectShareUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectShareCreateWithoutProjectInput, ProjectShareUncheckedCreateWithoutProjectInput> | ProjectShareCreateWithoutProjectInput[] | ProjectShareUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectShareCreateOrConnectWithoutProjectInput | ProjectShareCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectShareUpsertWithWhereUniqueWithoutProjectInput | ProjectShareUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectShareCreateManyProjectInputEnvelope
    set?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    disconnect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    delete?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    connect?: ProjectShareWhereUniqueInput | ProjectShareWhereUniqueInput[]
    update?: ProjectShareUpdateWithWhereUniqueWithoutProjectInput | ProjectShareUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectShareUpdateManyWithWhereWithoutProjectInput | ProjectShareUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectShareScalarWhereInput | ProjectShareScalarWhereInput[]
  }

  export type ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput> | ProjectInviteCreateWithoutProjectInput[] | ProjectInviteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInviteCreateOrConnectWithoutProjectInput | ProjectInviteCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectInviteUpsertWithWhereUniqueWithoutProjectInput | ProjectInviteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectInviteCreateManyProjectInputEnvelope
    set?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    disconnect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    delete?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    connect?: ProjectInviteWhereUniqueInput | ProjectInviteWhereUniqueInput[]
    update?: ProjectInviteUpdateWithWhereUniqueWithoutProjectInput | ProjectInviteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectInviteUpdateManyWithWhereWithoutProjectInput | ProjectInviteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectInviteScalarWhereInput | ProjectInviteScalarWhereInput[]
  }

  export type AgencyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgencyCreateWithoutProjectInput, AgencyUncheckedCreateWithoutProjectInput> | AgencyCreateWithoutProjectInput[] | AgencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgencyCreateOrConnectWithoutProjectInput | AgencyCreateOrConnectWithoutProjectInput[]
    upsert?: AgencyUpsertWithWhereUniqueWithoutProjectInput | AgencyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgencyCreateManyProjectInputEnvelope
    set?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    disconnect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    delete?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    connect?: AgencyWhereUniqueInput | AgencyWhereUniqueInput[]
    update?: AgencyUpdateWithWhereUniqueWithoutProjectInput | AgencyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgencyUpdateManyWithWhereWithoutProjectInput | AgencyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
  }

  export type StopUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StopCreateWithoutProjectInput, StopUncheckedCreateWithoutProjectInput> | StopCreateWithoutProjectInput[] | StopUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopCreateOrConnectWithoutProjectInput | StopCreateOrConnectWithoutProjectInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutProjectInput | StopUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StopCreateManyProjectInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutProjectInput | StopUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StopUpdateManyWithWhereWithoutProjectInput | StopUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type RouteUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RouteCreateWithoutProjectInput, RouteUncheckedCreateWithoutProjectInput> | RouteCreateWithoutProjectInput[] | RouteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutProjectInput | RouteCreateOrConnectWithoutProjectInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutProjectInput | RouteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RouteCreateManyProjectInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutProjectInput | RouteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutProjectInput | RouteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TripCreateWithoutProjectInput, TripUncheckedCreateWithoutProjectInput> | TripCreateWithoutProjectInput[] | TripUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TripCreateOrConnectWithoutProjectInput | TripCreateOrConnectWithoutProjectInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutProjectInput | TripUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TripCreateManyProjectInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutProjectInput | TripUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TripUpdateManyWithWhereWithoutProjectInput | TripUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type StopTimeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StopTimeCreateWithoutProjectInput, StopTimeUncheckedCreateWithoutProjectInput> | StopTimeCreateWithoutProjectInput[] | StopTimeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutProjectInput | StopTimeCreateOrConnectWithoutProjectInput[]
    upsert?: StopTimeUpsertWithWhereUniqueWithoutProjectInput | StopTimeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StopTimeCreateManyProjectInputEnvelope
    set?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    disconnect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    delete?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    update?: StopTimeUpdateWithWhereUniqueWithoutProjectInput | StopTimeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StopTimeUpdateManyWithWhereWithoutProjectInput | StopTimeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
  }

  export type CalendarUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarCreateWithoutProjectInput, CalendarUncheckedCreateWithoutProjectInput> | CalendarCreateWithoutProjectInput[] | CalendarUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutProjectInput | CalendarCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutProjectInput | CalendarUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarCreateManyProjectInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutProjectInput | CalendarUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutProjectInput | CalendarUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type CalendarDateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarDateCreateWithoutProjectInput, CalendarDateUncheckedCreateWithoutProjectInput> | CalendarDateCreateWithoutProjectInput[] | CalendarDateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutProjectInput | CalendarDateCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarDateUpsertWithWhereUniqueWithoutProjectInput | CalendarDateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarDateCreateManyProjectInputEnvelope
    set?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    disconnect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    delete?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    update?: CalendarDateUpdateWithWhereUniqueWithoutProjectInput | CalendarDateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarDateUpdateManyWithWhereWithoutProjectInput | CalendarDateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarDateScalarWhereInput | CalendarDateScalarWhereInput[]
  }

  export type FareAttributeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FareAttributeCreateWithoutProjectInput, FareAttributeUncheckedCreateWithoutProjectInput> | FareAttributeCreateWithoutProjectInput[] | FareAttributeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutProjectInput | FareAttributeCreateOrConnectWithoutProjectInput[]
    upsert?: FareAttributeUpsertWithWhereUniqueWithoutProjectInput | FareAttributeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FareAttributeCreateManyProjectInputEnvelope
    set?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    disconnect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    delete?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    update?: FareAttributeUpdateWithWhereUniqueWithoutProjectInput | FareAttributeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FareAttributeUpdateManyWithWhereWithoutProjectInput | FareAttributeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FareAttributeScalarWhereInput | FareAttributeScalarWhereInput[]
  }

  export type FareRuleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FareRuleCreateWithoutProjectInput, FareRuleUncheckedCreateWithoutProjectInput> | FareRuleCreateWithoutProjectInput[] | FareRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutProjectInput | FareRuleCreateOrConnectWithoutProjectInput[]
    upsert?: FareRuleUpsertWithWhereUniqueWithoutProjectInput | FareRuleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FareRuleCreateManyProjectInputEnvelope
    set?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    disconnect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    delete?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    update?: FareRuleUpdateWithWhereUniqueWithoutProjectInput | FareRuleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FareRuleUpdateManyWithWhereWithoutProjectInput | FareRuleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
  }

  export type ShapeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ShapeCreateWithoutProjectInput, ShapeUncheckedCreateWithoutProjectInput> | ShapeCreateWithoutProjectInput[] | ShapeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ShapeCreateOrConnectWithoutProjectInput | ShapeCreateOrConnectWithoutProjectInput[]
    upsert?: ShapeUpsertWithWhereUniqueWithoutProjectInput | ShapeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ShapeCreateManyProjectInputEnvelope
    set?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    disconnect?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    delete?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    connect?: ShapeWhereUniqueInput | ShapeWhereUniqueInput[]
    update?: ShapeUpdateWithWhereUniqueWithoutProjectInput | ShapeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ShapeUpdateManyWithWhereWithoutProjectInput | ShapeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ShapeScalarWhereInput | ShapeScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TransferCreateWithoutProjectInput, TransferUncheckedCreateWithoutProjectInput> | TransferCreateWithoutProjectInput[] | TransferUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutProjectInput | TransferCreateOrConnectWithoutProjectInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutProjectInput | TransferUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TransferCreateManyProjectInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutProjectInput | TransferUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutProjectInput | TransferUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type FrequencyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FrequencyCreateWithoutProjectInput, FrequencyUncheckedCreateWithoutProjectInput> | FrequencyCreateWithoutProjectInput[] | FrequencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FrequencyCreateOrConnectWithoutProjectInput | FrequencyCreateOrConnectWithoutProjectInput[]
    upsert?: FrequencyUpsertWithWhereUniqueWithoutProjectInput | FrequencyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FrequencyCreateManyProjectInputEnvelope
    set?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    disconnect?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    delete?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    connect?: FrequencyWhereUniqueInput | FrequencyWhereUniqueInput[]
    update?: FrequencyUpdateWithWhereUniqueWithoutProjectInput | FrequencyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FrequencyUpdateManyWithWhereWithoutProjectInput | FrequencyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FrequencyScalarWhereInput | FrequencyScalarWhereInput[]
  }

  export type LevelUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LevelCreateWithoutProjectInput, LevelUncheckedCreateWithoutProjectInput> | LevelCreateWithoutProjectInput[] | LevelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutProjectInput | LevelCreateOrConnectWithoutProjectInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutProjectInput | LevelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LevelCreateManyProjectInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutProjectInput | LevelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutProjectInput | LevelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PathwayCreateWithoutProjectInput, PathwayUncheckedCreateWithoutProjectInput> | PathwayCreateWithoutProjectInput[] | PathwayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutProjectInput | PathwayCreateOrConnectWithoutProjectInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutProjectInput | PathwayUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PathwayCreateManyProjectInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutProjectInput | PathwayUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutProjectInput | PathwayUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type FeedInfoUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FeedInfoCreateWithoutProjectInput, FeedInfoUncheckedCreateWithoutProjectInput> | FeedInfoCreateWithoutProjectInput[] | FeedInfoUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FeedInfoCreateOrConnectWithoutProjectInput | FeedInfoCreateOrConnectWithoutProjectInput[]
    upsert?: FeedInfoUpsertWithWhereUniqueWithoutProjectInput | FeedInfoUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FeedInfoCreateManyProjectInputEnvelope
    set?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    disconnect?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    delete?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    connect?: FeedInfoWhereUniqueInput | FeedInfoWhereUniqueInput[]
    update?: FeedInfoUpdateWithWhereUniqueWithoutProjectInput | FeedInfoUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FeedInfoUpdateManyWithWhereWithoutProjectInput | FeedInfoUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FeedInfoScalarWhereInput | FeedInfoScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutSharesInput = {
    create?: XOR<UserProjectCreateWithoutSharesInput, UserProjectUncheckedCreateWithoutSharesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutSharesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedProjectsInput = {
    create?: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectRole
  }

  export type UserProjectUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<UserProjectCreateWithoutSharesInput, UserProjectUncheckedCreateWithoutSharesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutSharesInput
    upsert?: UserProjectUpsertWithoutSharesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutSharesInput, UserProjectUpdateWithoutSharesInput>, UserProjectUncheckedUpdateWithoutSharesInput>
  }

  export type UserUpdateOneRequiredWithoutSharedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedProjectsInput
    upsert?: UserUpsertWithoutSharedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedProjectsInput, UserUpdateWithoutSharedProjectsInput>, UserUncheckedUpdateWithoutSharedProjectsInput>
  }

  export type UserProjectCreateNestedOneWithoutInvitesInput = {
    create?: XOR<UserProjectCreateWithoutInvitesInput, UserProjectUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutInvitesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitedProjectsInput = {
    create?: XOR<UserCreateWithoutInvitedProjectsInput, UserUncheckedCreateWithoutInvitedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<UserProjectCreateWithoutInvitesInput, UserProjectUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutInvitesInput
    upsert?: UserProjectUpsertWithoutInvitesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutInvitesInput, UserProjectUpdateWithoutInvitesInput>, UserProjectUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneWithoutInvitedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutInvitedProjectsInput, UserUncheckedCreateWithoutInvitedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitedProjectsInput
    upsert?: UserUpsertWithoutInvitedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitedProjectsInput, UserUpdateWithoutInvitedProjectsInput>, UserUncheckedUpdateWithoutInvitedProjectsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserProjectCreateNestedOneWithoutAgenciesInput = {
    create?: XOR<UserProjectCreateWithoutAgenciesInput, UserProjectUncheckedCreateWithoutAgenciesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutAgenciesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type RouteCreateNestedManyWithoutAgencyInput = {
    create?: XOR<RouteCreateWithoutAgencyInput, RouteUncheckedCreateWithoutAgencyInput> | RouteCreateWithoutAgencyInput[] | RouteUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutAgencyInput | RouteCreateOrConnectWithoutAgencyInput[]
    createMany?: RouteCreateManyAgencyInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type FareAttributeCreateNestedManyWithoutAgencyInput = {
    create?: XOR<FareAttributeCreateWithoutAgencyInput, FareAttributeUncheckedCreateWithoutAgencyInput> | FareAttributeCreateWithoutAgencyInput[] | FareAttributeUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutAgencyInput | FareAttributeCreateOrConnectWithoutAgencyInput[]
    createMany?: FareAttributeCreateManyAgencyInputEnvelope
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
  }

  export type RouteUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<RouteCreateWithoutAgencyInput, RouteUncheckedCreateWithoutAgencyInput> | RouteCreateWithoutAgencyInput[] | RouteUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutAgencyInput | RouteCreateOrConnectWithoutAgencyInput[]
    createMany?: RouteCreateManyAgencyInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type FareAttributeUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<FareAttributeCreateWithoutAgencyInput, FareAttributeUncheckedCreateWithoutAgencyInput> | FareAttributeCreateWithoutAgencyInput[] | FareAttributeUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutAgencyInput | FareAttributeCreateOrConnectWithoutAgencyInput[]
    createMany?: FareAttributeCreateManyAgencyInputEnvelope
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
  }

  export type UserProjectUpdateOneRequiredWithoutAgenciesNestedInput = {
    create?: XOR<UserProjectCreateWithoutAgenciesInput, UserProjectUncheckedCreateWithoutAgenciesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutAgenciesInput
    upsert?: UserProjectUpsertWithoutAgenciesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutAgenciesInput, UserProjectUpdateWithoutAgenciesInput>, UserProjectUncheckedUpdateWithoutAgenciesInput>
  }

  export type RouteUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<RouteCreateWithoutAgencyInput, RouteUncheckedCreateWithoutAgencyInput> | RouteCreateWithoutAgencyInput[] | RouteUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutAgencyInput | RouteCreateOrConnectWithoutAgencyInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutAgencyInput | RouteUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: RouteCreateManyAgencyInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutAgencyInput | RouteUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutAgencyInput | RouteUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type FareAttributeUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<FareAttributeCreateWithoutAgencyInput, FareAttributeUncheckedCreateWithoutAgencyInput> | FareAttributeCreateWithoutAgencyInput[] | FareAttributeUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutAgencyInput | FareAttributeCreateOrConnectWithoutAgencyInput[]
    upsert?: FareAttributeUpsertWithWhereUniqueWithoutAgencyInput | FareAttributeUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: FareAttributeCreateManyAgencyInputEnvelope
    set?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    disconnect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    delete?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    update?: FareAttributeUpdateWithWhereUniqueWithoutAgencyInput | FareAttributeUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: FareAttributeUpdateManyWithWhereWithoutAgencyInput | FareAttributeUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: FareAttributeScalarWhereInput | FareAttributeScalarWhereInput[]
  }

  export type RouteUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<RouteCreateWithoutAgencyInput, RouteUncheckedCreateWithoutAgencyInput> | RouteCreateWithoutAgencyInput[] | RouteUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutAgencyInput | RouteCreateOrConnectWithoutAgencyInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutAgencyInput | RouteUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: RouteCreateManyAgencyInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutAgencyInput | RouteUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutAgencyInput | RouteUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type FareAttributeUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<FareAttributeCreateWithoutAgencyInput, FareAttributeUncheckedCreateWithoutAgencyInput> | FareAttributeCreateWithoutAgencyInput[] | FareAttributeUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: FareAttributeCreateOrConnectWithoutAgencyInput | FareAttributeCreateOrConnectWithoutAgencyInput[]
    upsert?: FareAttributeUpsertWithWhereUniqueWithoutAgencyInput | FareAttributeUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: FareAttributeCreateManyAgencyInputEnvelope
    set?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    disconnect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    delete?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    connect?: FareAttributeWhereUniqueInput | FareAttributeWhereUniqueInput[]
    update?: FareAttributeUpdateWithWhereUniqueWithoutAgencyInput | FareAttributeUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: FareAttributeUpdateManyWithWhereWithoutAgencyInput | FareAttributeUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: FareAttributeScalarWhereInput | FareAttributeScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutStopsInput = {
    create?: XOR<UserProjectCreateWithoutStopsInput, UserProjectUncheckedCreateWithoutStopsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutStopsInput
    connect?: UserProjectWhereUniqueInput
  }

  export type StopTimeCreateNestedManyWithoutStopInput = {
    create?: XOR<StopTimeCreateWithoutStopInput, StopTimeUncheckedCreateWithoutStopInput> | StopTimeCreateWithoutStopInput[] | StopTimeUncheckedCreateWithoutStopInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutStopInput | StopTimeCreateOrConnectWithoutStopInput[]
    createMany?: StopTimeCreateManyStopInputEnvelope
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromStopInput = {
    create?: XOR<TransferCreateWithoutFromStopInput, TransferUncheckedCreateWithoutFromStopInput> | TransferCreateWithoutFromStopInput[] | TransferUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStopInput | TransferCreateOrConnectWithoutFromStopInput[]
    createMany?: TransferCreateManyFromStopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToStopInput = {
    create?: XOR<TransferCreateWithoutToStopInput, TransferUncheckedCreateWithoutToStopInput> | TransferCreateWithoutToStopInput[] | TransferUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStopInput | TransferCreateOrConnectWithoutToStopInput[]
    createMany?: TransferCreateManyToStopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutFromStopInput = {
    create?: XOR<PathwayCreateWithoutFromStopInput, PathwayUncheckedCreateWithoutFromStopInput> | PathwayCreateWithoutFromStopInput[] | PathwayUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutFromStopInput | PathwayCreateOrConnectWithoutFromStopInput[]
    createMany?: PathwayCreateManyFromStopInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutToStopInput = {
    create?: XOR<PathwayCreateWithoutToStopInput, PathwayUncheckedCreateWithoutToStopInput> | PathwayCreateWithoutToStopInput[] | PathwayUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutToStopInput | PathwayCreateOrConnectWithoutToStopInput[]
    createMany?: PathwayCreateManyToStopInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type StopCreateNestedOneWithoutChildStopsInput = {
    create?: XOR<StopCreateWithoutChildStopsInput, StopUncheckedCreateWithoutChildStopsInput>
    connectOrCreate?: StopCreateOrConnectWithoutChildStopsInput
    connect?: StopWhereUniqueInput
  }

  export type StopCreateNestedManyWithoutParentStopInput = {
    create?: XOR<StopCreateWithoutParentStopInput, StopUncheckedCreateWithoutParentStopInput> | StopCreateWithoutParentStopInput[] | StopUncheckedCreateWithoutParentStopInput[]
    connectOrCreate?: StopCreateOrConnectWithoutParentStopInput | StopCreateOrConnectWithoutParentStopInput[]
    createMany?: StopCreateManyParentStopInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type LevelCreateNestedOneWithoutStopsInput = {
    create?: XOR<LevelCreateWithoutStopsInput, LevelUncheckedCreateWithoutStopsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutStopsInput
    connect?: LevelWhereUniqueInput
  }

  export type StopTimeUncheckedCreateNestedManyWithoutStopInput = {
    create?: XOR<StopTimeCreateWithoutStopInput, StopTimeUncheckedCreateWithoutStopInput> | StopTimeCreateWithoutStopInput[] | StopTimeUncheckedCreateWithoutStopInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutStopInput | StopTimeCreateOrConnectWithoutStopInput[]
    createMany?: StopTimeCreateManyStopInputEnvelope
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromStopInput = {
    create?: XOR<TransferCreateWithoutFromStopInput, TransferUncheckedCreateWithoutFromStopInput> | TransferCreateWithoutFromStopInput[] | TransferUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStopInput | TransferCreateOrConnectWithoutFromStopInput[]
    createMany?: TransferCreateManyFromStopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToStopInput = {
    create?: XOR<TransferCreateWithoutToStopInput, TransferUncheckedCreateWithoutToStopInput> | TransferCreateWithoutToStopInput[] | TransferUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStopInput | TransferCreateOrConnectWithoutToStopInput[]
    createMany?: TransferCreateManyToStopInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutFromStopInput = {
    create?: XOR<PathwayCreateWithoutFromStopInput, PathwayUncheckedCreateWithoutFromStopInput> | PathwayCreateWithoutFromStopInput[] | PathwayUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutFromStopInput | PathwayCreateOrConnectWithoutFromStopInput[]
    createMany?: PathwayCreateManyFromStopInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutToStopInput = {
    create?: XOR<PathwayCreateWithoutToStopInput, PathwayUncheckedCreateWithoutToStopInput> | PathwayCreateWithoutToStopInput[] | PathwayUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutToStopInput | PathwayCreateOrConnectWithoutToStopInput[]
    createMany?: PathwayCreateManyToStopInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type StopUncheckedCreateNestedManyWithoutParentStopInput = {
    create?: XOR<StopCreateWithoutParentStopInput, StopUncheckedCreateWithoutParentStopInput> | StopCreateWithoutParentStopInput[] | StopUncheckedCreateWithoutParentStopInput[]
    connectOrCreate?: StopCreateOrConnectWithoutParentStopInput | StopCreateOrConnectWithoutParentStopInput[]
    createMany?: StopCreateManyParentStopInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProjectUpdateOneRequiredWithoutStopsNestedInput = {
    create?: XOR<UserProjectCreateWithoutStopsInput, UserProjectUncheckedCreateWithoutStopsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutStopsInput
    upsert?: UserProjectUpsertWithoutStopsInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutStopsInput, UserProjectUpdateWithoutStopsInput>, UserProjectUncheckedUpdateWithoutStopsInput>
  }

  export type StopTimeUpdateManyWithoutStopNestedInput = {
    create?: XOR<StopTimeCreateWithoutStopInput, StopTimeUncheckedCreateWithoutStopInput> | StopTimeCreateWithoutStopInput[] | StopTimeUncheckedCreateWithoutStopInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutStopInput | StopTimeCreateOrConnectWithoutStopInput[]
    upsert?: StopTimeUpsertWithWhereUniqueWithoutStopInput | StopTimeUpsertWithWhereUniqueWithoutStopInput[]
    createMany?: StopTimeCreateManyStopInputEnvelope
    set?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    disconnect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    delete?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    update?: StopTimeUpdateWithWhereUniqueWithoutStopInput | StopTimeUpdateWithWhereUniqueWithoutStopInput[]
    updateMany?: StopTimeUpdateManyWithWhereWithoutStopInput | StopTimeUpdateManyWithWhereWithoutStopInput[]
    deleteMany?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromStopNestedInput = {
    create?: XOR<TransferCreateWithoutFromStopInput, TransferUncheckedCreateWithoutFromStopInput> | TransferCreateWithoutFromStopInput[] | TransferUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStopInput | TransferCreateOrConnectWithoutFromStopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromStopInput | TransferUpsertWithWhereUniqueWithoutFromStopInput[]
    createMany?: TransferCreateManyFromStopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromStopInput | TransferUpdateWithWhereUniqueWithoutFromStopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromStopInput | TransferUpdateManyWithWhereWithoutFromStopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToStopNestedInput = {
    create?: XOR<TransferCreateWithoutToStopInput, TransferUncheckedCreateWithoutToStopInput> | TransferCreateWithoutToStopInput[] | TransferUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStopInput | TransferCreateOrConnectWithoutToStopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToStopInput | TransferUpsertWithWhereUniqueWithoutToStopInput[]
    createMany?: TransferCreateManyToStopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToStopInput | TransferUpdateWithWhereUniqueWithoutToStopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToStopInput | TransferUpdateManyWithWhereWithoutToStopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutFromStopNestedInput = {
    create?: XOR<PathwayCreateWithoutFromStopInput, PathwayUncheckedCreateWithoutFromStopInput> | PathwayCreateWithoutFromStopInput[] | PathwayUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutFromStopInput | PathwayCreateOrConnectWithoutFromStopInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutFromStopInput | PathwayUpsertWithWhereUniqueWithoutFromStopInput[]
    createMany?: PathwayCreateManyFromStopInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutFromStopInput | PathwayUpdateWithWhereUniqueWithoutFromStopInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutFromStopInput | PathwayUpdateManyWithWhereWithoutFromStopInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutToStopNestedInput = {
    create?: XOR<PathwayCreateWithoutToStopInput, PathwayUncheckedCreateWithoutToStopInput> | PathwayCreateWithoutToStopInput[] | PathwayUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutToStopInput | PathwayCreateOrConnectWithoutToStopInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutToStopInput | PathwayUpsertWithWhereUniqueWithoutToStopInput[]
    createMany?: PathwayCreateManyToStopInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutToStopInput | PathwayUpdateWithWhereUniqueWithoutToStopInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutToStopInput | PathwayUpdateManyWithWhereWithoutToStopInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type StopUpdateOneWithoutChildStopsNestedInput = {
    create?: XOR<StopCreateWithoutChildStopsInput, StopUncheckedCreateWithoutChildStopsInput>
    connectOrCreate?: StopCreateOrConnectWithoutChildStopsInput
    upsert?: StopUpsertWithoutChildStopsInput
    disconnect?: StopWhereInput | boolean
    delete?: StopWhereInput | boolean
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutChildStopsInput, StopUpdateWithoutChildStopsInput>, StopUncheckedUpdateWithoutChildStopsInput>
  }

  export type StopUpdateManyWithoutParentStopNestedInput = {
    create?: XOR<StopCreateWithoutParentStopInput, StopUncheckedCreateWithoutParentStopInput> | StopCreateWithoutParentStopInput[] | StopUncheckedCreateWithoutParentStopInput[]
    connectOrCreate?: StopCreateOrConnectWithoutParentStopInput | StopCreateOrConnectWithoutParentStopInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutParentStopInput | StopUpsertWithWhereUniqueWithoutParentStopInput[]
    createMany?: StopCreateManyParentStopInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutParentStopInput | StopUpdateWithWhereUniqueWithoutParentStopInput[]
    updateMany?: StopUpdateManyWithWhereWithoutParentStopInput | StopUpdateManyWithWhereWithoutParentStopInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type LevelUpdateOneWithoutStopsNestedInput = {
    create?: XOR<LevelCreateWithoutStopsInput, LevelUncheckedCreateWithoutStopsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutStopsInput
    upsert?: LevelUpsertWithoutStopsInput
    disconnect?: LevelWhereInput | boolean
    delete?: LevelWhereInput | boolean
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutStopsInput, LevelUpdateWithoutStopsInput>, LevelUncheckedUpdateWithoutStopsInput>
  }

  export type StopTimeUncheckedUpdateManyWithoutStopNestedInput = {
    create?: XOR<StopTimeCreateWithoutStopInput, StopTimeUncheckedCreateWithoutStopInput> | StopTimeCreateWithoutStopInput[] | StopTimeUncheckedCreateWithoutStopInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutStopInput | StopTimeCreateOrConnectWithoutStopInput[]
    upsert?: StopTimeUpsertWithWhereUniqueWithoutStopInput | StopTimeUpsertWithWhereUniqueWithoutStopInput[]
    createMany?: StopTimeCreateManyStopInputEnvelope
    set?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    disconnect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    delete?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    update?: StopTimeUpdateWithWhereUniqueWithoutStopInput | StopTimeUpdateWithWhereUniqueWithoutStopInput[]
    updateMany?: StopTimeUpdateManyWithWhereWithoutStopInput | StopTimeUpdateManyWithWhereWithoutStopInput[]
    deleteMany?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromStopNestedInput = {
    create?: XOR<TransferCreateWithoutFromStopInput, TransferUncheckedCreateWithoutFromStopInput> | TransferCreateWithoutFromStopInput[] | TransferUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStopInput | TransferCreateOrConnectWithoutFromStopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromStopInput | TransferUpsertWithWhereUniqueWithoutFromStopInput[]
    createMany?: TransferCreateManyFromStopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromStopInput | TransferUpdateWithWhereUniqueWithoutFromStopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromStopInput | TransferUpdateManyWithWhereWithoutFromStopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToStopNestedInput = {
    create?: XOR<TransferCreateWithoutToStopInput, TransferUncheckedCreateWithoutToStopInput> | TransferCreateWithoutToStopInput[] | TransferUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStopInput | TransferCreateOrConnectWithoutToStopInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToStopInput | TransferUpsertWithWhereUniqueWithoutToStopInput[]
    createMany?: TransferCreateManyToStopInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToStopInput | TransferUpdateWithWhereUniqueWithoutToStopInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToStopInput | TransferUpdateManyWithWhereWithoutToStopInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutFromStopNestedInput = {
    create?: XOR<PathwayCreateWithoutFromStopInput, PathwayUncheckedCreateWithoutFromStopInput> | PathwayCreateWithoutFromStopInput[] | PathwayUncheckedCreateWithoutFromStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutFromStopInput | PathwayCreateOrConnectWithoutFromStopInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutFromStopInput | PathwayUpsertWithWhereUniqueWithoutFromStopInput[]
    createMany?: PathwayCreateManyFromStopInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutFromStopInput | PathwayUpdateWithWhereUniqueWithoutFromStopInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutFromStopInput | PathwayUpdateManyWithWhereWithoutFromStopInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutToStopNestedInput = {
    create?: XOR<PathwayCreateWithoutToStopInput, PathwayUncheckedCreateWithoutToStopInput> | PathwayCreateWithoutToStopInput[] | PathwayUncheckedCreateWithoutToStopInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutToStopInput | PathwayCreateOrConnectWithoutToStopInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutToStopInput | PathwayUpsertWithWhereUniqueWithoutToStopInput[]
    createMany?: PathwayCreateManyToStopInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutToStopInput | PathwayUpdateWithWhereUniqueWithoutToStopInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutToStopInput | PathwayUpdateManyWithWhereWithoutToStopInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type StopUncheckedUpdateManyWithoutParentStopNestedInput = {
    create?: XOR<StopCreateWithoutParentStopInput, StopUncheckedCreateWithoutParentStopInput> | StopCreateWithoutParentStopInput[] | StopUncheckedCreateWithoutParentStopInput[]
    connectOrCreate?: StopCreateOrConnectWithoutParentStopInput | StopCreateOrConnectWithoutParentStopInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutParentStopInput | StopUpsertWithWhereUniqueWithoutParentStopInput[]
    createMany?: StopCreateManyParentStopInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutParentStopInput | StopUpdateWithWhereUniqueWithoutParentStopInput[]
    updateMany?: StopUpdateManyWithWhereWithoutParentStopInput | StopUpdateManyWithWhereWithoutParentStopInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutRoutesInput = {
    create?: XOR<UserProjectCreateWithoutRoutesInput, UserProjectUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutRoutesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutRoutesInput = {
    create?: XOR<AgencyCreateWithoutRoutesInput, AgencyUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRoutesInput
    connect?: AgencyWhereUniqueInput
  }

  export type TripCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type FareRuleCreateNestedManyWithoutRouteInput = {
    create?: XOR<FareRuleCreateWithoutRouteInput, FareRuleUncheckedCreateWithoutRouteInput> | FareRuleCreateWithoutRouteInput[] | FareRuleUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutRouteInput | FareRuleCreateOrConnectWithoutRouteInput[]
    createMany?: FareRuleCreateManyRouteInputEnvelope
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type FareRuleUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<FareRuleCreateWithoutRouteInput, FareRuleUncheckedCreateWithoutRouteInput> | FareRuleCreateWithoutRouteInput[] | FareRuleUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutRouteInput | FareRuleCreateOrConnectWithoutRouteInput[]
    createMany?: FareRuleCreateManyRouteInputEnvelope
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
  }

  export type UserProjectUpdateOneRequiredWithoutRoutesNestedInput = {
    create?: XOR<UserProjectCreateWithoutRoutesInput, UserProjectUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutRoutesInput
    upsert?: UserProjectUpsertWithoutRoutesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutRoutesInput, UserProjectUpdateWithoutRoutesInput>, UserProjectUncheckedUpdateWithoutRoutesInput>
  }

  export type AgencyUpdateOneWithoutRoutesNestedInput = {
    create?: XOR<AgencyCreateWithoutRoutesInput, AgencyUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutRoutesInput
    upsert?: AgencyUpsertWithoutRoutesInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutRoutesInput, AgencyUpdateWithoutRoutesInput>, AgencyUncheckedUpdateWithoutRoutesInput>
  }

  export type TripUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutRouteInput | TripUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutRouteInput | TripUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripUpdateManyWithWhereWithoutRouteInput | TripUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type FareRuleUpdateManyWithoutRouteNestedInput = {
    create?: XOR<FareRuleCreateWithoutRouteInput, FareRuleUncheckedCreateWithoutRouteInput> | FareRuleCreateWithoutRouteInput[] | FareRuleUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutRouteInput | FareRuleCreateOrConnectWithoutRouteInput[]
    upsert?: FareRuleUpsertWithWhereUniqueWithoutRouteInput | FareRuleUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: FareRuleCreateManyRouteInputEnvelope
    set?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    disconnect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    delete?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    update?: FareRuleUpdateWithWhereUniqueWithoutRouteInput | FareRuleUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: FareRuleUpdateManyWithWhereWithoutRouteInput | FareRuleUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutRouteInput | TripUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutRouteInput | TripUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripUpdateManyWithWhereWithoutRouteInput | TripUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type FareRuleUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<FareRuleCreateWithoutRouteInput, FareRuleUncheckedCreateWithoutRouteInput> | FareRuleCreateWithoutRouteInput[] | FareRuleUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutRouteInput | FareRuleCreateOrConnectWithoutRouteInput[]
    upsert?: FareRuleUpsertWithWhereUniqueWithoutRouteInput | FareRuleUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: FareRuleCreateManyRouteInputEnvelope
    set?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    disconnect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    delete?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    update?: FareRuleUpdateWithWhereUniqueWithoutRouteInput | FareRuleUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: FareRuleUpdateManyWithWhereWithoutRouteInput | FareRuleUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutTripsInput = {
    create?: XOR<UserProjectCreateWithoutTripsInput, UserProjectUncheckedCreateWithoutTripsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutTripsInput
    connect?: UserProjectWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutTripsInput = {
    create?: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripsInput
    connect?: RouteWhereUniqueInput
  }

  export type CalendarCreateNestedOneWithoutTripsInput = {
    create?: XOR<CalendarCreateWithoutTripsInput, CalendarUncheckedCreateWithoutTripsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutTripsInput
    connect?: CalendarWhereUniqueInput
  }

  export type StopTimeCreateNestedManyWithoutTripInput = {
    create?: XOR<StopTimeCreateWithoutTripInput, StopTimeUncheckedCreateWithoutTripInput> | StopTimeCreateWithoutTripInput[] | StopTimeUncheckedCreateWithoutTripInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutTripInput | StopTimeCreateOrConnectWithoutTripInput[]
    createMany?: StopTimeCreateManyTripInputEnvelope
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
  }

  export type StopTimeUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<StopTimeCreateWithoutTripInput, StopTimeUncheckedCreateWithoutTripInput> | StopTimeCreateWithoutTripInput[] | StopTimeUncheckedCreateWithoutTripInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutTripInput | StopTimeCreateOrConnectWithoutTripInput[]
    createMany?: StopTimeCreateManyTripInputEnvelope
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
  }

  export type UserProjectUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<UserProjectCreateWithoutTripsInput, UserProjectUncheckedCreateWithoutTripsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutTripsInput
    upsert?: UserProjectUpsertWithoutTripsInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutTripsInput, UserProjectUpdateWithoutTripsInput>, UserProjectUncheckedUpdateWithoutTripsInput>
  }

  export type RouteUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripsInput
    upsert?: RouteUpsertWithoutTripsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutTripsInput, RouteUpdateWithoutTripsInput>, RouteUncheckedUpdateWithoutTripsInput>
  }

  export type CalendarUpdateOneWithoutTripsNestedInput = {
    create?: XOR<CalendarCreateWithoutTripsInput, CalendarUncheckedCreateWithoutTripsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutTripsInput
    upsert?: CalendarUpsertWithoutTripsInput
    disconnect?: CalendarWhereInput | boolean
    delete?: CalendarWhereInput | boolean
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutTripsInput, CalendarUpdateWithoutTripsInput>, CalendarUncheckedUpdateWithoutTripsInput>
  }

  export type StopTimeUpdateManyWithoutTripNestedInput = {
    create?: XOR<StopTimeCreateWithoutTripInput, StopTimeUncheckedCreateWithoutTripInput> | StopTimeCreateWithoutTripInput[] | StopTimeUncheckedCreateWithoutTripInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutTripInput | StopTimeCreateOrConnectWithoutTripInput[]
    upsert?: StopTimeUpsertWithWhereUniqueWithoutTripInput | StopTimeUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: StopTimeCreateManyTripInputEnvelope
    set?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    disconnect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    delete?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    update?: StopTimeUpdateWithWhereUniqueWithoutTripInput | StopTimeUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: StopTimeUpdateManyWithWhereWithoutTripInput | StopTimeUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
  }

  export type StopTimeUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<StopTimeCreateWithoutTripInput, StopTimeUncheckedCreateWithoutTripInput> | StopTimeCreateWithoutTripInput[] | StopTimeUncheckedCreateWithoutTripInput[]
    connectOrCreate?: StopTimeCreateOrConnectWithoutTripInput | StopTimeCreateOrConnectWithoutTripInput[]
    upsert?: StopTimeUpsertWithWhereUniqueWithoutTripInput | StopTimeUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: StopTimeCreateManyTripInputEnvelope
    set?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    disconnect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    delete?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    connect?: StopTimeWhereUniqueInput | StopTimeWhereUniqueInput[]
    update?: StopTimeUpdateWithWhereUniqueWithoutTripInput | StopTimeUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: StopTimeUpdateManyWithWhereWithoutTripInput | StopTimeUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutStopTimesInput = {
    create?: XOR<UserProjectCreateWithoutStopTimesInput, UserProjectUncheckedCreateWithoutStopTimesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutStopTimesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type TripCreateNestedOneWithoutStopTimesInput = {
    create?: XOR<TripCreateWithoutStopTimesInput, TripUncheckedCreateWithoutStopTimesInput>
    connectOrCreate?: TripCreateOrConnectWithoutStopTimesInput
    connect?: TripWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutStopTimesInput = {
    create?: XOR<StopCreateWithoutStopTimesInput, StopUncheckedCreateWithoutStopTimesInput>
    connectOrCreate?: StopCreateOrConnectWithoutStopTimesInput
    connect?: StopWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProjectUpdateOneRequiredWithoutStopTimesNestedInput = {
    create?: XOR<UserProjectCreateWithoutStopTimesInput, UserProjectUncheckedCreateWithoutStopTimesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutStopTimesInput
    upsert?: UserProjectUpsertWithoutStopTimesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutStopTimesInput, UserProjectUpdateWithoutStopTimesInput>, UserProjectUncheckedUpdateWithoutStopTimesInput>
  }

  export type TripUpdateOneRequiredWithoutStopTimesNestedInput = {
    create?: XOR<TripCreateWithoutStopTimesInput, TripUncheckedCreateWithoutStopTimesInput>
    connectOrCreate?: TripCreateOrConnectWithoutStopTimesInput
    upsert?: TripUpsertWithoutStopTimesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutStopTimesInput, TripUpdateWithoutStopTimesInput>, TripUncheckedUpdateWithoutStopTimesInput>
  }

  export type StopUpdateOneRequiredWithoutStopTimesNestedInput = {
    create?: XOR<StopCreateWithoutStopTimesInput, StopUncheckedCreateWithoutStopTimesInput>
    connectOrCreate?: StopCreateOrConnectWithoutStopTimesInput
    upsert?: StopUpsertWithoutStopTimesInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutStopTimesInput, StopUpdateWithoutStopTimesInput>, StopUncheckedUpdateWithoutStopTimesInput>
  }

  export type UserProjectCreateNestedOneWithoutCalendarsInput = {
    create?: XOR<UserProjectCreateWithoutCalendarsInput, UserProjectUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutCalendarsInput
    connect?: UserProjectWhereUniqueInput
  }

  export type TripCreateNestedManyWithoutCalendarInput = {
    create?: XOR<TripCreateWithoutCalendarInput, TripUncheckedCreateWithoutCalendarInput> | TripCreateWithoutCalendarInput[] | TripUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TripCreateOrConnectWithoutCalendarInput | TripCreateOrConnectWithoutCalendarInput[]
    createMany?: TripCreateManyCalendarInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type CalendarDateCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarDateCreateWithoutCalendarInput, CalendarDateUncheckedCreateWithoutCalendarInput> | CalendarDateCreateWithoutCalendarInput[] | CalendarDateUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutCalendarInput | CalendarDateCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarDateCreateManyCalendarInputEnvelope
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<TripCreateWithoutCalendarInput, TripUncheckedCreateWithoutCalendarInput> | TripCreateWithoutCalendarInput[] | TripUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TripCreateOrConnectWithoutCalendarInput | TripCreateOrConnectWithoutCalendarInput[]
    createMany?: TripCreateManyCalendarInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type CalendarDateUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<CalendarDateCreateWithoutCalendarInput, CalendarDateUncheckedCreateWithoutCalendarInput> | CalendarDateCreateWithoutCalendarInput[] | CalendarDateUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutCalendarInput | CalendarDateCreateOrConnectWithoutCalendarInput[]
    createMany?: CalendarDateCreateManyCalendarInputEnvelope
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
  }

  export type UserProjectUpdateOneRequiredWithoutCalendarsNestedInput = {
    create?: XOR<UserProjectCreateWithoutCalendarsInput, UserProjectUncheckedCreateWithoutCalendarsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutCalendarsInput
    upsert?: UserProjectUpsertWithoutCalendarsInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutCalendarsInput, UserProjectUpdateWithoutCalendarsInput>, UserProjectUncheckedUpdateWithoutCalendarsInput>
  }

  export type TripUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<TripCreateWithoutCalendarInput, TripUncheckedCreateWithoutCalendarInput> | TripCreateWithoutCalendarInput[] | TripUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TripCreateOrConnectWithoutCalendarInput | TripCreateOrConnectWithoutCalendarInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutCalendarInput | TripUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: TripCreateManyCalendarInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutCalendarInput | TripUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: TripUpdateManyWithWhereWithoutCalendarInput | TripUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type CalendarDateUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarDateCreateWithoutCalendarInput, CalendarDateUncheckedCreateWithoutCalendarInput> | CalendarDateCreateWithoutCalendarInput[] | CalendarDateUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutCalendarInput | CalendarDateCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarDateUpsertWithWhereUniqueWithoutCalendarInput | CalendarDateUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarDateCreateManyCalendarInputEnvelope
    set?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    disconnect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    delete?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    update?: CalendarDateUpdateWithWhereUniqueWithoutCalendarInput | CalendarDateUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarDateUpdateManyWithWhereWithoutCalendarInput | CalendarDateUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarDateScalarWhereInput | CalendarDateScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<TripCreateWithoutCalendarInput, TripUncheckedCreateWithoutCalendarInput> | TripCreateWithoutCalendarInput[] | TripUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TripCreateOrConnectWithoutCalendarInput | TripCreateOrConnectWithoutCalendarInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutCalendarInput | TripUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: TripCreateManyCalendarInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutCalendarInput | TripUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: TripUpdateManyWithWhereWithoutCalendarInput | TripUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type CalendarDateUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<CalendarDateCreateWithoutCalendarInput, CalendarDateUncheckedCreateWithoutCalendarInput> | CalendarDateCreateWithoutCalendarInput[] | CalendarDateUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: CalendarDateCreateOrConnectWithoutCalendarInput | CalendarDateCreateOrConnectWithoutCalendarInput[]
    upsert?: CalendarDateUpsertWithWhereUniqueWithoutCalendarInput | CalendarDateUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: CalendarDateCreateManyCalendarInputEnvelope
    set?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    disconnect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    delete?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    connect?: CalendarDateWhereUniqueInput | CalendarDateWhereUniqueInput[]
    update?: CalendarDateUpdateWithWhereUniqueWithoutCalendarInput | CalendarDateUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: CalendarDateUpdateManyWithWhereWithoutCalendarInput | CalendarDateUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: CalendarDateScalarWhereInput | CalendarDateScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutCalendarDatesInput = {
    create?: XOR<UserProjectCreateWithoutCalendarDatesInput, UserProjectUncheckedCreateWithoutCalendarDatesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutCalendarDatesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type CalendarCreateNestedOneWithoutExceptionsInput = {
    create?: XOR<CalendarCreateWithoutExceptionsInput, CalendarUncheckedCreateWithoutExceptionsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutExceptionsInput
    connect?: CalendarWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutCalendarDatesNestedInput = {
    create?: XOR<UserProjectCreateWithoutCalendarDatesInput, UserProjectUncheckedCreateWithoutCalendarDatesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutCalendarDatesInput
    upsert?: UserProjectUpsertWithoutCalendarDatesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutCalendarDatesInput, UserProjectUpdateWithoutCalendarDatesInput>, UserProjectUncheckedUpdateWithoutCalendarDatesInput>
  }

  export type CalendarUpdateOneRequiredWithoutExceptionsNestedInput = {
    create?: XOR<CalendarCreateWithoutExceptionsInput, CalendarUncheckedCreateWithoutExceptionsInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutExceptionsInput
    upsert?: CalendarUpsertWithoutExceptionsInput
    connect?: CalendarWhereUniqueInput
    update?: XOR<XOR<CalendarUpdateToOneWithWhereWithoutExceptionsInput, CalendarUpdateWithoutExceptionsInput>, CalendarUncheckedUpdateWithoutExceptionsInput>
  }

  export type UserProjectCreateNestedOneWithoutFareAttributesInput = {
    create?: XOR<UserProjectCreateWithoutFareAttributesInput, UserProjectUncheckedCreateWithoutFareAttributesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFareAttributesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutFareAttributesInput = {
    create?: XOR<AgencyCreateWithoutFareAttributesInput, AgencyUncheckedCreateWithoutFareAttributesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutFareAttributesInput
    connect?: AgencyWhereUniqueInput
  }

  export type FareRuleCreateNestedManyWithoutFare_attributeInput = {
    create?: XOR<FareRuleCreateWithoutFare_attributeInput, FareRuleUncheckedCreateWithoutFare_attributeInput> | FareRuleCreateWithoutFare_attributeInput[] | FareRuleUncheckedCreateWithoutFare_attributeInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutFare_attributeInput | FareRuleCreateOrConnectWithoutFare_attributeInput[]
    createMany?: FareRuleCreateManyFare_attributeInputEnvelope
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
  }

  export type FareRuleUncheckedCreateNestedManyWithoutFare_attributeInput = {
    create?: XOR<FareRuleCreateWithoutFare_attributeInput, FareRuleUncheckedCreateWithoutFare_attributeInput> | FareRuleCreateWithoutFare_attributeInput[] | FareRuleUncheckedCreateWithoutFare_attributeInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutFare_attributeInput | FareRuleCreateOrConnectWithoutFare_attributeInput[]
    createMany?: FareRuleCreateManyFare_attributeInputEnvelope
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
  }

  export type UserProjectUpdateOneRequiredWithoutFareAttributesNestedInput = {
    create?: XOR<UserProjectCreateWithoutFareAttributesInput, UserProjectUncheckedCreateWithoutFareAttributesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFareAttributesInput
    upsert?: UserProjectUpsertWithoutFareAttributesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutFareAttributesInput, UserProjectUpdateWithoutFareAttributesInput>, UserProjectUncheckedUpdateWithoutFareAttributesInput>
  }

  export type AgencyUpdateOneWithoutFareAttributesNestedInput = {
    create?: XOR<AgencyCreateWithoutFareAttributesInput, AgencyUncheckedCreateWithoutFareAttributesInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutFareAttributesInput
    upsert?: AgencyUpsertWithoutFareAttributesInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutFareAttributesInput, AgencyUpdateWithoutFareAttributesInput>, AgencyUncheckedUpdateWithoutFareAttributesInput>
  }

  export type FareRuleUpdateManyWithoutFare_attributeNestedInput = {
    create?: XOR<FareRuleCreateWithoutFare_attributeInput, FareRuleUncheckedCreateWithoutFare_attributeInput> | FareRuleCreateWithoutFare_attributeInput[] | FareRuleUncheckedCreateWithoutFare_attributeInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutFare_attributeInput | FareRuleCreateOrConnectWithoutFare_attributeInput[]
    upsert?: FareRuleUpsertWithWhereUniqueWithoutFare_attributeInput | FareRuleUpsertWithWhereUniqueWithoutFare_attributeInput[]
    createMany?: FareRuleCreateManyFare_attributeInputEnvelope
    set?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    disconnect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    delete?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    update?: FareRuleUpdateWithWhereUniqueWithoutFare_attributeInput | FareRuleUpdateWithWhereUniqueWithoutFare_attributeInput[]
    updateMany?: FareRuleUpdateManyWithWhereWithoutFare_attributeInput | FareRuleUpdateManyWithWhereWithoutFare_attributeInput[]
    deleteMany?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
  }

  export type FareRuleUncheckedUpdateManyWithoutFare_attributeNestedInput = {
    create?: XOR<FareRuleCreateWithoutFare_attributeInput, FareRuleUncheckedCreateWithoutFare_attributeInput> | FareRuleCreateWithoutFare_attributeInput[] | FareRuleUncheckedCreateWithoutFare_attributeInput[]
    connectOrCreate?: FareRuleCreateOrConnectWithoutFare_attributeInput | FareRuleCreateOrConnectWithoutFare_attributeInput[]
    upsert?: FareRuleUpsertWithWhereUniqueWithoutFare_attributeInput | FareRuleUpsertWithWhereUniqueWithoutFare_attributeInput[]
    createMany?: FareRuleCreateManyFare_attributeInputEnvelope
    set?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    disconnect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    delete?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    connect?: FareRuleWhereUniqueInput | FareRuleWhereUniqueInput[]
    update?: FareRuleUpdateWithWhereUniqueWithoutFare_attributeInput | FareRuleUpdateWithWhereUniqueWithoutFare_attributeInput[]
    updateMany?: FareRuleUpdateManyWithWhereWithoutFare_attributeInput | FareRuleUpdateManyWithWhereWithoutFare_attributeInput[]
    deleteMany?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutFareRulesInput = {
    create?: XOR<UserProjectCreateWithoutFareRulesInput, UserProjectUncheckedCreateWithoutFareRulesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFareRulesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type FareAttributeCreateNestedOneWithoutFareRulesInput = {
    create?: XOR<FareAttributeCreateWithoutFareRulesInput, FareAttributeUncheckedCreateWithoutFareRulesInput>
    connectOrCreate?: FareAttributeCreateOrConnectWithoutFareRulesInput
    connect?: FareAttributeWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutFareRulesInput = {
    create?: XOR<RouteCreateWithoutFareRulesInput, RouteUncheckedCreateWithoutFareRulesInput>
    connectOrCreate?: RouteCreateOrConnectWithoutFareRulesInput
    connect?: RouteWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutFareRulesNestedInput = {
    create?: XOR<UserProjectCreateWithoutFareRulesInput, UserProjectUncheckedCreateWithoutFareRulesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFareRulesInput
    upsert?: UserProjectUpsertWithoutFareRulesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutFareRulesInput, UserProjectUpdateWithoutFareRulesInput>, UserProjectUncheckedUpdateWithoutFareRulesInput>
  }

  export type FareAttributeUpdateOneRequiredWithoutFareRulesNestedInput = {
    create?: XOR<FareAttributeCreateWithoutFareRulesInput, FareAttributeUncheckedCreateWithoutFareRulesInput>
    connectOrCreate?: FareAttributeCreateOrConnectWithoutFareRulesInput
    upsert?: FareAttributeUpsertWithoutFareRulesInput
    connect?: FareAttributeWhereUniqueInput
    update?: XOR<XOR<FareAttributeUpdateToOneWithWhereWithoutFareRulesInput, FareAttributeUpdateWithoutFareRulesInput>, FareAttributeUncheckedUpdateWithoutFareRulesInput>
  }

  export type RouteUpdateOneWithoutFareRulesNestedInput = {
    create?: XOR<RouteCreateWithoutFareRulesInput, RouteUncheckedCreateWithoutFareRulesInput>
    connectOrCreate?: RouteCreateOrConnectWithoutFareRulesInput
    upsert?: RouteUpsertWithoutFareRulesInput
    disconnect?: RouteWhereInput | boolean
    delete?: RouteWhereInput | boolean
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutFareRulesInput, RouteUpdateWithoutFareRulesInput>, RouteUncheckedUpdateWithoutFareRulesInput>
  }

  export type UserProjectCreateNestedOneWithoutShapesInput = {
    create?: XOR<UserProjectCreateWithoutShapesInput, UserProjectUncheckedCreateWithoutShapesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutShapesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutShapesNestedInput = {
    create?: XOR<UserProjectCreateWithoutShapesInput, UserProjectUncheckedCreateWithoutShapesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutShapesInput
    upsert?: UserProjectUpsertWithoutShapesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutShapesInput, UserProjectUpdateWithoutShapesInput>, UserProjectUncheckedUpdateWithoutShapesInput>
  }

  export type UserProjectCreateNestedOneWithoutTransfersInput = {
    create?: XOR<UserProjectCreateWithoutTransfersInput, UserProjectUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutTransfersInput
    connect?: UserProjectWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutTransfersInput = {
    create?: XOR<StopCreateWithoutTransfersInput, StopUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: StopCreateOrConnectWithoutTransfersInput
    connect?: StopWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<StopCreateWithoutTransfersToInput, StopUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: StopCreateOrConnectWithoutTransfersToInput
    connect?: StopWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<UserProjectCreateWithoutTransfersInput, UserProjectUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutTransfersInput
    upsert?: UserProjectUpsertWithoutTransfersInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutTransfersInput, UserProjectUpdateWithoutTransfersInput>, UserProjectUncheckedUpdateWithoutTransfersInput>
  }

  export type StopUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<StopCreateWithoutTransfersInput, StopUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: StopCreateOrConnectWithoutTransfersInput
    upsert?: StopUpsertWithoutTransfersInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutTransfersInput, StopUpdateWithoutTransfersInput>, StopUncheckedUpdateWithoutTransfersInput>
  }

  export type StopUpdateOneRequiredWithoutTransfersToNestedInput = {
    create?: XOR<StopCreateWithoutTransfersToInput, StopUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: StopCreateOrConnectWithoutTransfersToInput
    upsert?: StopUpsertWithoutTransfersToInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutTransfersToInput, StopUpdateWithoutTransfersToInput>, StopUncheckedUpdateWithoutTransfersToInput>
  }

  export type UserProjectCreateNestedOneWithoutFrequenciesInput = {
    create?: XOR<UserProjectCreateWithoutFrequenciesInput, UserProjectUncheckedCreateWithoutFrequenciesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFrequenciesInput
    connect?: UserProjectWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutFrequenciesNestedInput = {
    create?: XOR<UserProjectCreateWithoutFrequenciesInput, UserProjectUncheckedCreateWithoutFrequenciesInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFrequenciesInput
    upsert?: UserProjectUpsertWithoutFrequenciesInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutFrequenciesInput, UserProjectUpdateWithoutFrequenciesInput>, UserProjectUncheckedUpdateWithoutFrequenciesInput>
  }

  export type UserProjectCreateNestedOneWithoutLevelsInput = {
    create?: XOR<UserProjectCreateWithoutLevelsInput, UserProjectUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutLevelsInput
    connect?: UserProjectWhereUniqueInput
  }

  export type StopCreateNestedManyWithoutLevelInput = {
    create?: XOR<StopCreateWithoutLevelInput, StopUncheckedCreateWithoutLevelInput> | StopCreateWithoutLevelInput[] | StopUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLevelInput | StopCreateOrConnectWithoutLevelInput[]
    createMany?: StopCreateManyLevelInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type PathwayCreateNestedManyWithoutLevelInput = {
    create?: XOR<PathwayCreateWithoutLevelInput, PathwayUncheckedCreateWithoutLevelInput> | PathwayCreateWithoutLevelInput[] | PathwayUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutLevelInput | PathwayCreateOrConnectWithoutLevelInput[]
    createMany?: PathwayCreateManyLevelInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type StopUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<StopCreateWithoutLevelInput, StopUncheckedCreateWithoutLevelInput> | StopCreateWithoutLevelInput[] | StopUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLevelInput | StopCreateOrConnectWithoutLevelInput[]
    createMany?: StopCreateManyLevelInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type PathwayUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<PathwayCreateWithoutLevelInput, PathwayUncheckedCreateWithoutLevelInput> | PathwayCreateWithoutLevelInput[] | PathwayUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutLevelInput | PathwayCreateOrConnectWithoutLevelInput[]
    createMany?: PathwayCreateManyLevelInputEnvelope
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
  }

  export type UserProjectUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<UserProjectCreateWithoutLevelsInput, UserProjectUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutLevelsInput
    upsert?: UserProjectUpsertWithoutLevelsInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutLevelsInput, UserProjectUpdateWithoutLevelsInput>, UserProjectUncheckedUpdateWithoutLevelsInput>
  }

  export type StopUpdateManyWithoutLevelNestedInput = {
    create?: XOR<StopCreateWithoutLevelInput, StopUncheckedCreateWithoutLevelInput> | StopCreateWithoutLevelInput[] | StopUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLevelInput | StopCreateOrConnectWithoutLevelInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutLevelInput | StopUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: StopCreateManyLevelInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutLevelInput | StopUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: StopUpdateManyWithWhereWithoutLevelInput | StopUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type PathwayUpdateManyWithoutLevelNestedInput = {
    create?: XOR<PathwayCreateWithoutLevelInput, PathwayUncheckedCreateWithoutLevelInput> | PathwayCreateWithoutLevelInput[] | PathwayUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutLevelInput | PathwayCreateOrConnectWithoutLevelInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutLevelInput | PathwayUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: PathwayCreateManyLevelInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutLevelInput | PathwayUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutLevelInput | PathwayUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type StopUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<StopCreateWithoutLevelInput, StopUncheckedCreateWithoutLevelInput> | StopCreateWithoutLevelInput[] | StopUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLevelInput | StopCreateOrConnectWithoutLevelInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutLevelInput | StopUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: StopCreateManyLevelInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutLevelInput | StopUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: StopUpdateManyWithWhereWithoutLevelInput | StopUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type PathwayUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<PathwayCreateWithoutLevelInput, PathwayUncheckedCreateWithoutLevelInput> | PathwayCreateWithoutLevelInput[] | PathwayUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PathwayCreateOrConnectWithoutLevelInput | PathwayCreateOrConnectWithoutLevelInput[]
    upsert?: PathwayUpsertWithWhereUniqueWithoutLevelInput | PathwayUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: PathwayCreateManyLevelInputEnvelope
    set?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    disconnect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    delete?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    connect?: PathwayWhereUniqueInput | PathwayWhereUniqueInput[]
    update?: PathwayUpdateWithWhereUniqueWithoutLevelInput | PathwayUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: PathwayUpdateManyWithWhereWithoutLevelInput | PathwayUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
  }

  export type UserProjectCreateNestedOneWithoutPathwaysInput = {
    create?: XOR<UserProjectCreateWithoutPathwaysInput, UserProjectUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutPathwaysInput
    connect?: UserProjectWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutPathwaysInput = {
    create?: XOR<StopCreateWithoutPathwaysInput, StopUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: StopCreateOrConnectWithoutPathwaysInput
    connect?: StopWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutPathwaysToInput = {
    create?: XOR<StopCreateWithoutPathwaysToInput, StopUncheckedCreateWithoutPathwaysToInput>
    connectOrCreate?: StopCreateOrConnectWithoutPathwaysToInput
    connect?: StopWhereUniqueInput
  }

  export type LevelCreateNestedOneWithoutPathwaysInput = {
    create?: XOR<LevelCreateWithoutPathwaysInput, LevelUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: LevelCreateOrConnectWithoutPathwaysInput
    connect?: LevelWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutPathwaysNestedInput = {
    create?: XOR<UserProjectCreateWithoutPathwaysInput, UserProjectUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutPathwaysInput
    upsert?: UserProjectUpsertWithoutPathwaysInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutPathwaysInput, UserProjectUpdateWithoutPathwaysInput>, UserProjectUncheckedUpdateWithoutPathwaysInput>
  }

  export type StopUpdateOneRequiredWithoutPathwaysNestedInput = {
    create?: XOR<StopCreateWithoutPathwaysInput, StopUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: StopCreateOrConnectWithoutPathwaysInput
    upsert?: StopUpsertWithoutPathwaysInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutPathwaysInput, StopUpdateWithoutPathwaysInput>, StopUncheckedUpdateWithoutPathwaysInput>
  }

  export type StopUpdateOneRequiredWithoutPathwaysToNestedInput = {
    create?: XOR<StopCreateWithoutPathwaysToInput, StopUncheckedCreateWithoutPathwaysToInput>
    connectOrCreate?: StopCreateOrConnectWithoutPathwaysToInput
    upsert?: StopUpsertWithoutPathwaysToInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutPathwaysToInput, StopUpdateWithoutPathwaysToInput>, StopUncheckedUpdateWithoutPathwaysToInput>
  }

  export type LevelUpdateOneWithoutPathwaysNestedInput = {
    create?: XOR<LevelCreateWithoutPathwaysInput, LevelUncheckedCreateWithoutPathwaysInput>
    connectOrCreate?: LevelCreateOrConnectWithoutPathwaysInput
    upsert?: LevelUpsertWithoutPathwaysInput
    disconnect?: LevelWhereInput | boolean
    delete?: LevelWhereInput | boolean
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutPathwaysInput, LevelUpdateWithoutPathwaysInput>, LevelUncheckedUpdateWithoutPathwaysInput>
  }

  export type UserProjectCreateNestedOneWithoutFeedInfoInput = {
    create?: XOR<UserProjectCreateWithoutFeedInfoInput, UserProjectUncheckedCreateWithoutFeedInfoInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFeedInfoInput
    connect?: UserProjectWhereUniqueInput
  }

  export type UserProjectUpdateOneRequiredWithoutFeedInfoNestedInput = {
    create?: XOR<UserProjectCreateWithoutFeedInfoInput, UserProjectUncheckedCreateWithoutFeedInfoInput>
    connectOrCreate?: UserProjectCreateOrConnectWithoutFeedInfoInput
    upsert?: UserProjectUpsertWithoutFeedInfoInput
    connect?: UserProjectWhereUniqueInput
    update?: XOR<XOR<UserProjectUpdateToOneWithWhereWithoutFeedInfoInput, UserProjectUpdateWithoutFeedInfoInput>, UserProjectUncheckedUpdateWithoutFeedInfoInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    theme?: string
    language?: string
    timezone?: string
    map_default_lat?: number
    map_default_lon?: number
    map_default_zoom?: number
    table_page_size?: number
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    theme?: string
    language?: string
    timezone?: string
    map_default_lat?: number
    map_default_lon?: number
    map_default_zoom?: number
    table_page_size?: number
    notifications?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserProjectCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutOwnerInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutOwnerInput, UserProjectUncheckedCreateWithoutOwnerInput>
  }

  export type UserProjectCreateManyOwnerInputEnvelope = {
    data: UserProjectCreateManyOwnerInput | UserProjectCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectShareCreateWithoutUserInput = {
    id?: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutSharesInput
  }

  export type ProjectShareUncheckedCreateWithoutUserInput = {
    id?: string
    project_id: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectShareCreateOrConnectWithoutUserInput = {
    where: ProjectShareWhereUniqueInput
    create: XOR<ProjectShareCreateWithoutUserInput, ProjectShareUncheckedCreateWithoutUserInput>
  }

  export type ProjectShareCreateManyUserInputEnvelope = {
    data: ProjectShareCreateManyUserInput | ProjectShareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInviteCreateWithoutUserInput = {
    id?: string
    email: string
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
    project: UserProjectCreateNestedOneWithoutInvitesInput
  }

  export type ProjectInviteUncheckedCreateWithoutUserInput = {
    id?: string
    project_id: string
    email: string
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
  }

  export type ProjectInviteCreateOrConnectWithoutUserInput = {
    where: ProjectInviteWhereUniqueInput
    create: XOR<ProjectInviteCreateWithoutUserInput, ProjectInviteUncheckedCreateWithoutUserInput>
  }

  export type ProjectInviteCreateManyUserInputEnvelope = {
    data: ProjectInviteCreateManyUserInput | ProjectInviteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetCreateWithoutUserInput = {
    id?: string
    token: string
    expires_at: Date | string
    used_at?: Date | string | null
    created_at?: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expires_at: Date | string
    used_at?: Date | string | null
    created_at?: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateManyUserInputEnvelope = {
    data: PasswordResetCreateManyUserInput | PasswordResetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    session_token: string
    expires_at: Date | string
    user_agent?: string | null
    ip_address?: string | null
    created_at?: Date | string
    last_active?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    session_token: string
    expires_at: Date | string
    user_agent?: string | null
    ip_address?: string | null
    created_at?: Date | string
    last_active?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    map_default_lat?: FloatFieldUpdateOperationsInput | number
    map_default_lon?: FloatFieldUpdateOperationsInput | number
    map_default_zoom?: IntFieldUpdateOperationsInput | number
    table_page_size?: IntFieldUpdateOperationsInput | number
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    map_default_lat?: FloatFieldUpdateOperationsInput | number
    map_default_lon?: FloatFieldUpdateOperationsInput | number
    map_default_zoom?: IntFieldUpdateOperationsInput | number
    table_page_size?: IntFieldUpdateOperationsInput | number
    notifications?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: UserProjectWhereUniqueInput
    update: XOR<UserProjectUpdateWithoutOwnerInput, UserProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<UserProjectCreateWithoutOwnerInput, UserProjectUncheckedCreateWithoutOwnerInput>
  }

  export type UserProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: UserProjectWhereUniqueInput
    data: XOR<UserProjectUpdateWithoutOwnerInput, UserProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type UserProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: UserProjectScalarWhereInput
    data: XOR<UserProjectUpdateManyMutationInput, UserProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UserProjectScalarWhereInput = {
    AND?: UserProjectScalarWhereInput | UserProjectScalarWhereInput[]
    OR?: UserProjectScalarWhereInput[]
    NOT?: UserProjectScalarWhereInput | UserProjectScalarWhereInput[]
    id?: StringFilter<"UserProject"> | string
    name?: StringFilter<"UserProject"> | string
    description?: StringNullableFilter<"UserProject"> | string | null
    owner_id?: StringFilter<"UserProject"> | string
    is_active?: BoolFilter<"UserProject"> | boolean
    created_at?: DateTimeFilter<"UserProject"> | Date | string
    updated_at?: DateTimeFilter<"UserProject"> | Date | string
  }

  export type ProjectShareUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectShareWhereUniqueInput
    update: XOR<ProjectShareUpdateWithoutUserInput, ProjectShareUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectShareCreateWithoutUserInput, ProjectShareUncheckedCreateWithoutUserInput>
  }

  export type ProjectShareUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectShareWhereUniqueInput
    data: XOR<ProjectShareUpdateWithoutUserInput, ProjectShareUncheckedUpdateWithoutUserInput>
  }

  export type ProjectShareUpdateManyWithWhereWithoutUserInput = {
    where: ProjectShareScalarWhereInput
    data: XOR<ProjectShareUpdateManyMutationInput, ProjectShareUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectShareScalarWhereInput = {
    AND?: ProjectShareScalarWhereInput | ProjectShareScalarWhereInput[]
    OR?: ProjectShareScalarWhereInput[]
    NOT?: ProjectShareScalarWhereInput | ProjectShareScalarWhereInput[]
    id?: StringFilter<"ProjectShare"> | string
    project_id?: StringFilter<"ProjectShare"> | string
    user_id?: StringFilter<"ProjectShare"> | string
    role?: EnumProjectRoleFilter<"ProjectShare"> | $Enums.ProjectRole
    shared_by?: StringFilter<"ProjectShare"> | string
    created_at?: DateTimeFilter<"ProjectShare"> | Date | string
    updated_at?: DateTimeFilter<"ProjectShare"> | Date | string
  }

  export type ProjectInviteUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectInviteWhereUniqueInput
    update: XOR<ProjectInviteUpdateWithoutUserInput, ProjectInviteUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectInviteCreateWithoutUserInput, ProjectInviteUncheckedCreateWithoutUserInput>
  }

  export type ProjectInviteUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectInviteWhereUniqueInput
    data: XOR<ProjectInviteUpdateWithoutUserInput, ProjectInviteUncheckedUpdateWithoutUserInput>
  }

  export type ProjectInviteUpdateManyWithWhereWithoutUserInput = {
    where: ProjectInviteScalarWhereInput
    data: XOR<ProjectInviteUpdateManyMutationInput, ProjectInviteUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectInviteScalarWhereInput = {
    AND?: ProjectInviteScalarWhereInput | ProjectInviteScalarWhereInput[]
    OR?: ProjectInviteScalarWhereInput[]
    NOT?: ProjectInviteScalarWhereInput | ProjectInviteScalarWhereInput[]
    id?: StringFilter<"ProjectInvite"> | string
    project_id?: StringFilter<"ProjectInvite"> | string
    email?: StringFilter<"ProjectInvite"> | string
    user_id?: StringNullableFilter<"ProjectInvite"> | string | null
    role?: EnumProjectRoleFilter<"ProjectInvite"> | $Enums.ProjectRole
    token?: StringFilter<"ProjectInvite"> | string
    invited_by?: StringFilter<"ProjectInvite"> | string
    expires_at?: DateTimeFilter<"ProjectInvite"> | Date | string
    accepted_at?: DateTimeNullableFilter<"ProjectInvite"> | Date | string | null
    created_at?: DateTimeFilter<"ProjectInvite"> | Date | string
  }

  export type PasswordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetScalarWhereInput
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetScalarWhereInput = {
    AND?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    OR?: PasswordResetScalarWhereInput[]
    NOT?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    user_id?: StringFilter<"PasswordReset"> | string
    token?: StringFilter<"PasswordReset"> | string
    expires_at?: DateTimeFilter<"PasswordReset"> | Date | string
    used_at?: DateTimeNullableFilter<"PasswordReset"> | Date | string | null
    created_at?: DateTimeFilter<"PasswordReset"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    user_id?: StringFilter<"UserSession"> | string
    session_token?: StringFilter<"UserSession"> | string
    expires_at?: DateTimeFilter<"UserSession"> | Date | string
    user_agent?: StringNullableFilter<"UserSession"> | string | null
    ip_address?: StringNullableFilter<"UserSession"> | string | null
    created_at?: DateTimeFilter<"UserSession"> | Date | string
    last_active?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    ownedProjects?: UserProjectCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    ownedProjects?: UserProjectUncheckedCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareUncheckedCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedProjects?: UserProjectUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedProjects?: UserProjectUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUncheckedUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    sharedProjects?: ProjectShareCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    sharedProjects?: ProjectShareUncheckedCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type ProjectShareCreateWithoutProjectInput = {
    id?: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutSharedProjectsInput
  }

  export type ProjectShareUncheckedCreateWithoutProjectInput = {
    id?: string
    user_id: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectShareCreateOrConnectWithoutProjectInput = {
    where: ProjectShareWhereUniqueInput
    create: XOR<ProjectShareCreateWithoutProjectInput, ProjectShareUncheckedCreateWithoutProjectInput>
  }

  export type ProjectShareCreateManyProjectInputEnvelope = {
    data: ProjectShareCreateManyProjectInput | ProjectShareCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInviteCreateWithoutProjectInput = {
    id?: string
    email: string
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
    user?: UserCreateNestedOneWithoutInvitedProjectsInput
  }

  export type ProjectInviteUncheckedCreateWithoutProjectInput = {
    id?: string
    email: string
    user_id?: string | null
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
  }

  export type ProjectInviteCreateOrConnectWithoutProjectInput = {
    where: ProjectInviteWhereUniqueInput
    create: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInviteCreateManyProjectInputEnvelope = {
    data: ProjectInviteCreateManyProjectInput | ProjectInviteCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AgencyCreateWithoutProjectInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    routes?: RouteCreateNestedManyWithoutAgencyInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutProjectInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    routes?: RouteUncheckedCreateNestedManyWithoutAgencyInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutProjectInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutProjectInput, AgencyUncheckedCreateWithoutProjectInput>
  }

  export type AgencyCreateManyProjectInputEnvelope = {
    data: AgencyCreateManyProjectInput | AgencyCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type StopCreateWithoutProjectInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutProjectInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutProjectInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutProjectInput, StopUncheckedCreateWithoutProjectInput>
  }

  export type StopCreateManyProjectInputEnvelope = {
    data: StopCreateManyProjectInput | StopCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RouteCreateWithoutProjectInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency?: AgencyCreateNestedOneWithoutRoutesInput
    trips?: TripCreateNestedManyWithoutRouteInput
    fareRules?: FareRuleCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutProjectInput = {
    id?: string
    route_id: string
    agency_id?: string | null
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutProjectInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutProjectInput, RouteUncheckedCreateWithoutProjectInput>
  }

  export type RouteCreateManyProjectInputEnvelope = {
    data: RouteCreateManyProjectInput | RouteCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutProjectInput = {
    id?: string
    trip_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    route: RouteCreateNestedOneWithoutTripsInput
    calendar?: CalendarCreateNestedOneWithoutTripsInput
    stopTimes?: StopTimeCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutProjectInput = {
    id?: string
    trip_id: string
    route_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutProjectInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutProjectInput, TripUncheckedCreateWithoutProjectInput>
  }

  export type TripCreateManyProjectInputEnvelope = {
    data: TripCreateManyProjectInput | TripCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type StopTimeCreateWithoutProjectInput = {
    id?: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trip: TripCreateNestedOneWithoutStopTimesInput
    stop: StopCreateNestedOneWithoutStopTimesInput
  }

  export type StopTimeUncheckedCreateWithoutProjectInput = {
    id?: string
    trip_id: string
    stop_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeCreateOrConnectWithoutProjectInput = {
    where: StopTimeWhereUniqueInput
    create: XOR<StopTimeCreateWithoutProjectInput, StopTimeUncheckedCreateWithoutProjectInput>
  }

  export type StopTimeCreateManyProjectInputEnvelope = {
    data: StopTimeCreateManyProjectInput | StopTimeCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CalendarCreateWithoutProjectInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripCreateNestedManyWithoutCalendarInput
    exceptions?: CalendarDateCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutProjectInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutCalendarInput
    exceptions?: CalendarDateUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutProjectInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutProjectInput, CalendarUncheckedCreateWithoutProjectInput>
  }

  export type CalendarCreateManyProjectInputEnvelope = {
    data: CalendarCreateManyProjectInput | CalendarCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CalendarDateCreateWithoutProjectInput = {
    id?: string
    date: string
    exception_type: number
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calendar: CalendarCreateNestedOneWithoutExceptionsInput
  }

  export type CalendarDateUncheckedCreateWithoutProjectInput = {
    id?: string
    service_id: string
    date: string
    exception_type: number
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarDateCreateOrConnectWithoutProjectInput = {
    where: CalendarDateWhereUniqueInput
    create: XOR<CalendarDateCreateWithoutProjectInput, CalendarDateUncheckedCreateWithoutProjectInput>
  }

  export type CalendarDateCreateManyProjectInputEnvelope = {
    data: CalendarDateCreateManyProjectInput | CalendarDateCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FareAttributeCreateWithoutProjectInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    transfer_duration?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agency?: AgencyCreateNestedOneWithoutFareAttributesInput
    fareRules?: FareRuleCreateNestedManyWithoutFare_attributeInput
  }

  export type FareAttributeUncheckedCreateWithoutProjectInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    agency_id?: string | null
    transfer_duration?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutFare_attributeInput
  }

  export type FareAttributeCreateOrConnectWithoutProjectInput = {
    where: FareAttributeWhereUniqueInput
    create: XOR<FareAttributeCreateWithoutProjectInput, FareAttributeUncheckedCreateWithoutProjectInput>
  }

  export type FareAttributeCreateManyProjectInputEnvelope = {
    data: FareAttributeCreateManyProjectInput | FareAttributeCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FareRuleCreateWithoutProjectInput = {
    id?: string
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fare_attribute: FareAttributeCreateNestedOneWithoutFareRulesInput
    route?: RouteCreateNestedOneWithoutFareRulesInput
  }

  export type FareRuleUncheckedCreateWithoutProjectInput = {
    id?: string
    fare_id: string
    route_id?: string | null
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleCreateOrConnectWithoutProjectInput = {
    where: FareRuleWhereUniqueInput
    create: XOR<FareRuleCreateWithoutProjectInput, FareRuleUncheckedCreateWithoutProjectInput>
  }

  export type FareRuleCreateManyProjectInputEnvelope = {
    data: FareRuleCreateManyProjectInput | FareRuleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ShapeCreateWithoutProjectInput = {
    id?: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShapeUncheckedCreateWithoutProjectInput = {
    id?: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShapeCreateOrConnectWithoutProjectInput = {
    where: ShapeWhereUniqueInput
    create: XOR<ShapeCreateWithoutProjectInput, ShapeUncheckedCreateWithoutProjectInput>
  }

  export type ShapeCreateManyProjectInputEnvelope = {
    data: ShapeCreateManyProjectInput | ShapeCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutProjectInput = {
    id?: string
    transfer_type?: number
    min_transfer_time?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fromStop: StopCreateNestedOneWithoutTransfersInput
    toStop: StopCreateNestedOneWithoutTransfersToInput
  }

  export type TransferUncheckedCreateWithoutProjectInput = {
    id?: string
    from_stop_id: string
    to_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferCreateOrConnectWithoutProjectInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutProjectInput, TransferUncheckedCreateWithoutProjectInput>
  }

  export type TransferCreateManyProjectInputEnvelope = {
    data: TransferCreateManyProjectInput | TransferCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FrequencyCreateWithoutProjectInput = {
    id?: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FrequencyUncheckedCreateWithoutProjectInput = {
    id?: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FrequencyCreateOrConnectWithoutProjectInput = {
    where: FrequencyWhereUniqueInput
    create: XOR<FrequencyCreateWithoutProjectInput, FrequencyUncheckedCreateWithoutProjectInput>
  }

  export type FrequencyCreateManyProjectInputEnvelope = {
    data: FrequencyCreateManyProjectInput | FrequencyCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LevelCreateWithoutProjectInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stops?: StopCreateNestedManyWithoutLevelInput
    pathways?: PathwayCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutProjectInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutLevelInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutProjectInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutProjectInput, LevelUncheckedCreateWithoutProjectInput>
  }

  export type LevelCreateManyProjectInputEnvelope = {
    data: LevelCreateManyProjectInput | LevelCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutProjectInput = {
    id?: string
    pathway_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fromStop: StopCreateNestedOneWithoutPathwaysInput
    toStop: StopCreateNestedOneWithoutPathwaysToInput
    level?: LevelCreateNestedOneWithoutPathwaysInput
  }

  export type PathwayUncheckedCreateWithoutProjectInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateOrConnectWithoutProjectInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutProjectInput, PathwayUncheckedCreateWithoutProjectInput>
  }

  export type PathwayCreateManyProjectInputEnvelope = {
    data: PathwayCreateManyProjectInput | PathwayCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FeedInfoCreateWithoutProjectInput = {
    id?: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang?: string | null
    feed_start_date?: string | null
    feed_end_date?: string | null
    feed_version?: string | null
    feed_contact_email?: string | null
    feed_contact_url?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FeedInfoUncheckedCreateWithoutProjectInput = {
    id?: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang?: string | null
    feed_start_date?: string | null
    feed_end_date?: string | null
    feed_version?: string | null
    feed_contact_email?: string | null
    feed_contact_url?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FeedInfoCreateOrConnectWithoutProjectInput = {
    where: FeedInfoWhereUniqueInput
    create: XOR<FeedInfoCreateWithoutProjectInput, FeedInfoUncheckedCreateWithoutProjectInput>
  }

  export type FeedInfoCreateManyProjectInputEnvelope = {
    data: FeedInfoCreateManyProjectInput | FeedInfoCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type UserUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    sharedProjects?: ProjectShareUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    sharedProjects?: ProjectShareUncheckedUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectShareUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectShareWhereUniqueInput
    update: XOR<ProjectShareUpdateWithoutProjectInput, ProjectShareUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectShareCreateWithoutProjectInput, ProjectShareUncheckedCreateWithoutProjectInput>
  }

  export type ProjectShareUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectShareWhereUniqueInput
    data: XOR<ProjectShareUpdateWithoutProjectInput, ProjectShareUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectShareUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectShareScalarWhereInput
    data: XOR<ProjectShareUpdateManyMutationInput, ProjectShareUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectInviteUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectInviteWhereUniqueInput
    update: XOR<ProjectInviteUpdateWithoutProjectInput, ProjectInviteUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectInviteCreateWithoutProjectInput, ProjectInviteUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInviteUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectInviteWhereUniqueInput
    data: XOR<ProjectInviteUpdateWithoutProjectInput, ProjectInviteUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectInviteUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectInviteScalarWhereInput
    data: XOR<ProjectInviteUpdateManyMutationInput, ProjectInviteUncheckedUpdateManyWithoutProjectInput>
  }

  export type AgencyUpsertWithWhereUniqueWithoutProjectInput = {
    where: AgencyWhereUniqueInput
    update: XOR<AgencyUpdateWithoutProjectInput, AgencyUncheckedUpdateWithoutProjectInput>
    create: XOR<AgencyCreateWithoutProjectInput, AgencyUncheckedCreateWithoutProjectInput>
  }

  export type AgencyUpdateWithWhereUniqueWithoutProjectInput = {
    where: AgencyWhereUniqueInput
    data: XOR<AgencyUpdateWithoutProjectInput, AgencyUncheckedUpdateWithoutProjectInput>
  }

  export type AgencyUpdateManyWithWhereWithoutProjectInput = {
    where: AgencyScalarWhereInput
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyWithoutProjectInput>
  }

  export type AgencyScalarWhereInput = {
    AND?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
    OR?: AgencyScalarWhereInput[]
    NOT?: AgencyScalarWhereInput | AgencyScalarWhereInput[]
    id?: StringFilter<"Agency"> | string
    agency_id?: StringFilter<"Agency"> | string
    agency_name?: StringFilter<"Agency"> | string
    agency_url?: StringFilter<"Agency"> | string
    agency_timezone?: StringFilter<"Agency"> | string
    agency_lang?: StringNullableFilter<"Agency"> | string | null
    agency_phone?: StringNullableFilter<"Agency"> | string | null
    agency_fare_url?: StringNullableFilter<"Agency"> | string | null
    agency_email?: StringNullableFilter<"Agency"> | string | null
    project_id?: StringFilter<"Agency"> | string
    created_by?: StringNullableFilter<"Agency"> | string | null
    created_at?: DateTimeFilter<"Agency"> | Date | string
    updated_at?: DateTimeFilter<"Agency"> | Date | string
  }

  export type StopUpsertWithWhereUniqueWithoutProjectInput = {
    where: StopWhereUniqueInput
    update: XOR<StopUpdateWithoutProjectInput, StopUncheckedUpdateWithoutProjectInput>
    create: XOR<StopCreateWithoutProjectInput, StopUncheckedCreateWithoutProjectInput>
  }

  export type StopUpdateWithWhereUniqueWithoutProjectInput = {
    where: StopWhereUniqueInput
    data: XOR<StopUpdateWithoutProjectInput, StopUncheckedUpdateWithoutProjectInput>
  }

  export type StopUpdateManyWithWhereWithoutProjectInput = {
    where: StopScalarWhereInput
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyWithoutProjectInput>
  }

  export type StopScalarWhereInput = {
    AND?: StopScalarWhereInput | StopScalarWhereInput[]
    OR?: StopScalarWhereInput[]
    NOT?: StopScalarWhereInput | StopScalarWhereInput[]
    id?: StringFilter<"Stop"> | string
    stop_id?: StringFilter<"Stop"> | string
    stop_code?: StringNullableFilter<"Stop"> | string | null
    stop_name?: StringFilter<"Stop"> | string
    stop_desc?: StringNullableFilter<"Stop"> | string | null
    stop_lat?: FloatFilter<"Stop"> | number
    stop_lon?: FloatFilter<"Stop"> | number
    zone_id?: StringNullableFilter<"Stop"> | string | null
    stop_url?: StringNullableFilter<"Stop"> | string | null
    location_type?: IntNullableFilter<"Stop"> | number | null
    wheelchair_boarding?: IntNullableFilter<"Stop"> | number | null
    parent_station?: StringNullableFilter<"Stop"> | string | null
    platform_code?: StringNullableFilter<"Stop"> | string | null
    level_id?: StringNullableFilter<"Stop"> | string | null
    tts_stop_name?: StringNullableFilter<"Stop"> | string | null
    project_id?: StringFilter<"Stop"> | string
    created_by?: StringNullableFilter<"Stop"> | string | null
    created_at?: DateTimeFilter<"Stop"> | Date | string
    updated_at?: DateTimeFilter<"Stop"> | Date | string
  }

  export type RouteUpsertWithWhereUniqueWithoutProjectInput = {
    where: RouteWhereUniqueInput
    update: XOR<RouteUpdateWithoutProjectInput, RouteUncheckedUpdateWithoutProjectInput>
    create: XOR<RouteCreateWithoutProjectInput, RouteUncheckedCreateWithoutProjectInput>
  }

  export type RouteUpdateWithWhereUniqueWithoutProjectInput = {
    where: RouteWhereUniqueInput
    data: XOR<RouteUpdateWithoutProjectInput, RouteUncheckedUpdateWithoutProjectInput>
  }

  export type RouteUpdateManyWithWhereWithoutProjectInput = {
    where: RouteScalarWhereInput
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyWithoutProjectInput>
  }

  export type RouteScalarWhereInput = {
    AND?: RouteScalarWhereInput | RouteScalarWhereInput[]
    OR?: RouteScalarWhereInput[]
    NOT?: RouteScalarWhereInput | RouteScalarWhereInput[]
    id?: StringFilter<"Route"> | string
    route_id?: StringFilter<"Route"> | string
    agency_id?: StringNullableFilter<"Route"> | string | null
    route_short_name?: StringNullableFilter<"Route"> | string | null
    route_long_name?: StringNullableFilter<"Route"> | string | null
    route_desc?: StringNullableFilter<"Route"> | string | null
    route_type?: IntFilter<"Route"> | number
    route_url?: StringNullableFilter<"Route"> | string | null
    route_color?: StringNullableFilter<"Route"> | string | null
    route_text_color?: StringNullableFilter<"Route"> | string | null
    route_sort_order?: IntNullableFilter<"Route"> | number | null
    continuous_pickup?: IntNullableFilter<"Route"> | number | null
    continuous_drop_off?: IntNullableFilter<"Route"> | number | null
    network_id?: StringNullableFilter<"Route"> | string | null
    project_id?: StringFilter<"Route"> | string
    created_by?: StringNullableFilter<"Route"> | string | null
    created_at?: DateTimeFilter<"Route"> | Date | string
    updated_at?: DateTimeFilter<"Route"> | Date | string
  }

  export type TripUpsertWithWhereUniqueWithoutProjectInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutProjectInput, TripUncheckedUpdateWithoutProjectInput>
    create: XOR<TripCreateWithoutProjectInput, TripUncheckedCreateWithoutProjectInput>
  }

  export type TripUpdateWithWhereUniqueWithoutProjectInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutProjectInput, TripUncheckedUpdateWithoutProjectInput>
  }

  export type TripUpdateManyWithWhereWithoutProjectInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutProjectInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    trip_id?: StringFilter<"Trip"> | string
    route_id?: StringFilter<"Trip"> | string
    service_id?: StringFilter<"Trip"> | string
    trip_headsign?: StringNullableFilter<"Trip"> | string | null
    trip_short_name?: StringNullableFilter<"Trip"> | string | null
    direction_id?: IntNullableFilter<"Trip"> | number | null
    block_id?: StringNullableFilter<"Trip"> | string | null
    shape_id?: StringNullableFilter<"Trip"> | string | null
    wheelchair_accessible?: IntNullableFilter<"Trip"> | number | null
    bikes_allowed?: IntNullableFilter<"Trip"> | number | null
    project_id?: StringFilter<"Trip"> | string
    created_by?: StringNullableFilter<"Trip"> | string | null
    created_at?: DateTimeFilter<"Trip"> | Date | string
    updated_at?: DateTimeFilter<"Trip"> | Date | string
  }

  export type StopTimeUpsertWithWhereUniqueWithoutProjectInput = {
    where: StopTimeWhereUniqueInput
    update: XOR<StopTimeUpdateWithoutProjectInput, StopTimeUncheckedUpdateWithoutProjectInput>
    create: XOR<StopTimeCreateWithoutProjectInput, StopTimeUncheckedCreateWithoutProjectInput>
  }

  export type StopTimeUpdateWithWhereUniqueWithoutProjectInput = {
    where: StopTimeWhereUniqueInput
    data: XOR<StopTimeUpdateWithoutProjectInput, StopTimeUncheckedUpdateWithoutProjectInput>
  }

  export type StopTimeUpdateManyWithWhereWithoutProjectInput = {
    where: StopTimeScalarWhereInput
    data: XOR<StopTimeUpdateManyMutationInput, StopTimeUncheckedUpdateManyWithoutProjectInput>
  }

  export type StopTimeScalarWhereInput = {
    AND?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
    OR?: StopTimeScalarWhereInput[]
    NOT?: StopTimeScalarWhereInput | StopTimeScalarWhereInput[]
    id?: StringFilter<"StopTime"> | string
    trip_id?: StringFilter<"StopTime"> | string
    stop_id?: StringFilter<"StopTime"> | string
    arrival_time?: StringNullableFilter<"StopTime"> | string | null
    departure_time?: StringNullableFilter<"StopTime"> | string | null
    stop_sequence?: IntFilter<"StopTime"> | number
    stop_headsign?: StringNullableFilter<"StopTime"> | string | null
    pickup_type?: IntNullableFilter<"StopTime"> | number | null
    drop_off_type?: IntNullableFilter<"StopTime"> | number | null
    continuous_pickup?: IntNullableFilter<"StopTime"> | number | null
    continuous_drop_off?: IntNullableFilter<"StopTime"> | number | null
    shape_dist_traveled?: FloatNullableFilter<"StopTime"> | number | null
    timepoint?: IntNullableFilter<"StopTime"> | number | null
    project_id?: StringFilter<"StopTime"> | string
    created_by?: StringNullableFilter<"StopTime"> | string | null
    created_at?: DateTimeFilter<"StopTime"> | Date | string
    updated_at?: DateTimeFilter<"StopTime"> | Date | string
  }

  export type CalendarUpsertWithWhereUniqueWithoutProjectInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutProjectInput, CalendarUncheckedUpdateWithoutProjectInput>
    create: XOR<CalendarCreateWithoutProjectInput, CalendarUncheckedCreateWithoutProjectInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutProjectInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutProjectInput, CalendarUncheckedUpdateWithoutProjectInput>
  }

  export type CalendarUpdateManyWithWhereWithoutProjectInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutProjectInput>
  }

  export type CalendarScalarWhereInput = {
    AND?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    OR?: CalendarScalarWhereInput[]
    NOT?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    service_id?: StringFilter<"Calendar"> | string
    monday?: IntFilter<"Calendar"> | number
    tuesday?: IntFilter<"Calendar"> | number
    wednesday?: IntFilter<"Calendar"> | number
    thursday?: IntFilter<"Calendar"> | number
    friday?: IntFilter<"Calendar"> | number
    saturday?: IntFilter<"Calendar"> | number
    sunday?: IntFilter<"Calendar"> | number
    start_date?: StringFilter<"Calendar"> | string
    end_date?: StringFilter<"Calendar"> | string
    project_id?: StringFilter<"Calendar"> | string
    created_by?: StringNullableFilter<"Calendar"> | string | null
    created_at?: DateTimeFilter<"Calendar"> | Date | string
    updated_at?: DateTimeFilter<"Calendar"> | Date | string
  }

  export type CalendarDateUpsertWithWhereUniqueWithoutProjectInput = {
    where: CalendarDateWhereUniqueInput
    update: XOR<CalendarDateUpdateWithoutProjectInput, CalendarDateUncheckedUpdateWithoutProjectInput>
    create: XOR<CalendarDateCreateWithoutProjectInput, CalendarDateUncheckedCreateWithoutProjectInput>
  }

  export type CalendarDateUpdateWithWhereUniqueWithoutProjectInput = {
    where: CalendarDateWhereUniqueInput
    data: XOR<CalendarDateUpdateWithoutProjectInput, CalendarDateUncheckedUpdateWithoutProjectInput>
  }

  export type CalendarDateUpdateManyWithWhereWithoutProjectInput = {
    where: CalendarDateScalarWhereInput
    data: XOR<CalendarDateUpdateManyMutationInput, CalendarDateUncheckedUpdateManyWithoutProjectInput>
  }

  export type CalendarDateScalarWhereInput = {
    AND?: CalendarDateScalarWhereInput | CalendarDateScalarWhereInput[]
    OR?: CalendarDateScalarWhereInput[]
    NOT?: CalendarDateScalarWhereInput | CalendarDateScalarWhereInput[]
    id?: StringFilter<"CalendarDate"> | string
    service_id?: StringFilter<"CalendarDate"> | string
    date?: StringFilter<"CalendarDate"> | string
    exception_type?: IntFilter<"CalendarDate"> | number
    project_id?: StringFilter<"CalendarDate"> | string
    created_by?: StringNullableFilter<"CalendarDate"> | string | null
    created_at?: DateTimeFilter<"CalendarDate"> | Date | string
    updated_at?: DateTimeFilter<"CalendarDate"> | Date | string
  }

  export type FareAttributeUpsertWithWhereUniqueWithoutProjectInput = {
    where: FareAttributeWhereUniqueInput
    update: XOR<FareAttributeUpdateWithoutProjectInput, FareAttributeUncheckedUpdateWithoutProjectInput>
    create: XOR<FareAttributeCreateWithoutProjectInput, FareAttributeUncheckedCreateWithoutProjectInput>
  }

  export type FareAttributeUpdateWithWhereUniqueWithoutProjectInput = {
    where: FareAttributeWhereUniqueInput
    data: XOR<FareAttributeUpdateWithoutProjectInput, FareAttributeUncheckedUpdateWithoutProjectInput>
  }

  export type FareAttributeUpdateManyWithWhereWithoutProjectInput = {
    where: FareAttributeScalarWhereInput
    data: XOR<FareAttributeUpdateManyMutationInput, FareAttributeUncheckedUpdateManyWithoutProjectInput>
  }

  export type FareAttributeScalarWhereInput = {
    AND?: FareAttributeScalarWhereInput | FareAttributeScalarWhereInput[]
    OR?: FareAttributeScalarWhereInput[]
    NOT?: FareAttributeScalarWhereInput | FareAttributeScalarWhereInput[]
    id?: StringFilter<"FareAttribute"> | string
    fare_id?: StringFilter<"FareAttribute"> | string
    price?: FloatFilter<"FareAttribute"> | number
    currency_type?: StringFilter<"FareAttribute"> | string
    payment_method?: IntFilter<"FareAttribute"> | number
    transfers?: IntNullableFilter<"FareAttribute"> | number | null
    agency_id?: StringNullableFilter<"FareAttribute"> | string | null
    transfer_duration?: IntNullableFilter<"FareAttribute"> | number | null
    project_id?: StringFilter<"FareAttribute"> | string
    created_by?: StringNullableFilter<"FareAttribute"> | string | null
    created_at?: DateTimeFilter<"FareAttribute"> | Date | string
    updated_at?: DateTimeFilter<"FareAttribute"> | Date | string
  }

  export type FareRuleUpsertWithWhereUniqueWithoutProjectInput = {
    where: FareRuleWhereUniqueInput
    update: XOR<FareRuleUpdateWithoutProjectInput, FareRuleUncheckedUpdateWithoutProjectInput>
    create: XOR<FareRuleCreateWithoutProjectInput, FareRuleUncheckedCreateWithoutProjectInput>
  }

  export type FareRuleUpdateWithWhereUniqueWithoutProjectInput = {
    where: FareRuleWhereUniqueInput
    data: XOR<FareRuleUpdateWithoutProjectInput, FareRuleUncheckedUpdateWithoutProjectInput>
  }

  export type FareRuleUpdateManyWithWhereWithoutProjectInput = {
    where: FareRuleScalarWhereInput
    data: XOR<FareRuleUpdateManyMutationInput, FareRuleUncheckedUpdateManyWithoutProjectInput>
  }

  export type FareRuleScalarWhereInput = {
    AND?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
    OR?: FareRuleScalarWhereInput[]
    NOT?: FareRuleScalarWhereInput | FareRuleScalarWhereInput[]
    id?: StringFilter<"FareRule"> | string
    fare_id?: StringFilter<"FareRule"> | string
    route_id?: StringNullableFilter<"FareRule"> | string | null
    origin_id?: StringNullableFilter<"FareRule"> | string | null
    destination_id?: StringNullableFilter<"FareRule"> | string | null
    contains_id?: StringNullableFilter<"FareRule"> | string | null
    project_id?: StringFilter<"FareRule"> | string
    created_by?: StringNullableFilter<"FareRule"> | string | null
    created_at?: DateTimeFilter<"FareRule"> | Date | string
    updated_at?: DateTimeFilter<"FareRule"> | Date | string
  }

  export type ShapeUpsertWithWhereUniqueWithoutProjectInput = {
    where: ShapeWhereUniqueInput
    update: XOR<ShapeUpdateWithoutProjectInput, ShapeUncheckedUpdateWithoutProjectInput>
    create: XOR<ShapeCreateWithoutProjectInput, ShapeUncheckedCreateWithoutProjectInput>
  }

  export type ShapeUpdateWithWhereUniqueWithoutProjectInput = {
    where: ShapeWhereUniqueInput
    data: XOR<ShapeUpdateWithoutProjectInput, ShapeUncheckedUpdateWithoutProjectInput>
  }

  export type ShapeUpdateManyWithWhereWithoutProjectInput = {
    where: ShapeScalarWhereInput
    data: XOR<ShapeUpdateManyMutationInput, ShapeUncheckedUpdateManyWithoutProjectInput>
  }

  export type ShapeScalarWhereInput = {
    AND?: ShapeScalarWhereInput | ShapeScalarWhereInput[]
    OR?: ShapeScalarWhereInput[]
    NOT?: ShapeScalarWhereInput | ShapeScalarWhereInput[]
    id?: StringFilter<"Shape"> | string
    shape_id?: StringFilter<"Shape"> | string
    shape_pt_sequence?: IntFilter<"Shape"> | number
    shape_pt_lat?: FloatFilter<"Shape"> | number
    shape_pt_lon?: FloatFilter<"Shape"> | number
    shape_dist_traveled?: FloatNullableFilter<"Shape"> | number | null
    project_id?: StringFilter<"Shape"> | string
    created_by?: StringNullableFilter<"Shape"> | string | null
    created_at?: DateTimeFilter<"Shape"> | Date | string
    updated_at?: DateTimeFilter<"Shape"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutProjectInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutProjectInput, TransferUncheckedUpdateWithoutProjectInput>
    create: XOR<TransferCreateWithoutProjectInput, TransferUncheckedCreateWithoutProjectInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutProjectInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutProjectInput, TransferUncheckedUpdateWithoutProjectInput>
  }

  export type TransferUpdateManyWithWhereWithoutProjectInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutProjectInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    from_stop_id?: StringFilter<"Transfer"> | string
    to_stop_id?: StringFilter<"Transfer"> | string
    transfer_type?: IntFilter<"Transfer"> | number
    min_transfer_time?: IntNullableFilter<"Transfer"> | number | null
    project_id?: StringFilter<"Transfer"> | string
    created_by?: StringNullableFilter<"Transfer"> | string | null
    created_at?: DateTimeFilter<"Transfer"> | Date | string
    updated_at?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type FrequencyUpsertWithWhereUniqueWithoutProjectInput = {
    where: FrequencyWhereUniqueInput
    update: XOR<FrequencyUpdateWithoutProjectInput, FrequencyUncheckedUpdateWithoutProjectInput>
    create: XOR<FrequencyCreateWithoutProjectInput, FrequencyUncheckedCreateWithoutProjectInput>
  }

  export type FrequencyUpdateWithWhereUniqueWithoutProjectInput = {
    where: FrequencyWhereUniqueInput
    data: XOR<FrequencyUpdateWithoutProjectInput, FrequencyUncheckedUpdateWithoutProjectInput>
  }

  export type FrequencyUpdateManyWithWhereWithoutProjectInput = {
    where: FrequencyScalarWhereInput
    data: XOR<FrequencyUpdateManyMutationInput, FrequencyUncheckedUpdateManyWithoutProjectInput>
  }

  export type FrequencyScalarWhereInput = {
    AND?: FrequencyScalarWhereInput | FrequencyScalarWhereInput[]
    OR?: FrequencyScalarWhereInput[]
    NOT?: FrequencyScalarWhereInput | FrequencyScalarWhereInput[]
    id?: StringFilter<"Frequency"> | string
    trip_id?: StringFilter<"Frequency"> | string
    start_time?: StringFilter<"Frequency"> | string
    end_time?: StringFilter<"Frequency"> | string
    headway_secs?: IntFilter<"Frequency"> | number
    exact_times?: IntNullableFilter<"Frequency"> | number | null
    project_id?: StringFilter<"Frequency"> | string
    created_by?: StringNullableFilter<"Frequency"> | string | null
    created_at?: DateTimeFilter<"Frequency"> | Date | string
    updated_at?: DateTimeFilter<"Frequency"> | Date | string
  }

  export type LevelUpsertWithWhereUniqueWithoutProjectInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutProjectInput, LevelUncheckedUpdateWithoutProjectInput>
    create: XOR<LevelCreateWithoutProjectInput, LevelUncheckedCreateWithoutProjectInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutProjectInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutProjectInput, LevelUncheckedUpdateWithoutProjectInput>
  }

  export type LevelUpdateManyWithWhereWithoutProjectInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutProjectInput>
  }

  export type LevelScalarWhereInput = {
    AND?: LevelScalarWhereInput | LevelScalarWhereInput[]
    OR?: LevelScalarWhereInput[]
    NOT?: LevelScalarWhereInput | LevelScalarWhereInput[]
    id?: StringFilter<"Level"> | string
    level_id?: StringFilter<"Level"> | string
    level_index?: FloatFilter<"Level"> | number
    level_name?: StringNullableFilter<"Level"> | string | null
    project_id?: StringFilter<"Level"> | string
    created_by?: StringNullableFilter<"Level"> | string | null
    created_at?: DateTimeFilter<"Level"> | Date | string
    updated_at?: DateTimeFilter<"Level"> | Date | string
  }

  export type PathwayUpsertWithWhereUniqueWithoutProjectInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutProjectInput, PathwayUncheckedUpdateWithoutProjectInput>
    create: XOR<PathwayCreateWithoutProjectInput, PathwayUncheckedCreateWithoutProjectInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutProjectInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutProjectInput, PathwayUncheckedUpdateWithoutProjectInput>
  }

  export type PathwayUpdateManyWithWhereWithoutProjectInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutProjectInput>
  }

  export type PathwayScalarWhereInput = {
    AND?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
    OR?: PathwayScalarWhereInput[]
    NOT?: PathwayScalarWhereInput | PathwayScalarWhereInput[]
    id?: StringFilter<"Pathway"> | string
    pathway_id?: StringFilter<"Pathway"> | string
    from_stop_id?: StringFilter<"Pathway"> | string
    to_stop_id?: StringFilter<"Pathway"> | string
    pathway_mode?: IntFilter<"Pathway"> | number
    is_bidirectional?: IntFilter<"Pathway"> | number
    length?: FloatNullableFilter<"Pathway"> | number | null
    traversal_time?: IntNullableFilter<"Pathway"> | number | null
    stair_count?: IntNullableFilter<"Pathway"> | number | null
    max_slope?: FloatNullableFilter<"Pathway"> | number | null
    min_width?: FloatNullableFilter<"Pathway"> | number | null
    signposted_as?: StringNullableFilter<"Pathway"> | string | null
    reversed_signposted_as?: StringNullableFilter<"Pathway"> | string | null
    level_id?: StringNullableFilter<"Pathway"> | string | null
    project_id?: StringFilter<"Pathway"> | string
    created_by?: StringNullableFilter<"Pathway"> | string | null
    created_at?: DateTimeFilter<"Pathway"> | Date | string
    updated_at?: DateTimeFilter<"Pathway"> | Date | string
  }

  export type FeedInfoUpsertWithWhereUniqueWithoutProjectInput = {
    where: FeedInfoWhereUniqueInput
    update: XOR<FeedInfoUpdateWithoutProjectInput, FeedInfoUncheckedUpdateWithoutProjectInput>
    create: XOR<FeedInfoCreateWithoutProjectInput, FeedInfoUncheckedCreateWithoutProjectInput>
  }

  export type FeedInfoUpdateWithWhereUniqueWithoutProjectInput = {
    where: FeedInfoWhereUniqueInput
    data: XOR<FeedInfoUpdateWithoutProjectInput, FeedInfoUncheckedUpdateWithoutProjectInput>
  }

  export type FeedInfoUpdateManyWithWhereWithoutProjectInput = {
    where: FeedInfoScalarWhereInput
    data: XOR<FeedInfoUpdateManyMutationInput, FeedInfoUncheckedUpdateManyWithoutProjectInput>
  }

  export type FeedInfoScalarWhereInput = {
    AND?: FeedInfoScalarWhereInput | FeedInfoScalarWhereInput[]
    OR?: FeedInfoScalarWhereInput[]
    NOT?: FeedInfoScalarWhereInput | FeedInfoScalarWhereInput[]
    id?: StringFilter<"FeedInfo"> | string
    feed_publisher_name?: StringFilter<"FeedInfo"> | string
    feed_publisher_url?: StringFilter<"FeedInfo"> | string
    feed_lang?: StringFilter<"FeedInfo"> | string
    default_lang?: StringNullableFilter<"FeedInfo"> | string | null
    feed_start_date?: StringNullableFilter<"FeedInfo"> | string | null
    feed_end_date?: StringNullableFilter<"FeedInfo"> | string | null
    feed_version?: StringNullableFilter<"FeedInfo"> | string | null
    feed_contact_email?: StringNullableFilter<"FeedInfo"> | string | null
    feed_contact_url?: StringNullableFilter<"FeedInfo"> | string | null
    project_id?: StringFilter<"FeedInfo"> | string
    created_by?: StringNullableFilter<"FeedInfo"> | string | null
    created_at?: DateTimeFilter<"FeedInfo"> | Date | string
    updated_at?: DateTimeFilter<"FeedInfo"> | Date | string
  }

  export type UserProjectCreateWithoutSharesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutSharesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutSharesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutSharesInput, UserProjectUncheckedCreateWithoutSharesInput>
  }

  export type UserCreateWithoutSharedProjectsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectCreateNestedManyWithoutOwnerInput
    invitedProjects?: ProjectInviteCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedProjectsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectUncheckedCreateNestedManyWithoutOwnerInput
    invitedProjects?: ProjectInviteUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
  }

  export type UserProjectUpsertWithoutSharesInput = {
    update: XOR<UserProjectUpdateWithoutSharesInput, UserProjectUncheckedUpdateWithoutSharesInput>
    create: XOR<UserProjectCreateWithoutSharesInput, UserProjectUncheckedCreateWithoutSharesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutSharesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutSharesInput, UserProjectUncheckedUpdateWithoutSharesInput>
  }

  export type UserProjectUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutSharedProjectsInput = {
    update: XOR<UserUpdateWithoutSharedProjectsInput, UserUncheckedUpdateWithoutSharedProjectsInput>
    create: XOR<UserCreateWithoutSharedProjectsInput, UserUncheckedCreateWithoutSharedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedProjectsInput, UserUncheckedUpdateWithoutSharedProjectsInput>
  }

  export type UserUpdateWithoutSharedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUpdateManyWithoutOwnerNestedInput
    invitedProjects?: ProjectInviteUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUncheckedUpdateManyWithoutOwnerNestedInput
    invitedProjects?: ProjectInviteUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProjectCreateWithoutInvitesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutInvitesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutInvitesInput, UserProjectUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutInvitedProjectsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitedProjectsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectUncheckedCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitedProjectsInput, UserUncheckedCreateWithoutInvitedProjectsInput>
  }

  export type UserProjectUpsertWithoutInvitesInput = {
    update: XOR<UserProjectUpdateWithoutInvitesInput, UserProjectUncheckedUpdateWithoutInvitesInput>
    create: XOR<UserProjectCreateWithoutInvitesInput, UserProjectUncheckedCreateWithoutInvitesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutInvitesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutInvitesInput, UserProjectUncheckedUpdateWithoutInvitesInput>
  }

  export type UserProjectUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutInvitedProjectsInput = {
    update: XOR<UserUpdateWithoutInvitedProjectsInput, UserUncheckedUpdateWithoutInvitedProjectsInput>
    create: XOR<UserCreateWithoutInvitedProjectsInput, UserUncheckedCreateWithoutInvitedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitedProjectsInput, UserUncheckedUpdateWithoutInvitedProjectsInput>
  }

  export type UserUpdateWithoutInvitedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectUncheckedCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareUncheckedCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUncheckedUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    password_hash: string
    avatar_url?: string | null
    first_name?: string | null
    last_name?: string | null
    is_active?: boolean
    is_verified?: boolean
    last_login?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    ownedProjects?: UserProjectUncheckedCreateNestedManyWithoutOwnerInput
    sharedProjects?: ProjectShareUncheckedCreateNestedManyWithoutUserInput
    invitedProjects?: ProjectInviteUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    ownedProjects?: UserProjectUncheckedUpdateManyWithoutOwnerNestedInput
    sharedProjects?: ProjectShareUncheckedUpdateManyWithoutUserNestedInput
    invitedProjects?: ProjectInviteUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProjectCreateWithoutAgenciesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutAgenciesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutAgenciesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutAgenciesInput, UserProjectUncheckedCreateWithoutAgenciesInput>
  }

  export type RouteCreateWithoutAgencyInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutRoutesInput
    trips?: TripCreateNestedManyWithoutRouteInput
    fareRules?: FareRuleCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutAgencyInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutAgencyInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutAgencyInput, RouteUncheckedCreateWithoutAgencyInput>
  }

  export type RouteCreateManyAgencyInputEnvelope = {
    data: RouteCreateManyAgencyInput | RouteCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type FareAttributeCreateWithoutAgencyInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    transfer_duration?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFareAttributesInput
    fareRules?: FareRuleCreateNestedManyWithoutFare_attributeInput
  }

  export type FareAttributeUncheckedCreateWithoutAgencyInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    transfer_duration?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutFare_attributeInput
  }

  export type FareAttributeCreateOrConnectWithoutAgencyInput = {
    where: FareAttributeWhereUniqueInput
    create: XOR<FareAttributeCreateWithoutAgencyInput, FareAttributeUncheckedCreateWithoutAgencyInput>
  }

  export type FareAttributeCreateManyAgencyInputEnvelope = {
    data: FareAttributeCreateManyAgencyInput | FareAttributeCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserProjectUpsertWithoutAgenciesInput = {
    update: XOR<UserProjectUpdateWithoutAgenciesInput, UserProjectUncheckedUpdateWithoutAgenciesInput>
    create: XOR<UserProjectCreateWithoutAgenciesInput, UserProjectUncheckedCreateWithoutAgenciesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutAgenciesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutAgenciesInput, UserProjectUncheckedUpdateWithoutAgenciesInput>
  }

  export type UserProjectUpdateWithoutAgenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutAgenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RouteUpsertWithWhereUniqueWithoutAgencyInput = {
    where: RouteWhereUniqueInput
    update: XOR<RouteUpdateWithoutAgencyInput, RouteUncheckedUpdateWithoutAgencyInput>
    create: XOR<RouteCreateWithoutAgencyInput, RouteUncheckedCreateWithoutAgencyInput>
  }

  export type RouteUpdateWithWhereUniqueWithoutAgencyInput = {
    where: RouteWhereUniqueInput
    data: XOR<RouteUpdateWithoutAgencyInput, RouteUncheckedUpdateWithoutAgencyInput>
  }

  export type RouteUpdateManyWithWhereWithoutAgencyInput = {
    where: RouteScalarWhereInput
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyWithoutAgencyInput>
  }

  export type FareAttributeUpsertWithWhereUniqueWithoutAgencyInput = {
    where: FareAttributeWhereUniqueInput
    update: XOR<FareAttributeUpdateWithoutAgencyInput, FareAttributeUncheckedUpdateWithoutAgencyInput>
    create: XOR<FareAttributeCreateWithoutAgencyInput, FareAttributeUncheckedCreateWithoutAgencyInput>
  }

  export type FareAttributeUpdateWithWhereUniqueWithoutAgencyInput = {
    where: FareAttributeWhereUniqueInput
    data: XOR<FareAttributeUpdateWithoutAgencyInput, FareAttributeUncheckedUpdateWithoutAgencyInput>
  }

  export type FareAttributeUpdateManyWithWhereWithoutAgencyInput = {
    where: FareAttributeScalarWhereInput
    data: XOR<FareAttributeUpdateManyMutationInput, FareAttributeUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UserProjectCreateWithoutStopsInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutStopsInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutStopsInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutStopsInput, UserProjectUncheckedCreateWithoutStopsInput>
  }

  export type StopTimeCreateWithoutStopInput = {
    id?: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopTimesInput
    trip: TripCreateNestedOneWithoutStopTimesInput
  }

  export type StopTimeUncheckedCreateWithoutStopInput = {
    id?: string
    trip_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeCreateOrConnectWithoutStopInput = {
    where: StopTimeWhereUniqueInput
    create: XOR<StopTimeCreateWithoutStopInput, StopTimeUncheckedCreateWithoutStopInput>
  }

  export type StopTimeCreateManyStopInputEnvelope = {
    data: StopTimeCreateManyStopInput | StopTimeCreateManyStopInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutFromStopInput = {
    id?: string
    transfer_type?: number
    min_transfer_time?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTransfersInput
    toStop: StopCreateNestedOneWithoutTransfersToInput
  }

  export type TransferUncheckedCreateWithoutFromStopInput = {
    id?: string
    to_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferCreateOrConnectWithoutFromStopInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromStopInput, TransferUncheckedCreateWithoutFromStopInput>
  }

  export type TransferCreateManyFromStopInputEnvelope = {
    data: TransferCreateManyFromStopInput | TransferCreateManyFromStopInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutToStopInput = {
    id?: string
    transfer_type?: number
    min_transfer_time?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTransfersInput
    fromStop: StopCreateNestedOneWithoutTransfersInput
  }

  export type TransferUncheckedCreateWithoutToStopInput = {
    id?: string
    from_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferCreateOrConnectWithoutToStopInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToStopInput, TransferUncheckedCreateWithoutToStopInput>
  }

  export type TransferCreateManyToStopInputEnvelope = {
    data: TransferCreateManyToStopInput | TransferCreateManyToStopInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutFromStopInput = {
    id?: string
    pathway_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutPathwaysInput
    toStop: StopCreateNestedOneWithoutPathwaysToInput
    level?: LevelCreateNestedOneWithoutPathwaysInput
  }

  export type PathwayUncheckedCreateWithoutFromStopInput = {
    id?: string
    pathway_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateOrConnectWithoutFromStopInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutFromStopInput, PathwayUncheckedCreateWithoutFromStopInput>
  }

  export type PathwayCreateManyFromStopInputEnvelope = {
    data: PathwayCreateManyFromStopInput | PathwayCreateManyFromStopInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutToStopInput = {
    id?: string
    pathway_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutPathwaysInput
    fromStop: StopCreateNestedOneWithoutPathwaysInput
    level?: LevelCreateNestedOneWithoutPathwaysInput
  }

  export type PathwayUncheckedCreateWithoutToStopInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateOrConnectWithoutToStopInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutToStopInput, PathwayUncheckedCreateWithoutToStopInput>
  }

  export type PathwayCreateManyToStopInputEnvelope = {
    data: PathwayCreateManyToStopInput | PathwayCreateManyToStopInput[]
    skipDuplicates?: boolean
  }

  export type StopCreateWithoutChildStopsInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutChildStopsInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
  }

  export type StopCreateOrConnectWithoutChildStopsInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutChildStopsInput, StopUncheckedCreateWithoutChildStopsInput>
  }

  export type StopCreateWithoutParentStopInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutParentStopInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutParentStopInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutParentStopInput, StopUncheckedCreateWithoutParentStopInput>
  }

  export type StopCreateManyParentStopInputEnvelope = {
    data: StopCreateManyParentStopInput | StopCreateManyParentStopInput[]
    skipDuplicates?: boolean
  }

  export type LevelCreateWithoutStopsInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutLevelsInput
    pathways?: PathwayCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutStopsInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    pathways?: PathwayUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutStopsInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutStopsInput, LevelUncheckedCreateWithoutStopsInput>
  }

  export type UserProjectUpsertWithoutStopsInput = {
    update: XOR<UserProjectUpdateWithoutStopsInput, UserProjectUncheckedUpdateWithoutStopsInput>
    create: XOR<UserProjectCreateWithoutStopsInput, UserProjectUncheckedCreateWithoutStopsInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutStopsInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutStopsInput, UserProjectUncheckedUpdateWithoutStopsInput>
  }

  export type UserProjectUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type StopTimeUpsertWithWhereUniqueWithoutStopInput = {
    where: StopTimeWhereUniqueInput
    update: XOR<StopTimeUpdateWithoutStopInput, StopTimeUncheckedUpdateWithoutStopInput>
    create: XOR<StopTimeCreateWithoutStopInput, StopTimeUncheckedCreateWithoutStopInput>
  }

  export type StopTimeUpdateWithWhereUniqueWithoutStopInput = {
    where: StopTimeWhereUniqueInput
    data: XOR<StopTimeUpdateWithoutStopInput, StopTimeUncheckedUpdateWithoutStopInput>
  }

  export type StopTimeUpdateManyWithWhereWithoutStopInput = {
    where: StopTimeScalarWhereInput
    data: XOR<StopTimeUpdateManyMutationInput, StopTimeUncheckedUpdateManyWithoutStopInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutFromStopInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromStopInput, TransferUncheckedUpdateWithoutFromStopInput>
    create: XOR<TransferCreateWithoutFromStopInput, TransferUncheckedCreateWithoutFromStopInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromStopInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromStopInput, TransferUncheckedUpdateWithoutFromStopInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromStopInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromStopInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutToStopInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToStopInput, TransferUncheckedUpdateWithoutToStopInput>
    create: XOR<TransferCreateWithoutToStopInput, TransferUncheckedCreateWithoutToStopInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToStopInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToStopInput, TransferUncheckedUpdateWithoutToStopInput>
  }

  export type TransferUpdateManyWithWhereWithoutToStopInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToStopInput>
  }

  export type PathwayUpsertWithWhereUniqueWithoutFromStopInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutFromStopInput, PathwayUncheckedUpdateWithoutFromStopInput>
    create: XOR<PathwayCreateWithoutFromStopInput, PathwayUncheckedCreateWithoutFromStopInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutFromStopInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutFromStopInput, PathwayUncheckedUpdateWithoutFromStopInput>
  }

  export type PathwayUpdateManyWithWhereWithoutFromStopInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutFromStopInput>
  }

  export type PathwayUpsertWithWhereUniqueWithoutToStopInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutToStopInput, PathwayUncheckedUpdateWithoutToStopInput>
    create: XOR<PathwayCreateWithoutToStopInput, PathwayUncheckedCreateWithoutToStopInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutToStopInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutToStopInput, PathwayUncheckedUpdateWithoutToStopInput>
  }

  export type PathwayUpdateManyWithWhereWithoutToStopInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutToStopInput>
  }

  export type StopUpsertWithoutChildStopsInput = {
    update: XOR<StopUpdateWithoutChildStopsInput, StopUncheckedUpdateWithoutChildStopsInput>
    create: XOR<StopCreateWithoutChildStopsInput, StopUncheckedCreateWithoutChildStopsInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutChildStopsInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutChildStopsInput, StopUncheckedUpdateWithoutChildStopsInput>
  }

  export type StopUpdateWithoutChildStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutChildStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
  }

  export type StopUpsertWithWhereUniqueWithoutParentStopInput = {
    where: StopWhereUniqueInput
    update: XOR<StopUpdateWithoutParentStopInput, StopUncheckedUpdateWithoutParentStopInput>
    create: XOR<StopCreateWithoutParentStopInput, StopUncheckedCreateWithoutParentStopInput>
  }

  export type StopUpdateWithWhereUniqueWithoutParentStopInput = {
    where: StopWhereUniqueInput
    data: XOR<StopUpdateWithoutParentStopInput, StopUncheckedUpdateWithoutParentStopInput>
  }

  export type StopUpdateManyWithWhereWithoutParentStopInput = {
    where: StopScalarWhereInput
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyWithoutParentStopInput>
  }

  export type LevelUpsertWithoutStopsInput = {
    update: XOR<LevelUpdateWithoutStopsInput, LevelUncheckedUpdateWithoutStopsInput>
    create: XOR<LevelCreateWithoutStopsInput, LevelUncheckedCreateWithoutStopsInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutStopsInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutStopsInput, LevelUncheckedUpdateWithoutStopsInput>
  }

  export type LevelUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutLevelsNestedInput
    pathways?: PathwayUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pathways?: PathwayUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type UserProjectCreateWithoutRoutesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutRoutesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutRoutesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutRoutesInput, UserProjectUncheckedCreateWithoutRoutesInput>
  }

  export type AgencyCreateWithoutRoutesInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutAgenciesInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutRoutesInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutRoutesInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutRoutesInput, AgencyUncheckedCreateWithoutRoutesInput>
  }

  export type TripCreateWithoutRouteInput = {
    id?: string
    trip_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTripsInput
    calendar?: CalendarCreateNestedOneWithoutTripsInput
    stopTimes?: StopTimeCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutRouteInput = {
    id?: string
    trip_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutRouteInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput>
  }

  export type TripCreateManyRouteInputEnvelope = {
    data: TripCreateManyRouteInput | TripCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type FareRuleCreateWithoutRouteInput = {
    id?: string
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFareRulesInput
    fare_attribute: FareAttributeCreateNestedOneWithoutFareRulesInput
  }

  export type FareRuleUncheckedCreateWithoutRouteInput = {
    id?: string
    fare_id: string
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleCreateOrConnectWithoutRouteInput = {
    where: FareRuleWhereUniqueInput
    create: XOR<FareRuleCreateWithoutRouteInput, FareRuleUncheckedCreateWithoutRouteInput>
  }

  export type FareRuleCreateManyRouteInputEnvelope = {
    data: FareRuleCreateManyRouteInput | FareRuleCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type UserProjectUpsertWithoutRoutesInput = {
    update: XOR<UserProjectUpdateWithoutRoutesInput, UserProjectUncheckedUpdateWithoutRoutesInput>
    create: XOR<UserProjectCreateWithoutRoutesInput, UserProjectUncheckedCreateWithoutRoutesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutRoutesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutRoutesInput, UserProjectUncheckedUpdateWithoutRoutesInput>
  }

  export type UserProjectUpdateWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AgencyUpsertWithoutRoutesInput = {
    update: XOR<AgencyUpdateWithoutRoutesInput, AgencyUncheckedUpdateWithoutRoutesInput>
    create: XOR<AgencyCreateWithoutRoutesInput, AgencyUncheckedCreateWithoutRoutesInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutRoutesInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutRoutesInput, AgencyUncheckedUpdateWithoutRoutesInput>
  }

  export type AgencyUpdateWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutAgenciesNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type TripUpsertWithWhereUniqueWithoutRouteInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutRouteInput, TripUncheckedUpdateWithoutRouteInput>
    create: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput>
  }

  export type TripUpdateWithWhereUniqueWithoutRouteInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutRouteInput, TripUncheckedUpdateWithoutRouteInput>
  }

  export type TripUpdateManyWithWhereWithoutRouteInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutRouteInput>
  }

  export type FareRuleUpsertWithWhereUniqueWithoutRouteInput = {
    where: FareRuleWhereUniqueInput
    update: XOR<FareRuleUpdateWithoutRouteInput, FareRuleUncheckedUpdateWithoutRouteInput>
    create: XOR<FareRuleCreateWithoutRouteInput, FareRuleUncheckedCreateWithoutRouteInput>
  }

  export type FareRuleUpdateWithWhereUniqueWithoutRouteInput = {
    where: FareRuleWhereUniqueInput
    data: XOR<FareRuleUpdateWithoutRouteInput, FareRuleUncheckedUpdateWithoutRouteInput>
  }

  export type FareRuleUpdateManyWithWhereWithoutRouteInput = {
    where: FareRuleScalarWhereInput
    data: XOR<FareRuleUpdateManyMutationInput, FareRuleUncheckedUpdateManyWithoutRouteInput>
  }

  export type UserProjectCreateWithoutTripsInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutTripsInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutTripsInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutTripsInput, UserProjectUncheckedCreateWithoutTripsInput>
  }

  export type RouteCreateWithoutTripsInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutRoutesInput
    agency?: AgencyCreateNestedOneWithoutRoutesInput
    fareRules?: FareRuleCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutTripsInput = {
    id?: string
    route_id: string
    agency_id?: string | null
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutTripsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
  }

  export type CalendarCreateWithoutTripsInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutCalendarsInput
    exceptions?: CalendarDateCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutTripsInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    exceptions?: CalendarDateUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutTripsInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutTripsInput, CalendarUncheckedCreateWithoutTripsInput>
  }

  export type StopTimeCreateWithoutTripInput = {
    id?: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopTimesInput
    stop: StopCreateNestedOneWithoutStopTimesInput
  }

  export type StopTimeUncheckedCreateWithoutTripInput = {
    id?: string
    stop_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeCreateOrConnectWithoutTripInput = {
    where: StopTimeWhereUniqueInput
    create: XOR<StopTimeCreateWithoutTripInput, StopTimeUncheckedCreateWithoutTripInput>
  }

  export type StopTimeCreateManyTripInputEnvelope = {
    data: StopTimeCreateManyTripInput | StopTimeCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type UserProjectUpsertWithoutTripsInput = {
    update: XOR<UserProjectUpdateWithoutTripsInput, UserProjectUncheckedUpdateWithoutTripsInput>
    create: XOR<UserProjectCreateWithoutTripsInput, UserProjectUncheckedCreateWithoutTripsInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutTripsInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutTripsInput, UserProjectUncheckedUpdateWithoutTripsInput>
  }

  export type UserProjectUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RouteUpsertWithoutTripsInput = {
    update: XOR<RouteUpdateWithoutTripsInput, RouteUncheckedUpdateWithoutTripsInput>
    create: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutTripsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutTripsInput, RouteUncheckedUpdateWithoutTripsInput>
  }

  export type RouteUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutRoutesNestedInput
    agency?: AgencyUpdateOneWithoutRoutesNestedInput
    fareRules?: FareRuleUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fareRules?: FareRuleUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type CalendarUpsertWithoutTripsInput = {
    update: XOR<CalendarUpdateWithoutTripsInput, CalendarUncheckedUpdateWithoutTripsInput>
    create: XOR<CalendarCreateWithoutTripsInput, CalendarUncheckedCreateWithoutTripsInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutTripsInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutTripsInput, CalendarUncheckedUpdateWithoutTripsInput>
  }

  export type CalendarUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutCalendarsNestedInput
    exceptions?: CalendarDateUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exceptions?: CalendarDateUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type StopTimeUpsertWithWhereUniqueWithoutTripInput = {
    where: StopTimeWhereUniqueInput
    update: XOR<StopTimeUpdateWithoutTripInput, StopTimeUncheckedUpdateWithoutTripInput>
    create: XOR<StopTimeCreateWithoutTripInput, StopTimeUncheckedCreateWithoutTripInput>
  }

  export type StopTimeUpdateWithWhereUniqueWithoutTripInput = {
    where: StopTimeWhereUniqueInput
    data: XOR<StopTimeUpdateWithoutTripInput, StopTimeUncheckedUpdateWithoutTripInput>
  }

  export type StopTimeUpdateManyWithWhereWithoutTripInput = {
    where: StopTimeScalarWhereInput
    data: XOR<StopTimeUpdateManyMutationInput, StopTimeUncheckedUpdateManyWithoutTripInput>
  }

  export type UserProjectCreateWithoutStopTimesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutStopTimesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutStopTimesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutStopTimesInput, UserProjectUncheckedCreateWithoutStopTimesInput>
  }

  export type TripCreateWithoutStopTimesInput = {
    id?: string
    trip_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTripsInput
    route: RouteCreateNestedOneWithoutTripsInput
    calendar?: CalendarCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutStopTimesInput = {
    id?: string
    trip_id: string
    route_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TripCreateOrConnectWithoutStopTimesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutStopTimesInput, TripUncheckedCreateWithoutStopTimesInput>
  }

  export type StopCreateWithoutStopTimesInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutStopTimesInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutStopTimesInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutStopTimesInput, StopUncheckedCreateWithoutStopTimesInput>
  }

  export type UserProjectUpsertWithoutStopTimesInput = {
    update: XOR<UserProjectUpdateWithoutStopTimesInput, UserProjectUncheckedUpdateWithoutStopTimesInput>
    create: XOR<UserProjectCreateWithoutStopTimesInput, UserProjectUncheckedCreateWithoutStopTimesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutStopTimesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutStopTimesInput, UserProjectUncheckedUpdateWithoutStopTimesInput>
  }

  export type UserProjectUpdateWithoutStopTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutStopTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TripUpsertWithoutStopTimesInput = {
    update: XOR<TripUpdateWithoutStopTimesInput, TripUncheckedUpdateWithoutStopTimesInput>
    create: XOR<TripCreateWithoutStopTimesInput, TripUncheckedCreateWithoutStopTimesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutStopTimesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutStopTimesInput, TripUncheckedUpdateWithoutStopTimesInput>
  }

  export type TripUpdateWithoutStopTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTripsNestedInput
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    calendar?: CalendarUpdateOneWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutStopTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUpsertWithoutStopTimesInput = {
    update: XOR<StopUpdateWithoutStopTimesInput, StopUncheckedUpdateWithoutStopTimesInput>
    create: XOR<StopCreateWithoutStopTimesInput, StopUncheckedCreateWithoutStopTimesInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutStopTimesInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutStopTimesInput, StopUncheckedUpdateWithoutStopTimesInput>
  }

  export type StopUpdateWithoutStopTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutStopTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type UserProjectCreateWithoutCalendarsInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutCalendarsInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutCalendarsInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutCalendarsInput, UserProjectUncheckedCreateWithoutCalendarsInput>
  }

  export type TripCreateWithoutCalendarInput = {
    id?: string
    trip_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutTripsInput
    route: RouteCreateNestedOneWithoutTripsInput
    stopTimes?: StopTimeCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutCalendarInput = {
    id?: string
    trip_id: string
    route_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutCalendarInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutCalendarInput, TripUncheckedCreateWithoutCalendarInput>
  }

  export type TripCreateManyCalendarInputEnvelope = {
    data: TripCreateManyCalendarInput | TripCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type CalendarDateCreateWithoutCalendarInput = {
    id?: string
    date: string
    exception_type: number
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutCalendarDatesInput
  }

  export type CalendarDateUncheckedCreateWithoutCalendarInput = {
    id?: string
    date: string
    exception_type: number
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarDateCreateOrConnectWithoutCalendarInput = {
    where: CalendarDateWhereUniqueInput
    create: XOR<CalendarDateCreateWithoutCalendarInput, CalendarDateUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarDateCreateManyCalendarInputEnvelope = {
    data: CalendarDateCreateManyCalendarInput | CalendarDateCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type UserProjectUpsertWithoutCalendarsInput = {
    update: XOR<UserProjectUpdateWithoutCalendarsInput, UserProjectUncheckedUpdateWithoutCalendarsInput>
    create: XOR<UserProjectCreateWithoutCalendarsInput, UserProjectUncheckedCreateWithoutCalendarsInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutCalendarsInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutCalendarsInput, UserProjectUncheckedUpdateWithoutCalendarsInput>
  }

  export type UserProjectUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TripUpsertWithWhereUniqueWithoutCalendarInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutCalendarInput, TripUncheckedUpdateWithoutCalendarInput>
    create: XOR<TripCreateWithoutCalendarInput, TripUncheckedCreateWithoutCalendarInput>
  }

  export type TripUpdateWithWhereUniqueWithoutCalendarInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutCalendarInput, TripUncheckedUpdateWithoutCalendarInput>
  }

  export type TripUpdateManyWithWhereWithoutCalendarInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutCalendarInput>
  }

  export type CalendarDateUpsertWithWhereUniqueWithoutCalendarInput = {
    where: CalendarDateWhereUniqueInput
    update: XOR<CalendarDateUpdateWithoutCalendarInput, CalendarDateUncheckedUpdateWithoutCalendarInput>
    create: XOR<CalendarDateCreateWithoutCalendarInput, CalendarDateUncheckedCreateWithoutCalendarInput>
  }

  export type CalendarDateUpdateWithWhereUniqueWithoutCalendarInput = {
    where: CalendarDateWhereUniqueInput
    data: XOR<CalendarDateUpdateWithoutCalendarInput, CalendarDateUncheckedUpdateWithoutCalendarInput>
  }

  export type CalendarDateUpdateManyWithWhereWithoutCalendarInput = {
    where: CalendarDateScalarWhereInput
    data: XOR<CalendarDateUpdateManyMutationInput, CalendarDateUncheckedUpdateManyWithoutCalendarInput>
  }

  export type UserProjectCreateWithoutCalendarDatesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutCalendarDatesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutCalendarDatesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutCalendarDatesInput, UserProjectUncheckedCreateWithoutCalendarDatesInput>
  }

  export type CalendarCreateWithoutExceptionsInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutCalendarsInput
    trips?: TripCreateNestedManyWithoutCalendarInput
  }

  export type CalendarUncheckedCreateWithoutExceptionsInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type CalendarCreateOrConnectWithoutExceptionsInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutExceptionsInput, CalendarUncheckedCreateWithoutExceptionsInput>
  }

  export type UserProjectUpsertWithoutCalendarDatesInput = {
    update: XOR<UserProjectUpdateWithoutCalendarDatesInput, UserProjectUncheckedUpdateWithoutCalendarDatesInput>
    create: XOR<UserProjectCreateWithoutCalendarDatesInput, UserProjectUncheckedCreateWithoutCalendarDatesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutCalendarDatesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutCalendarDatesInput, UserProjectUncheckedUpdateWithoutCalendarDatesInput>
  }

  export type UserProjectUpdateWithoutCalendarDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutCalendarDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CalendarUpsertWithoutExceptionsInput = {
    update: XOR<CalendarUpdateWithoutExceptionsInput, CalendarUncheckedUpdateWithoutExceptionsInput>
    create: XOR<CalendarCreateWithoutExceptionsInput, CalendarUncheckedCreateWithoutExceptionsInput>
    where?: CalendarWhereInput
  }

  export type CalendarUpdateToOneWithWhereWithoutExceptionsInput = {
    where?: CalendarWhereInput
    data: XOR<CalendarUpdateWithoutExceptionsInput, CalendarUncheckedUpdateWithoutExceptionsInput>
  }

  export type CalendarUpdateWithoutExceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutCalendarsNestedInput
    trips?: TripUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutExceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type UserProjectCreateWithoutFareAttributesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutFareAttributesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutFareAttributesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutFareAttributesInput, UserProjectUncheckedCreateWithoutFareAttributesInput>
  }

  export type AgencyCreateWithoutFareAttributesInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutAgenciesInput
    routes?: RouteCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutFareAttributesInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    routes?: RouteUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutFareAttributesInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutFareAttributesInput, AgencyUncheckedCreateWithoutFareAttributesInput>
  }

  export type FareRuleCreateWithoutFare_attributeInput = {
    id?: string
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFareRulesInput
    route?: RouteCreateNestedOneWithoutFareRulesInput
  }

  export type FareRuleUncheckedCreateWithoutFare_attributeInput = {
    id?: string
    route_id?: string | null
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleCreateOrConnectWithoutFare_attributeInput = {
    where: FareRuleWhereUniqueInput
    create: XOR<FareRuleCreateWithoutFare_attributeInput, FareRuleUncheckedCreateWithoutFare_attributeInput>
  }

  export type FareRuleCreateManyFare_attributeInputEnvelope = {
    data: FareRuleCreateManyFare_attributeInput | FareRuleCreateManyFare_attributeInput[]
    skipDuplicates?: boolean
  }

  export type UserProjectUpsertWithoutFareAttributesInput = {
    update: XOR<UserProjectUpdateWithoutFareAttributesInput, UserProjectUncheckedUpdateWithoutFareAttributesInput>
    create: XOR<UserProjectCreateWithoutFareAttributesInput, UserProjectUncheckedCreateWithoutFareAttributesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutFareAttributesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutFareAttributesInput, UserProjectUncheckedUpdateWithoutFareAttributesInput>
  }

  export type UserProjectUpdateWithoutFareAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutFareAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AgencyUpsertWithoutFareAttributesInput = {
    update: XOR<AgencyUpdateWithoutFareAttributesInput, AgencyUncheckedUpdateWithoutFareAttributesInput>
    create: XOR<AgencyCreateWithoutFareAttributesInput, AgencyUncheckedCreateWithoutFareAttributesInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutFareAttributesInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutFareAttributesInput, AgencyUncheckedUpdateWithoutFareAttributesInput>
  }

  export type AgencyUpdateWithoutFareAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutAgenciesNestedInput
    routes?: RouteUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutFareAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    routes?: RouteUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type FareRuleUpsertWithWhereUniqueWithoutFare_attributeInput = {
    where: FareRuleWhereUniqueInput
    update: XOR<FareRuleUpdateWithoutFare_attributeInput, FareRuleUncheckedUpdateWithoutFare_attributeInput>
    create: XOR<FareRuleCreateWithoutFare_attributeInput, FareRuleUncheckedCreateWithoutFare_attributeInput>
  }

  export type FareRuleUpdateWithWhereUniqueWithoutFare_attributeInput = {
    where: FareRuleWhereUniqueInput
    data: XOR<FareRuleUpdateWithoutFare_attributeInput, FareRuleUncheckedUpdateWithoutFare_attributeInput>
  }

  export type FareRuleUpdateManyWithWhereWithoutFare_attributeInput = {
    where: FareRuleScalarWhereInput
    data: XOR<FareRuleUpdateManyMutationInput, FareRuleUncheckedUpdateManyWithoutFare_attributeInput>
  }

  export type UserProjectCreateWithoutFareRulesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutFareRulesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutFareRulesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutFareRulesInput, UserProjectUncheckedCreateWithoutFareRulesInput>
  }

  export type FareAttributeCreateWithoutFareRulesInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    transfer_duration?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutFareAttributesInput
    agency?: AgencyCreateNestedOneWithoutFareAttributesInput
  }

  export type FareAttributeUncheckedCreateWithoutFareRulesInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    agency_id?: string | null
    transfer_duration?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareAttributeCreateOrConnectWithoutFareRulesInput = {
    where: FareAttributeWhereUniqueInput
    create: XOR<FareAttributeCreateWithoutFareRulesInput, FareAttributeUncheckedCreateWithoutFareRulesInput>
  }

  export type RouteCreateWithoutFareRulesInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutRoutesInput
    agency?: AgencyCreateNestedOneWithoutRoutesInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutFareRulesInput = {
    id?: string
    route_id: string
    agency_id?: string | null
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutFareRulesInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutFareRulesInput, RouteUncheckedCreateWithoutFareRulesInput>
  }

  export type UserProjectUpsertWithoutFareRulesInput = {
    update: XOR<UserProjectUpdateWithoutFareRulesInput, UserProjectUncheckedUpdateWithoutFareRulesInput>
    create: XOR<UserProjectCreateWithoutFareRulesInput, UserProjectUncheckedCreateWithoutFareRulesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutFareRulesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutFareRulesInput, UserProjectUncheckedUpdateWithoutFareRulesInput>
  }

  export type UserProjectUpdateWithoutFareRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutFareRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type FareAttributeUpsertWithoutFareRulesInput = {
    update: XOR<FareAttributeUpdateWithoutFareRulesInput, FareAttributeUncheckedUpdateWithoutFareRulesInput>
    create: XOR<FareAttributeCreateWithoutFareRulesInput, FareAttributeUncheckedCreateWithoutFareRulesInput>
    where?: FareAttributeWhereInput
  }

  export type FareAttributeUpdateToOneWithWhereWithoutFareRulesInput = {
    where?: FareAttributeWhereInput
    data: XOR<FareAttributeUpdateWithoutFareRulesInput, FareAttributeUncheckedUpdateWithoutFareRulesInput>
  }

  export type FareAttributeUpdateWithoutFareRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFareAttributesNestedInput
    agency?: AgencyUpdateOneWithoutFareAttributesNestedInput
  }

  export type FareAttributeUncheckedUpdateWithoutFareRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUpsertWithoutFareRulesInput = {
    update: XOR<RouteUpdateWithoutFareRulesInput, RouteUncheckedUpdateWithoutFareRulesInput>
    create: XOR<RouteCreateWithoutFareRulesInput, RouteUncheckedCreateWithoutFareRulesInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutFareRulesInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutFareRulesInput, RouteUncheckedUpdateWithoutFareRulesInput>
  }

  export type RouteUpdateWithoutFareRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutRoutesNestedInput
    agency?: AgencyUpdateOneWithoutRoutesNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutFareRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type UserProjectCreateWithoutShapesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutShapesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutShapesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutShapesInput, UserProjectUncheckedCreateWithoutShapesInput>
  }

  export type UserProjectUpsertWithoutShapesInput = {
    update: XOR<UserProjectUpdateWithoutShapesInput, UserProjectUncheckedUpdateWithoutShapesInput>
    create: XOR<UserProjectCreateWithoutShapesInput, UserProjectUncheckedCreateWithoutShapesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutShapesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutShapesInput, UserProjectUncheckedUpdateWithoutShapesInput>
  }

  export type UserProjectUpdateWithoutShapesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutShapesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectCreateWithoutTransfersInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutTransfersInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutTransfersInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutTransfersInput, UserProjectUncheckedCreateWithoutTransfersInput>
  }

  export type StopCreateWithoutTransfersInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutTransfersInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutTransfersInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutTransfersInput, StopUncheckedCreateWithoutTransfersInput>
  }

  export type StopCreateWithoutTransfersToInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutTransfersToInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutTransfersToInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutTransfersToInput, StopUncheckedCreateWithoutTransfersToInput>
  }

  export type UserProjectUpsertWithoutTransfersInput = {
    update: XOR<UserProjectUpdateWithoutTransfersInput, UserProjectUncheckedUpdateWithoutTransfersInput>
    create: XOR<UserProjectCreateWithoutTransfersInput, UserProjectUncheckedCreateWithoutTransfersInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutTransfersInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutTransfersInput, UserProjectUncheckedUpdateWithoutTransfersInput>
  }

  export type UserProjectUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type StopUpsertWithoutTransfersInput = {
    update: XOR<StopUpdateWithoutTransfersInput, StopUncheckedUpdateWithoutTransfersInput>
    create: XOR<StopCreateWithoutTransfersInput, StopUncheckedCreateWithoutTransfersInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutTransfersInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutTransfersInput, StopUncheckedUpdateWithoutTransfersInput>
  }

  export type StopUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type StopUpsertWithoutTransfersToInput = {
    update: XOR<StopUpdateWithoutTransfersToInput, StopUncheckedUpdateWithoutTransfersToInput>
    create: XOR<StopCreateWithoutTransfersToInput, StopUncheckedCreateWithoutTransfersToInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutTransfersToInput, StopUncheckedUpdateWithoutTransfersToInput>
  }

  export type StopUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type UserProjectCreateWithoutFrequenciesInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutFrequenciesInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutFrequenciesInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutFrequenciesInput, UserProjectUncheckedCreateWithoutFrequenciesInput>
  }

  export type UserProjectUpsertWithoutFrequenciesInput = {
    update: XOR<UserProjectUpdateWithoutFrequenciesInput, UserProjectUncheckedUpdateWithoutFrequenciesInput>
    create: XOR<UserProjectCreateWithoutFrequenciesInput, UserProjectUncheckedCreateWithoutFrequenciesInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutFrequenciesInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutFrequenciesInput, UserProjectUncheckedUpdateWithoutFrequenciesInput>
  }

  export type UserProjectUpdateWithoutFrequenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutFrequenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectCreateWithoutLevelsInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutLevelsInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutLevelsInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutLevelsInput, UserProjectUncheckedCreateWithoutLevelsInput>
  }

  export type StopCreateWithoutLevelInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
  }

  export type StopUncheckedCreateWithoutLevelInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutLevelInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutLevelInput, StopUncheckedCreateWithoutLevelInput>
  }

  export type StopCreateManyLevelInputEnvelope = {
    data: StopCreateManyLevelInput | StopCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type PathwayCreateWithoutLevelInput = {
    id?: string
    pathway_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutPathwaysInput
    fromStop: StopCreateNestedOneWithoutPathwaysInput
    toStop: StopCreateNestedOneWithoutPathwaysToInput
  }

  export type PathwayUncheckedCreateWithoutLevelInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateOrConnectWithoutLevelInput = {
    where: PathwayWhereUniqueInput
    create: XOR<PathwayCreateWithoutLevelInput, PathwayUncheckedCreateWithoutLevelInput>
  }

  export type PathwayCreateManyLevelInputEnvelope = {
    data: PathwayCreateManyLevelInput | PathwayCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type UserProjectUpsertWithoutLevelsInput = {
    update: XOR<UserProjectUpdateWithoutLevelsInput, UserProjectUncheckedUpdateWithoutLevelsInput>
    create: XOR<UserProjectCreateWithoutLevelsInput, UserProjectUncheckedCreateWithoutLevelsInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutLevelsInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutLevelsInput, UserProjectUncheckedUpdateWithoutLevelsInput>
  }

  export type UserProjectUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type StopUpsertWithWhereUniqueWithoutLevelInput = {
    where: StopWhereUniqueInput
    update: XOR<StopUpdateWithoutLevelInput, StopUncheckedUpdateWithoutLevelInput>
    create: XOR<StopCreateWithoutLevelInput, StopUncheckedCreateWithoutLevelInput>
  }

  export type StopUpdateWithWhereUniqueWithoutLevelInput = {
    where: StopWhereUniqueInput
    data: XOR<StopUpdateWithoutLevelInput, StopUncheckedUpdateWithoutLevelInput>
  }

  export type StopUpdateManyWithWhereWithoutLevelInput = {
    where: StopScalarWhereInput
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyWithoutLevelInput>
  }

  export type PathwayUpsertWithWhereUniqueWithoutLevelInput = {
    where: PathwayWhereUniqueInput
    update: XOR<PathwayUpdateWithoutLevelInput, PathwayUncheckedUpdateWithoutLevelInput>
    create: XOR<PathwayCreateWithoutLevelInput, PathwayUncheckedCreateWithoutLevelInput>
  }

  export type PathwayUpdateWithWhereUniqueWithoutLevelInput = {
    where: PathwayWhereUniqueInput
    data: XOR<PathwayUpdateWithoutLevelInput, PathwayUncheckedUpdateWithoutLevelInput>
  }

  export type PathwayUpdateManyWithWhereWithoutLevelInput = {
    where: PathwayScalarWhereInput
    data: XOR<PathwayUpdateManyMutationInput, PathwayUncheckedUpdateManyWithoutLevelInput>
  }

  export type UserProjectCreateWithoutPathwaysInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutPathwaysInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    feedInfo?: FeedInfoUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutPathwaysInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutPathwaysInput, UserProjectUncheckedCreateWithoutPathwaysInput>
  }

  export type StopCreateWithoutPathwaysInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathwaysTo?: PathwayCreateNestedManyWithoutToStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutPathwaysInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathwaysTo?: PathwayUncheckedCreateNestedManyWithoutToStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutPathwaysInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutPathwaysInput, StopUncheckedCreateWithoutPathwaysInput>
  }

  export type StopCreateWithoutPathwaysToInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutStopsInput
    stopTimes?: StopTimeCreateNestedManyWithoutStopInput
    transfers?: TransferCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferCreateNestedManyWithoutToStopInput
    pathways?: PathwayCreateNestedManyWithoutFromStopInput
    parentStop?: StopCreateNestedOneWithoutChildStopsInput
    childStops?: StopCreateNestedManyWithoutParentStopInput
    level?: LevelCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutPathwaysToInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutStopInput
    transfers?: TransferUncheckedCreateNestedManyWithoutFromStopInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStopInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutFromStopInput
    childStops?: StopUncheckedCreateNestedManyWithoutParentStopInput
  }

  export type StopCreateOrConnectWithoutPathwaysToInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutPathwaysToInput, StopUncheckedCreateWithoutPathwaysToInput>
  }

  export type LevelCreateWithoutPathwaysInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: UserProjectCreateNestedOneWithoutLevelsInput
    stops?: StopCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutPathwaysInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutPathwaysInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutPathwaysInput, LevelUncheckedCreateWithoutPathwaysInput>
  }

  export type UserProjectUpsertWithoutPathwaysInput = {
    update: XOR<UserProjectUpdateWithoutPathwaysInput, UserProjectUncheckedUpdateWithoutPathwaysInput>
    create: XOR<UserProjectCreateWithoutPathwaysInput, UserProjectUncheckedCreateWithoutPathwaysInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutPathwaysInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutPathwaysInput, UserProjectUncheckedUpdateWithoutPathwaysInput>
  }

  export type UserProjectUpdateWithoutPathwaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutPathwaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type StopUpsertWithoutPathwaysInput = {
    update: XOR<StopUpdateWithoutPathwaysInput, StopUncheckedUpdateWithoutPathwaysInput>
    create: XOR<StopCreateWithoutPathwaysInput, StopUncheckedCreateWithoutPathwaysInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutPathwaysInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutPathwaysInput, StopUncheckedUpdateWithoutPathwaysInput>
  }

  export type StopUpdateWithoutPathwaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutPathwaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type StopUpsertWithoutPathwaysToInput = {
    update: XOR<StopUpdateWithoutPathwaysToInput, StopUncheckedUpdateWithoutPathwaysToInput>
    create: XOR<StopCreateWithoutPathwaysToInput, StopUncheckedCreateWithoutPathwaysToInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutPathwaysToInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutPathwaysToInput, StopUncheckedUpdateWithoutPathwaysToInput>
  }

  export type StopUpdateWithoutPathwaysToInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutPathwaysToInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type LevelUpsertWithoutPathwaysInput = {
    update: XOR<LevelUpdateWithoutPathwaysInput, LevelUncheckedUpdateWithoutPathwaysInput>
    create: XOR<LevelCreateWithoutPathwaysInput, LevelUncheckedCreateWithoutPathwaysInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutPathwaysInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutPathwaysInput, LevelUncheckedUpdateWithoutPathwaysInput>
  }

  export type LevelUpdateWithoutPathwaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutLevelsNestedInput
    stops?: StopUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutPathwaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type UserProjectCreateWithoutFeedInfoInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    shares?: ProjectShareCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteCreateNestedManyWithoutProjectInput
    agencies?: AgencyCreateNestedManyWithoutProjectInput
    stops?: StopCreateNestedManyWithoutProjectInput
    routes?: RouteCreateNestedManyWithoutProjectInput
    trips?: TripCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeCreateNestedManyWithoutProjectInput
    calendars?: CalendarCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleCreateNestedManyWithoutProjectInput
    shapes?: ShapeCreateNestedManyWithoutProjectInput
    transfers?: TransferCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyCreateNestedManyWithoutProjectInput
    levels?: LevelCreateNestedManyWithoutProjectInput
    pathways?: PathwayCreateNestedManyWithoutProjectInput
  }

  export type UserProjectUncheckedCreateWithoutFeedInfoInput = {
    id?: string
    name: string
    description?: string | null
    owner_id: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    shares?: ProjectShareUncheckedCreateNestedManyWithoutProjectInput
    invites?: ProjectInviteUncheckedCreateNestedManyWithoutProjectInput
    agencies?: AgencyUncheckedCreateNestedManyWithoutProjectInput
    stops?: StopUncheckedCreateNestedManyWithoutProjectInput
    routes?: RouteUncheckedCreateNestedManyWithoutProjectInput
    trips?: TripUncheckedCreateNestedManyWithoutProjectInput
    stopTimes?: StopTimeUncheckedCreateNestedManyWithoutProjectInput
    calendars?: CalendarUncheckedCreateNestedManyWithoutProjectInput
    calendarDates?: CalendarDateUncheckedCreateNestedManyWithoutProjectInput
    fareAttributes?: FareAttributeUncheckedCreateNestedManyWithoutProjectInput
    fareRules?: FareRuleUncheckedCreateNestedManyWithoutProjectInput
    shapes?: ShapeUncheckedCreateNestedManyWithoutProjectInput
    transfers?: TransferUncheckedCreateNestedManyWithoutProjectInput
    frequencies?: FrequencyUncheckedCreateNestedManyWithoutProjectInput
    levels?: LevelUncheckedCreateNestedManyWithoutProjectInput
    pathways?: PathwayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type UserProjectCreateOrConnectWithoutFeedInfoInput = {
    where: UserProjectWhereUniqueInput
    create: XOR<UserProjectCreateWithoutFeedInfoInput, UserProjectUncheckedCreateWithoutFeedInfoInput>
  }

  export type UserProjectUpsertWithoutFeedInfoInput = {
    update: XOR<UserProjectUpdateWithoutFeedInfoInput, UserProjectUncheckedUpdateWithoutFeedInfoInput>
    create: XOR<UserProjectCreateWithoutFeedInfoInput, UserProjectUncheckedCreateWithoutFeedInfoInput>
    where?: UserProjectWhereInput
  }

  export type UserProjectUpdateToOneWithWhereWithoutFeedInfoInput = {
    where?: UserProjectWhereInput
    data: XOR<UserProjectUpdateWithoutFeedInfoInput, UserProjectUncheckedUpdateWithoutFeedInfoInput>
  }

  export type UserProjectUpdateWithoutFeedInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutFeedInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    owner_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectShareCreateManyUserInput = {
    id?: string
    project_id: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectInviteCreateManyUserInput = {
    id?: string
    project_id: string
    email: string
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
  }

  export type PasswordResetCreateManyUserInput = {
    id?: string
    token: string
    expires_at: Date | string
    used_at?: Date | string | null
    created_at?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    session_token: string
    expires_at: Date | string
    user_agent?: string | null
    ip_address?: string | null
    created_at?: Date | string
    last_active?: Date | string
  }

  export type UserProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUpdateManyWithoutProjectNestedInput
    stops?: StopUpdateManyWithoutProjectNestedInput
    routes?: RouteUpdateManyWithoutProjectNestedInput
    trips?: TripUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUpdateManyWithoutProjectNestedInput
    transfers?: TransferUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUpdateManyWithoutProjectNestedInput
    levels?: LevelUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ProjectShareUncheckedUpdateManyWithoutProjectNestedInput
    invites?: ProjectInviteUncheckedUpdateManyWithoutProjectNestedInput
    agencies?: AgencyUncheckedUpdateManyWithoutProjectNestedInput
    stops?: StopUncheckedUpdateManyWithoutProjectNestedInput
    routes?: RouteUncheckedUpdateManyWithoutProjectNestedInput
    trips?: TripUncheckedUpdateManyWithoutProjectNestedInput
    stopTimes?: StopTimeUncheckedUpdateManyWithoutProjectNestedInput
    calendars?: CalendarUncheckedUpdateManyWithoutProjectNestedInput
    calendarDates?: CalendarDateUncheckedUpdateManyWithoutProjectNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutProjectNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutProjectNestedInput
    shapes?: ShapeUncheckedUpdateManyWithoutProjectNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutProjectNestedInput
    frequencies?: FrequencyUncheckedUpdateManyWithoutProjectNestedInput
    levels?: LevelUncheckedUpdateManyWithoutProjectNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutProjectNestedInput
    feedInfo?: FeedInfoUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutSharesNestedInput
  }

  export type ProjectShareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type ProjectInviteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareCreateManyProjectInput = {
    id?: string
    user_id: string
    role?: $Enums.ProjectRole
    shared_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectInviteCreateManyProjectInput = {
    id?: string
    email: string
    user_id?: string | null
    role?: $Enums.ProjectRole
    token: string
    invited_by: string
    expires_at: Date | string
    accepted_at?: Date | string | null
    created_at?: Date | string
  }

  export type AgencyCreateManyProjectInput = {
    id?: string
    agency_id: string
    agency_name: string
    agency_url: string
    agency_timezone: string
    agency_lang?: string | null
    agency_phone?: string | null
    agency_fare_url?: string | null
    agency_email?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopCreateManyProjectInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteCreateManyProjectInput = {
    id?: string
    route_id: string
    agency_id?: string | null
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TripCreateManyProjectInput = {
    id?: string
    trip_id: string
    route_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeCreateManyProjectInput = {
    id?: string
    trip_id: string
    stop_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarCreateManyProjectInput = {
    id?: string
    service_id: string
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    start_date: string
    end_date: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarDateCreateManyProjectInput = {
    id?: string
    service_id: string
    date: string
    exception_type: number
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareAttributeCreateManyProjectInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    agency_id?: string | null
    transfer_duration?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleCreateManyProjectInput = {
    id?: string
    fare_id: string
    route_id?: string | null
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ShapeCreateManyProjectInput = {
    id?: string
    shape_id: string
    shape_pt_sequence: number
    shape_pt_lat: number
    shape_pt_lon: number
    shape_dist_traveled?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferCreateManyProjectInput = {
    id?: string
    from_stop_id: string
    to_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FrequencyCreateManyProjectInput = {
    id?: string
    trip_id: string
    start_time: string
    end_time: string
    headway_secs: number
    exact_times?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LevelCreateManyProjectInput = {
    id?: string
    level_id: string
    level_index: number
    level_name?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateManyProjectInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FeedInfoCreateManyProjectInput = {
    id?: string
    feed_publisher_name: string
    feed_publisher_url: string
    feed_lang: string
    default_lang?: string | null
    feed_start_date?: string | null
    feed_end_date?: string | null
    feed_version?: string | null
    feed_contact_email?: string | null
    feed_contact_url?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectShareUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedProjectsNestedInput
  }

  export type ProjectShareUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectShareUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    shared_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInvitedProjectsNestedInput
  }

  export type ProjectInviteUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInviteUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    token?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    routes?: RouteUpdateManyWithoutAgencyNestedInput
    fareAttributes?: FareAttributeUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    routes?: RouteUncheckedUpdateManyWithoutAgencyNestedInput
    fareAttributes?: FareAttributeUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    agency_id?: StringFieldUpdateOperationsInput | string
    agency_name?: StringFieldUpdateOperationsInput | string
    agency_url?: StringFieldUpdateOperationsInput | string
    agency_timezone?: StringFieldUpdateOperationsInput | string
    agency_lang?: NullableStringFieldUpdateOperationsInput | string | null
    agency_phone?: NullableStringFieldUpdateOperationsInput | string | null
    agency_fare_url?: NullableStringFieldUpdateOperationsInput | string | null
    agency_email?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type StopUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneWithoutRoutesNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
    fareRules?: FareRuleUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    calendar?: CalendarUpdateOneWithoutTripsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutStopTimesNestedInput
    stop?: StopUpdateOneRequiredWithoutStopTimesNestedInput
  }

  export type StopTimeUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUpdateManyWithoutCalendarNestedInput
    exceptions?: CalendarDateUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutCalendarNestedInput
    exceptions?: CalendarDateUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    monday?: IntFieldUpdateOperationsInput | number
    tuesday?: IntFieldUpdateOperationsInput | number
    wednesday?: IntFieldUpdateOperationsInput | number
    thursday?: IntFieldUpdateOperationsInput | number
    friday?: IntFieldUpdateOperationsInput | number
    saturday?: IntFieldUpdateOperationsInput | number
    sunday?: IntFieldUpdateOperationsInput | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: CalendarUpdateOneRequiredWithoutExceptionsNestedInput
  }

  export type CalendarDateUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareAttributeUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agency?: AgencyUpdateOneWithoutFareAttributesNestedInput
    fareRules?: FareRuleUpdateManyWithoutFare_attributeNestedInput
  }

  export type FareAttributeUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fareRules?: FareRuleUncheckedUpdateManyWithoutFare_attributeNestedInput
  }

  export type FareAttributeUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fare_attribute?: FareAttributeUpdateOneRequiredWithoutFareRulesNestedInput
    route?: RouteUpdateOneWithoutFareRulesNestedInput
  }

  export type FareRuleUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    route_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    route_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShapeUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShapeUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShapeUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    shape_id?: StringFieldUpdateOperationsInput | string
    shape_pt_sequence?: IntFieldUpdateOperationsInput | number
    shape_pt_lat?: FloatFieldUpdateOperationsInput | number
    shape_pt_lon?: FloatFieldUpdateOperationsInput | number
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStop?: StopUpdateOneRequiredWithoutTransfersNestedInput
    toStop?: StopUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type TransferUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FrequencyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FrequencyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FrequencyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    headway_secs?: IntFieldUpdateOperationsInput | number
    exact_times?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUpdateManyWithoutLevelNestedInput
    pathways?: PathwayUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutLevelNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    level_id?: StringFieldUpdateOperationsInput | string
    level_index?: FloatFieldUpdateOperationsInput | number
    level_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStop?: StopUpdateOneRequiredWithoutPathwaysNestedInput
    toStop?: StopUpdateOneRequiredWithoutPathwaysToNestedInput
    level?: LevelUpdateOneWithoutPathwaysNestedInput
  }

  export type PathwayUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedInfoUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedInfoUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedInfoUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    feed_publisher_name?: StringFieldUpdateOperationsInput | string
    feed_publisher_url?: StringFieldUpdateOperationsInput | string
    feed_lang?: StringFieldUpdateOperationsInput | string
    default_lang?: NullableStringFieldUpdateOperationsInput | string | null
    feed_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    feed_version?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    feed_contact_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateManyAgencyInput = {
    id?: string
    route_id: string
    route_short_name?: string | null
    route_long_name?: string | null
    route_desc?: string | null
    route_type: number
    route_url?: string | null
    route_color?: string | null
    route_text_color?: string | null
    route_sort_order?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    network_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareAttributeCreateManyAgencyInput = {
    id?: string
    fare_id: string
    price: number
    currency_type: string
    payment_method: number
    transfers?: number | null
    transfer_duration?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RouteUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutRoutesNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
    fareRules?: FareRuleUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
    fareRules?: FareRuleUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    route_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_long_name?: NullableStringFieldUpdateOperationsInput | string | null
    route_desc?: NullableStringFieldUpdateOperationsInput | string | null
    route_type?: IntFieldUpdateOperationsInput | number
    route_url?: NullableStringFieldUpdateOperationsInput | string | null
    route_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_text_color?: NullableStringFieldUpdateOperationsInput | string | null
    route_sort_order?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    network_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareAttributeUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFareAttributesNestedInput
    fareRules?: FareRuleUpdateManyWithoutFare_attributeNestedInput
  }

  export type FareAttributeUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fareRules?: FareRuleUncheckedUpdateManyWithoutFare_attributeNestedInput
  }

  export type FareAttributeUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency_type?: StringFieldUpdateOperationsInput | string
    payment_method?: IntFieldUpdateOperationsInput | number
    transfers?: NullableIntFieldUpdateOperationsInput | number | null
    transfer_duration?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeCreateManyStopInput = {
    id?: string
    trip_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferCreateManyFromStopInput = {
    id?: string
    to_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransferCreateManyToStopInput = {
    id?: string
    from_stop_id: string
    transfer_type?: number
    min_transfer_time?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateManyFromStopInput = {
    id?: string
    pathway_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateManyToStopInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    level_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopCreateManyParentStopInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    platform_code?: string | null
    level_id?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeUpdateWithoutStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopTimesNestedInput
    trip?: TripUpdateOneRequiredWithoutStopTimesNestedInput
  }

  export type StopTimeUncheckedUpdateWithoutStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeUncheckedUpdateManyWithoutStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutFromStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTransfersNestedInput
    toStop?: StopUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutFromStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutToStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTransfersNestedInput
    fromStop?: StopUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutToStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutToStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    transfer_type?: IntFieldUpdateOperationsInput | number
    min_transfer_time?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUpdateWithoutFromStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutPathwaysNestedInput
    toStop?: StopUpdateOneRequiredWithoutPathwaysToNestedInput
    level?: LevelUpdateOneWithoutPathwaysNestedInput
  }

  export type PathwayUncheckedUpdateWithoutFromStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUncheckedUpdateManyWithoutFromStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUpdateWithoutToStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutPathwaysNestedInput
    fromStop?: StopUpdateOneRequiredWithoutPathwaysNestedInput
    level?: LevelUpdateOneWithoutPathwaysNestedInput
  }

  export type PathwayUncheckedUpdateWithoutToStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUncheckedUpdateManyWithoutToStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUpdateWithoutParentStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
    level?: LevelUpdateOneWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutParentStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type StopUncheckedUpdateManyWithoutParentStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    level_id?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateManyRouteInput = {
    id?: string
    trip_id: string
    service_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleCreateManyRouteInput = {
    id?: string
    fare_id: string
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TripUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTripsNestedInput
    calendar?: CalendarUpdateOneWithoutTripsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFareRulesNestedInput
    fare_attribute?: FareAttributeUpdateOneRequiredWithoutFareRulesNestedInput
  }

  export type FareRuleUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fare_id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeCreateManyTripInput = {
    id?: string
    stop_id: string
    arrival_time?: string | null
    departure_time?: string | null
    stop_sequence: number
    stop_headsign?: string | null
    pickup_type?: number | null
    drop_off_type?: number | null
    continuous_pickup?: number | null
    continuous_drop_off?: number | null
    shape_dist_traveled?: number | null
    timepoint?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopTimeUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopTimesNestedInput
    stop?: StopUpdateOneRequiredWithoutStopTimesNestedInput
  }

  export type StopTimeUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopTimeUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    arrival_time?: NullableStringFieldUpdateOperationsInput | string | null
    departure_time?: NullableStringFieldUpdateOperationsInput | string | null
    stop_sequence?: IntFieldUpdateOperationsInput | number
    stop_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_type?: NullableIntFieldUpdateOperationsInput | number | null
    drop_off_type?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_pickup?: NullableIntFieldUpdateOperationsInput | number | null
    continuous_drop_off?: NullableIntFieldUpdateOperationsInput | number | null
    shape_dist_traveled?: NullableFloatFieldUpdateOperationsInput | number | null
    timepoint?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateManyCalendarInput = {
    id?: string
    trip_id: string
    route_id: string
    trip_headsign?: string | null
    trip_short_name?: string | null
    direction_id?: number | null
    block_id?: string | null
    shape_id?: string | null
    wheelchair_accessible?: number | null
    bikes_allowed?: number | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CalendarDateCreateManyCalendarInput = {
    id?: string
    date: string
    exception_type: number
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TripUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutTripsNestedInput
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    trip_id?: StringFieldUpdateOperationsInput | string
    route_id?: StringFieldUpdateOperationsInput | string
    trip_headsign?: NullableStringFieldUpdateOperationsInput | string | null
    trip_short_name?: NullableStringFieldUpdateOperationsInput | string | null
    direction_id?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: NullableStringFieldUpdateOperationsInput | string | null
    shape_id?: NullableStringFieldUpdateOperationsInput | string | null
    wheelchair_accessible?: NullableIntFieldUpdateOperationsInput | number | null
    bikes_allowed?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutCalendarDatesNestedInput
  }

  export type CalendarDateUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarDateUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    exception_type?: IntFieldUpdateOperationsInput | number
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleCreateManyFare_attributeInput = {
    id?: string
    route_id?: string | null
    origin_id?: string | null
    destination_id?: string | null
    contains_id?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FareRuleUpdateWithoutFare_attributeInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutFareRulesNestedInput
    route?: RouteUpdateOneWithoutFareRulesNestedInput
  }

  export type FareRuleUncheckedUpdateWithoutFare_attributeInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FareRuleUncheckedUpdateManyWithoutFare_attributeInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    destination_id?: NullableStringFieldUpdateOperationsInput | string | null
    contains_id?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopCreateManyLevelInput = {
    id?: string
    stop_id: string
    stop_code?: string | null
    stop_name: string
    stop_desc?: string | null
    stop_lat: number
    stop_lon: number
    zone_id?: string | null
    stop_url?: string | null
    location_type?: number | null
    wheelchair_boarding?: number | null
    parent_station?: string | null
    platform_code?: string | null
    tts_stop_name?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PathwayCreateManyLevelInput = {
    id?: string
    pathway_id: string
    from_stop_id: string
    to_stop_id: string
    pathway_mode: number
    is_bidirectional: number
    length?: number | null
    traversal_time?: number | null
    stair_count?: number | null
    max_slope?: number | null
    min_width?: number | null
    signposted_as?: string | null
    reversed_signposted_as?: string | null
    project_id: string
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StopUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutStopsNestedInput
    stopTimes?: StopTimeUpdateManyWithoutStopNestedInput
    transfers?: TransferUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUpdateManyWithoutToStopNestedInput
    parentStop?: StopUpdateOneWithoutChildStopsNestedInput
    childStops?: StopUpdateManyWithoutParentStopNestedInput
  }

  export type StopUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stopTimes?: StopTimeUncheckedUpdateManyWithoutStopNestedInput
    transfers?: TransferUncheckedUpdateManyWithoutFromStopNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStopNestedInput
    pathways?: PathwayUncheckedUpdateManyWithoutFromStopNestedInput
    pathwaysTo?: PathwayUncheckedUpdateManyWithoutToStopNestedInput
    childStops?: StopUncheckedUpdateManyWithoutParentStopNestedInput
  }

  export type StopUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    stop_id?: StringFieldUpdateOperationsInput | string
    stop_code?: NullableStringFieldUpdateOperationsInput | string | null
    stop_name?: StringFieldUpdateOperationsInput | string
    stop_desc?: NullableStringFieldUpdateOperationsInput | string | null
    stop_lat?: FloatFieldUpdateOperationsInput | number
    stop_lon?: FloatFieldUpdateOperationsInput | number
    zone_id?: NullableStringFieldUpdateOperationsInput | string | null
    stop_url?: NullableStringFieldUpdateOperationsInput | string | null
    location_type?: NullableIntFieldUpdateOperationsInput | number | null
    wheelchair_boarding?: NullableIntFieldUpdateOperationsInput | number | null
    parent_station?: NullableStringFieldUpdateOperationsInput | string | null
    platform_code?: NullableStringFieldUpdateOperationsInput | string | null
    tts_stop_name?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: UserProjectUpdateOneRequiredWithoutPathwaysNestedInput
    fromStop?: StopUpdateOneRequiredWithoutPathwaysNestedInput
    toStop?: StopUpdateOneRequiredWithoutPathwaysToNestedInput
  }

  export type PathwayUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathwayUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    pathway_id?: StringFieldUpdateOperationsInput | string
    from_stop_id?: StringFieldUpdateOperationsInput | string
    to_stop_id?: StringFieldUpdateOperationsInput | string
    pathway_mode?: IntFieldUpdateOperationsInput | number
    is_bidirectional?: IntFieldUpdateOperationsInput | number
    length?: NullableFloatFieldUpdateOperationsInput | number | null
    traversal_time?: NullableIntFieldUpdateOperationsInput | number | null
    stair_count?: NullableIntFieldUpdateOperationsInput | number | null
    max_slope?: NullableFloatFieldUpdateOperationsInput | number | null
    min_width?: NullableFloatFieldUpdateOperationsInput | number | null
    signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    reversed_signposted_as?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: StringFieldUpdateOperationsInput | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}